/*
 * This file is part of Dependency-Track.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 * Copyright (c) OWASP Foundation. All Rights Reserved.
 */
package org.dependencytrack.persistence.jdbi;

import alpine.persistence.PaginatedResult;
import alpine.resources.AlpineRequest;
import org.dependencytrack.PersistenceCapableTest;
import org.dependencytrack.model.Analysis;
import org.dependencytrack.model.AnalysisComment;
import org.dependencytrack.model.AnalysisJustification;
import org.dependencytrack.model.AnalysisResponse;
import org.dependencytrack.model.AnalysisState;
import org.dependencytrack.model.Component;
import org.dependencytrack.model.Project;
import org.dependencytrack.model.Vulnerability;
import org.dependencytrack.policy.vulnerability.VulnerabilityPolicy;
import org.dependencytrack.policy.vulnerability.VulnerabilityPolicyAnalysis;
import org.dependencytrack.policy.vulnerability.VulnerabilityPolicyOperation;
import org.dependencytrack.policy.vulnerability.VulnerabilityPolicyRating;
import org.jdbi.v3.core.Handle;
import org.junit.After;
import org.junit.Before;
import org.junit.Test;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.time.Instant;
import java.time.ZoneOffset;
import java.time.ZonedDateTime;
import java.util.Date;
import java.util.List;

import static org.assertj.core.api.Assertions.assertThat;
import static org.dependencytrack.persistence.jdbi.JdbiFactory.openJdbiHandle;
import static org.dependencytrack.persistence.jdbi.JdbiFactory.withJdbiHandle;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertNull;

public class VulnerabilityPolicyDaoTest extends PersistenceCapableTest {

    private Handle jdbiHandle;
    private VulnerabilityPolicyDao vulnPolicyDao;

    @Before
    public void before() throws Exception {
        super.before();

        jdbiHandle = openJdbiHandle();
        vulnPolicyDao = jdbiHandle.attach(VulnerabilityPolicyDao.class);
    }

    @After
    public void after() {
        if (jdbiHandle != null) {
            jdbiHandle.close();
        }

        super.after();
    }

    private static VulnerabilityPolicy getVulnerabilityPolicyInstance() throws ParseException {
        SimpleDateFormat formatter = new SimpleDateFormat("dd-MMM-yyyy");
        String validFromInString = "7-Jun-2020";
        Date validFrom = formatter.parse(validFromInString);

        String validUntilInString = "7-Jun-2023";
        Date validUntil = formatter.parse(validUntilInString);

        VulnerabilityPolicy vulnPolicy = new VulnerabilityPolicy();
        vulnPolicy.setConditions(List.of("vuln.id == \"CVE-123\" || vuln.aliases.exists(alias, alias.id == \"CVE-123\")",
                "component.name == \"foo\" && project.name == \"bar\" && \"internal\" in project.tags && !component.is_dependency_of(v1.Component{group: \"org.springframework.boot\"}"));
        vulnPolicy.setName("name");
        vulnPolicy.setValidFrom(ZonedDateTime.ofInstant(validFrom.toInstant(), ZoneOffset.UTC));
        vulnPolicy.setValidUntil(ZonedDateTime.ofInstant(validUntil.toInstant(), ZoneOffset.UTC));
        VulnerabilityPolicyAnalysis vulnerabilityPolicyAnalysis = new VulnerabilityPolicyAnalysis();
        vulnerabilityPolicyAnalysis.setState(VulnerabilityPolicyAnalysis.State.NOT_AFFECTED);
        vulnerabilityPolicyAnalysis.setJustification(VulnerabilityPolicyAnalysis.Justification.CODE_NOT_REACHABLE);
        vulnerabilityPolicyAnalysis.setDetails("something");
        vulnerabilityPolicyAnalysis.setSuppress(true);
        vulnPolicy.setAnalysis(vulnerabilityPolicyAnalysis);
        VulnerabilityPolicyRating rating = new VulnerabilityPolicyRating();
        rating.setSeverity(VulnerabilityPolicyRating.Severity.HIGH);
        rating.setMethod(VulnerabilityPolicyRating.Method.CVSSV3);
        rating.setScore(6.3);
        rating.setVector("CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:L");
        vulnPolicy.setRatings(List.of(rating));
        vulnPolicy.setOperationMode(VulnerabilityPolicyOperation.LOG);
        return vulnPolicy;
    }

    @Test
    public void testVulnerabilityPolicyIsCreated() throws Exception {

        VulnerabilityPolicy vulnPolicy = getVulnerabilityPolicyInstance();

        final VulnerabilityPolicy createdPolicy = vulnPolicyDao.create(vulnPolicy);

        assertThat(createdPolicy).isNotNull();

        List<VulnerabilityPolicy> vulnerabilityPolicies = vulnPolicyDao.getAll();

        assertNotNull(vulnerabilityPolicies);
        assertThat(vulnerabilityPolicies).hasSize(1);
        assertThat(vulnerabilityPolicies).satisfiesExactlyInAnyOrder(
                vulnerabilityPolicy -> {
                    assertThat(vulnerabilityPolicy).isNotNull();
                    assertThat(vulnerabilityPolicy.getCreated()).isNotNull();
                    assertThat(vulnerabilityPolicy.getConditions()).isEqualTo(vulnPolicy.getConditions());
                    assertThat(vulnerabilityPolicy.getAnalysis()).isNotNull();
                    assertThat(vulnerabilityPolicy.getAnalysis().getState().name()).isEqualTo(AnalysisState.NOT_AFFECTED.name());
                    assertThat(vulnerabilityPolicy.getAnalysis().isSuppress()).isTrue();
                    assertThat(vulnerabilityPolicy.getAnalysis().getJustification().name()).isEqualTo(AnalysisJustification.CODE_NOT_REACHABLE.name());
                    assertThat(vulnerabilityPolicy.getAnalysis().getDetails()).isEqualTo("something");
                    assertThat(vulnerabilityPolicy.getRatings()).isNotNull();
                    assertThat(vulnerabilityPolicy.getRatings()).hasSize(1);
                    assertThat(vulnerabilityPolicy.getRatings()).satisfiesExactlyInAnyOrder(
                            rating1 -> {
                                assertThat(rating1.getScore()).isEqualTo(6.3);
                                assertThat(rating1.getMethod()).isEqualTo(VulnerabilityPolicyRating.Method.CVSSV3);
                                assertThat(rating1.getSeverity()).isEqualTo(VulnerabilityPolicyRating.Severity.HIGH);
                                assertThat(rating1.getVector()).isEqualTo("CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:L");
                            });
                    assertThat(vulnerabilityPolicy.getOperationMode()).isEqualTo(VulnerabilityPolicyOperation.LOG);
                });
    }

    @Test
    public void testGetAllEnabledAndValid() {

        // Without validFrom and validUntil
        createPolicy("Foo-001", null, null, VulnerabilityPolicyOperation.APPLY);

        // validFrom in the future
        createPolicy("Foo-002", ZonedDateTime.ofInstant(Instant.now().plusSeconds(180), ZoneOffset.UTC), null, VulnerabilityPolicyOperation.APPLY);

        // validFrom in the past
        createPolicy("Foo-003", ZonedDateTime.ofInstant(Instant.now().minusSeconds(180), ZoneOffset.UTC), null, VulnerabilityPolicyOperation.APPLY);

        // validUntil in the future
        createPolicy("Foo-004", null, ZonedDateTime.ofInstant(Instant.now().plusSeconds(180), ZoneOffset.UTC), VulnerabilityPolicyOperation.APPLY);

        // validUntil in the past
        createPolicy("Foo-005", null, ZonedDateTime.ofInstant(Instant.now().minusSeconds(180), ZoneOffset.UTC), VulnerabilityPolicyOperation.APPLY);

        // validUntil in the past
        createPolicy("Foo-006", null, null, VulnerabilityPolicyOperation.DISABLED);

        // validUntil in the past
        createPolicy("Foo-007", null, null, VulnerabilityPolicyOperation.LOG);

        final List<VulnerabilityPolicy> validPolicies = vulnPolicyDao.getAllEnabledAndValid();
        assertThat(validPolicies).extracting(VulnerabilityPolicy::getName).containsExactly(
                "Foo-001",
                // Foo-002 is not yet valid
                "Foo-003",
                "Foo-004",
                // Foo-005 is expired
                // Foo-006 is Disabled
                "Foo-007"
        );
    }

    @Test
    public void testGetPageWithNoFilter() throws Exception {
        VulnerabilityPolicy vulnPolicy = vulnPolicyDao.create(getVulnerabilityPolicyInstance());
        assertThat(vulnPolicy).isNotNull();
        PaginatedResult result = vulnPolicyDao.getPage();
        assertNotNull(result);
        assertThat(result.getObjects()).hasSize(1);
    }

    @Test
    public void testGetPageWithFilter() throws Exception {
        VulnerabilityPolicy vulnPolicy = vulnPolicyDao.create(getVulnerabilityPolicyInstance());
        assertThat(vulnPolicy).isNotNull();

        final var request = new AlpineRequest(
                /* principal */ null,
                /* pagination */ null,
                /* filter */ "am",
                /* orderBy */ null,
                /* orderDirection */ null
        );
        PaginatedResult result = withJdbiHandle(request, handle -> handle.attach(VulnerabilityPolicyDao.class).getPage());
        assertNotNull(result);
        assertThat(result.getObjects()).hasSize(1);
    }

    @Test
    public void testGetPageWithFilterAndNameNotMatching() throws Exception {
        VulnerabilityPolicy vulnPolicy = vulnPolicyDao.create(getVulnerabilityPolicyInstance());
        assertThat(vulnPolicy).isNotNull();
        final var request = new AlpineRequest(
                /* principal */ null,
                /* pagination */ null,
                /* filter */ "othername",
                /* orderBy */ null,
                /* orderDirection */ null
        );
        PaginatedResult result = withJdbiHandle(request, handle -> handle.attach(VulnerabilityPolicyDao.class).getPage());
        assertNotNull(result);
        assertThat(result.getObjects()).hasSize(0);
    }

    @Test
    public void testGetByName() throws Exception {

        VulnerabilityPolicy vulnPolicy = getVulnerabilityPolicyInstance();

        VulnerabilityPolicy vulnerabilityPolicy = vulnPolicyDao.create(vulnPolicy);

        assertNotNull(vulnerabilityPolicy);
        assertThat(vulnerabilityPolicy).isNotNull();
        assertThat(vulnerabilityPolicy.getCreated()).isNotNull();
        assertThat(vulnerabilityPolicy.getUpdated()).isNull();
        assertThat(vulnerabilityPolicy.getConditions()).isEqualTo(vulnPolicy.getConditions());
        assertThat(vulnerabilityPolicy.getAnalysis()).isNotNull();
        assertThat(vulnerabilityPolicy.getAnalysis().getState().name()).isEqualTo(AnalysisState.NOT_AFFECTED.name());
        assertThat(vulnerabilityPolicy.getAnalysis().isSuppress()).isTrue();
        assertThat(vulnerabilityPolicy.getAnalysis().getJustification().name()).isEqualTo(AnalysisJustification.CODE_NOT_REACHABLE.name());
        assertThat(vulnerabilityPolicy.getAnalysis().getDetails()).isEqualTo("something");
        assertThat(vulnerabilityPolicy.getRatings()).isNotNull();
        assertThat(vulnerabilityPolicy.getRatings()).hasSize(1);
        assertThat(vulnerabilityPolicy.getRatings()).satisfiesExactlyInAnyOrder(
                rating1 -> {
                    assertThat(rating1.getScore()).isEqualTo(6.3);
                    assertThat(rating1.getMethod()).isEqualTo(VulnerabilityPolicyRating.Method.CVSSV3);
                    assertThat(rating1.getSeverity()).isEqualTo(VulnerabilityPolicyRating.Severity.HIGH);
                    assertThat(rating1.getVector()).isEqualTo("CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:L");
                });
        assertThat(vulnerabilityPolicy.getOperationMode()).isEqualTo(VulnerabilityPolicyOperation.LOG);
    }

    @Test
    public void testDeleteByName() throws Exception {

        VulnerabilityPolicy vulnPolicy = getVulnerabilityPolicyInstance();

        VulnerabilityPolicy vulnerabilityPolicy = vulnPolicyDao.create(vulnPolicy);

        assertNotNull(vulnerabilityPolicy);

        final int result = vulnPolicyDao.deleteByName("name");

        assertThat(result).isEqualTo(1);
    }

    @Test
    public void testUpdate() throws Exception {

        VulnerabilityPolicy vulnPolicy = getVulnerabilityPolicyInstance();

        VulnerabilityPolicy createdPolicy = vulnPolicyDao.create(vulnPolicy);

        assertNotNull(createdPolicy);
        createdPolicy.setAuthor("Jon Doe");
        createdPolicy.setOperationMode(VulnerabilityPolicyOperation.DISABLED);

        VulnerabilityPolicy updatedPolicy = vulnPolicyDao.update(createdPolicy);

        assertThat(updatedPolicy).isNotNull();
        assertThat(updatedPolicy.getCreated()).isNotNull();
        assertThat(updatedPolicy.getUpdated()).isNotNull();
        assertThat(updatedPolicy.getAuthor()).isEqualTo("Jon Doe");
        assertThat(updatedPolicy.getConditions()).isEqualTo(vulnPolicy.getConditions());
        assertThat(updatedPolicy.getAnalysis()).isNotNull();
        assertThat(updatedPolicy.getAnalysis().getState().name()).isEqualTo(AnalysisState.NOT_AFFECTED.name());
        assertThat(updatedPolicy.getAnalysis().isSuppress()).isTrue();
        assertThat(updatedPolicy.getAnalysis().getJustification().name()).isEqualTo(AnalysisJustification.CODE_NOT_REACHABLE.name());
        assertThat(updatedPolicy.getAnalysis().getDetails()).isEqualTo("something");
        assertThat(updatedPolicy.getRatings()).isNotNull();
        assertThat(updatedPolicy.getRatings()).hasSize(1);
        assertThat(updatedPolicy.getRatings()).satisfiesExactlyInAnyOrder(
                rating1 -> {
                    assertThat(rating1.getScore()).isEqualTo(6.3);
                    assertThat(rating1.getMethod()).isEqualTo(VulnerabilityPolicyRating.Method.CVSSV3);
                    assertThat(rating1.getSeverity()).isEqualTo(VulnerabilityPolicyRating.Severity.HIGH);
                    assertThat(rating1.getVector()).isEqualTo("CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:L");
                });
        assertThat(updatedPolicy.getOperationMode()).isEqualTo(VulnerabilityPolicyOperation.DISABLED);
    }

    @Test
    public void testVulnerabilityPolicyIsNotUpdatedWhenNothingChanged() throws Exception {
        VulnerabilityPolicy vulnPolicy = getVulnerabilityPolicyInstance();

        VulnerabilityPolicy createdPolicy = vulnPolicyDao.create(vulnPolicy);

        assertNotNull(createdPolicy);

        VulnerabilityPolicy updatedPolicy = vulnPolicyDao.update(createdPolicy);

        assertNull(updatedPolicy);
    }

    @Test
    public void testVulnerabilityPolicyIsDeleted() throws Exception {
        VulnerabilityPolicy vulnPolicy = vulnPolicyDao.create(getVulnerabilityPolicyInstance());
        assertThat(vulnPolicy).isNotNull();
        vulnPolicyDao.deleteByName(vulnPolicy.getName());
        List<VulnerabilityPolicy> policies = vulnPolicyDao.getAll();
        assertThat(policies).isEmpty();
    }

    @Test
    public void testVulnerabilityPolicyIsUnassignedAndDeleted() throws Exception {
        final var project = new Project();
        project.setName("acme-app");
        project.setVersion("1.0.0");
        qm.persist(project);

        final var component = new Component();
        component.setProject(project);
        component.setName("acme-lib");
        component.setVersion("2.0.0");
        qm.persist(component);

        final var vuln = new Vulnerability();
        vuln.setVulnId("CVE-100");
        vuln.setSource(Vulnerability.Source.NVD);
        qm.persist(vuln);

        final var analysis = new Analysis();
        analysis.setComponent(component);
        analysis.setVulnerability(vuln);
        analysis.setAnalysisState(AnalysisState.NOT_AFFECTED);
        analysis.setAnalysisJustification(AnalysisJustification.CODE_NOT_REACHABLE);
        analysis.setAnalysisResponse(AnalysisResponse.WILL_NOT_FIX);
        analysis.setAnalysisDetails("Foo");
        analysis.setSuppressed(true);
        qm.persist(analysis);

        final VulnerabilityPolicy vulnPolicy = vulnPolicyDao.create(getVulnerabilityPolicyInstance());
        assertThat(vulnPolicy).isNotNull();

        int count = jdbiHandle.createUpdate("""
                        UPDATE
                          "ANALYSIS"
                        SET
                          "VULNERABILITY_POLICY_ID" = (SELECT "ID" FROM "VULNERABILITY_POLICY" WHERE "NAME" = :vulnPolicyName)
                        WHERE
                          "ID" = :analysisId
                        """)
                .bind("vulnPolicyName", vulnPolicy.getName())
                .bind("analysisId", analysis.getId())
                .execute();
        assertThat(count).isEqualTo(1);

        vulnPolicyDao.unassignAndDeleteByName(vulnPolicy.getName());

        qm.getPersistenceManager().refresh(analysis);
        assertThat(analysis.getAnalysisState()).isEqualTo(AnalysisState.NOT_SET);
        assertThat(analysis.getAnalysisJustification()).isNull();
        assertThat(analysis.getAnalysisResponse()).isNull();
        assertThat(analysis.getAnalysisDetails()).isNull();
        assertThat(analysis.getVulnerabilityPolicyId()).isNull();
        assertThat(analysis.getAnalysisComments()).extracting(AnalysisComment::getCommenter).containsOnly("[Policy{Name=name}]");
        assertThat(analysis.getAnalysisComments()).extracting(AnalysisComment::getComment).containsExactlyInAnyOrder(
                "Policy removed",
                "Analysis: NOT_AFFECTED → NOT_SET",
                "Justification: CODE_NOT_REACHABLE → NOT_SET",
                "Vendor Response: WILL_NOT_FIX → NOT_SET",
                "Details: (None)",
                "Unsuppressed"
        );
    }

    private VulnerabilityPolicy createPolicy(String name, ZonedDateTime validFrom, ZonedDateTime validUntil, VulnerabilityPolicyOperation operationMode) {
        final var analysis = new VulnerabilityPolicyAnalysis();
        analysis.setState(VulnerabilityPolicyAnalysis.State.FALSE_POSITIVE);
        final var policy = new org.dependencytrack.policy.vulnerability.VulnerabilityPolicy();
        policy.setName(name);
        policy.setValidFrom(validFrom);
        policy.setValidUntil(validUntil);
        policy.setConditions(List.of("true"));
        policy.setAnalysis(analysis);
        policy.setOperationMode(operationMode);
        return vulnPolicyDao.create(policy);
    }
}
