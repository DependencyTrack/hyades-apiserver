/*
 * This file is part of Dependency-Track.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 * Copyright (c) OWASP Foundation. All Rights Reserved.
 */
package org.dependencytrack.persistence.jdbi;

import org.dependencytrack.PersistenceCapableTest;
import org.dependencytrack.model.VulnerabilityKey;
import org.jdbi.v3.core.Handle;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Named;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.Arguments;
import org.junit.jupiter.params.provider.MethodSource;

import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.UUID;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import static org.assertj.core.api.Assertions.assertThat;
import static org.dependencytrack.persistence.jdbi.JdbiFactory.openJdbiHandle;

class VulnerabilityAliasDaoTest extends PersistenceCapableTest {

    private Handle jdbiHandle;

    @BeforeEach
    public void before() throws Exception {
        super.before();
        jdbiHandle = openJdbiHandle();
    }

    @AfterEach
    public void after() {
        if (jdbiHandle != null) {
            jdbiHandle.close();
        }
        super.after();
    }

    @ParameterizedTest(name = "{0}")
    @MethodSource("shouldSyncAssertionsAndComputeGroupsArguments")
    void shouldSyncAssertionsAndComputeGroups(
            List<AssertionInput> assertionInputs,
            List<Set<VulnerabilityKey>> expectedGroups) {
        jdbiHandle.useTransaction(txHandle -> {
            final var dao = new VulnerabilityAliasDao(txHandle);

            final var assertionsByAsserter = new LinkedHashMap<String, Map<VulnerabilityKey, Set<VulnerabilityKey>>>();
            for (final AssertionInput assertionInput : assertionInputs) {
                assertionsByAsserter
                        .computeIfAbsent(assertionInput.asserter(), k -> new LinkedHashMap<>())
                        .put(assertionInput.vulnKey(), assertionInput.aliasKeys());
            }
            for (final var entry : assertionsByAsserter.entrySet()) {
                dao.syncAssertions(entry.getKey(), entry.getValue());
            }
        });

        assertThat(getAllAliasGroups()).containsExactlyInAnyOrderElementsOf(expectedGroups);
    }

    @Test
    void shouldSyncAssertionsAndCreateGroups() {
        jdbiHandle.useTransaction(txHandle -> {
            final var dao = new VulnerabilityAliasDao(txHandle);
            dao.syncAssertions(
                    "NVD",
                    vuln("CVE-1000", "NVD"),
                    Set.of(vuln("GHSA-1000", "GITHUB")));
        });

        assertThat(getAllAliasGroups()).singleElement().isEqualTo(
                Set.of(vuln("CVE-1000", "NVD"), vuln("GHSA-1000", "GITHUB")));
    }

    @Test
    void shouldSyncAssertionsAndMergeGroups() {
        jdbiHandle.useTransaction(txHandle -> {
            final var dao = new VulnerabilityAliasDao(txHandle);
            dao.syncAssertions(
                    "NVD",
                    vuln("CVE-1000", "NVD"),
                    Set.of(vuln("GHSA-1000", "GITHUB")));
            dao.syncAssertions(
                    "OSV",
                    vuln("GO-1000", "OSV"),
                    Set.of(vuln("SNYK-1000", "SNYK")));
        });
        assertThat(getAllAliasGroups()).hasSize(2);

        jdbiHandle.useTransaction(txHandle -> {
            final var dao = new VulnerabilityAliasDao(txHandle);
            dao.syncAssertions(
                    "NVD",
                    vuln("CVE-1000", "NVD"),
                    Set.of(vuln("GHSA-1000", "GITHUB"), vuln("GO-1000", "OSV")));
        });

        assertThat(getAllAliasGroups()).singleElement().isEqualTo(
                Set.of(
                        vuln("CVE-1000", "NVD"),
                        vuln("GHSA-1000", "GITHUB"),
                        vuln("GO-1000", "OSV"),
                        vuln("SNYK-1000", "SNYK")));
    }

    @Test
    void shouldImplicitlyRetractAlias() {
        jdbiHandle.useTransaction(txHandle -> {
            final var dao = new VulnerabilityAliasDao(txHandle);
            dao.syncAssertions(
                    "NVD",
                    vuln("CVE-1000", "NVD"),
                    Set.of(vuln("GHSA-1000", "GITHUB"), vuln("SNYK-1000", "SNYK")));
        });
        assertThat(getAllAliasGroups()).singleElement().isEqualTo(
                Set.of(vuln("CVE-1000", "NVD"), vuln("GHSA-1000", "GITHUB"), vuln("SNYK-1000", "SNYK")));

        jdbiHandle.useTransaction(txHandle -> {
            final var dao = new VulnerabilityAliasDao(txHandle);
            dao.syncAssertions(
                    "NVD",
                    vuln("CVE-1000", "NVD"),
                    Set.of(vuln("GHSA-1000", "GITHUB")));
        });

        assertThat(getAllAliasGroups()).singleElement().isEqualTo(
                Set.of(vuln("CVE-1000", "NVD"), vuln("GHSA-1000", "GITHUB")));
    }

    @Test
    void shouldSplitGroupOnRetraction() {
        jdbiHandle.useTransaction(txHandle -> {
            final var dao = new VulnerabilityAliasDao(txHandle);
            dao.syncAssertions(
                    "NVD",
                    vuln("CVE-1000", "NVD"),
                    Set.of(vuln("GHSA-1000", "GITHUB")));
            dao.syncAssertions(
                    "OSV",
                    vuln("GO-1000", "OSV"),
                    Set.of(vuln("CVE-1000", "NVD")));
        });
        assertThat(getAllAliasGroups()).singleElement().isEqualTo(
                Set.of(vuln("CVE-1000", "NVD"), vuln("GHSA-1000", "GITHUB"), vuln("GO-1000", "OSV")));

        jdbiHandle.useTransaction(txHandle -> {
            final var dao = new VulnerabilityAliasDao(txHandle);
            dao.syncAssertions("OSV", vuln("GO-1000", "OSV"), Set.of());
        });

        assertThat(getAllAliasGroups()).containsExactlyInAnyOrder(
                Set.of(vuln("CVE-1000", "NVD"), vuln("GHSA-1000", "GITHUB")));
    }

    @Test
    void shouldPreserveAliasFromOtherAsserter() {
        jdbiHandle.useTransaction(txHandle -> {
            final var dao = new VulnerabilityAliasDao(txHandle);
            dao.syncAssertions(
                    "NVD",
                    vuln("CVE-1000", "NVD"),
                    Set.of(vuln("GHSA-1000", "GITHUB")));
            dao.syncAssertions(
                    "OSV",
                    vuln("GO-1000", "OSV"),
                    Set.of(vuln("CVE-1000", "NVD"), vuln("GHSA-1000", "GITHUB")));
        });

        jdbiHandle.useTransaction(txHandle -> {
            final var dao = new VulnerabilityAliasDao(txHandle);
            dao.syncAssertions("NVD", vuln("CVE-1000", "NVD"), Set.of());
        });

        assertThat(getAllAliasGroups()).singleElement().isEqualTo(
                Set.of(vuln("CVE-1000", "NVD"), vuln("GHSA-1000", "GITHUB"), vuln("GO-1000", "OSV")));
    }

    @Test
    void shouldSkipWhenAssertionsUnchanged() {
        jdbiHandle.useTransaction(txHandle -> {
            final var dao = new VulnerabilityAliasDao(txHandle);
            dao.syncAssertions(
                    "NVD",
                    vuln("CVE-1000", "NVD"),
                    Set.of(vuln("GHSA-1000", "GITHUB")));
        });

        final List<Set<VulnerabilityKey>> groupsBefore = getAllAliasGroups();

        jdbiHandle.useTransaction(txHandle -> {
            final var dao = new VulnerabilityAliasDao(txHandle);
            dao.syncAssertions(
                    "NVD",
                    vuln("CVE-1000", "NVD"),
                    Set.of(vuln("GHSA-1000", "GITHUB")));
        });

        assertThat(getAllAliasGroups()).isEqualTo(groupsBefore);
    }

    @Test
    void shouldCleanUpUnknownAssertionsOnSync() {
        jdbiHandle.useTransaction(txHandle -> new VulnerabilityAliasDao(txHandle)
                .syncAssertions(
                        "UNKNOWN",
                        vuln("CVE-1000", "NVD"),
                        Set.of(vuln("GHSA-1000", "GITHUB"))));

        jdbiHandle.useTransaction(txHandle -> {
            final var dao = new VulnerabilityAliasDao(txHandle);
            dao.syncAssertions(
                    "NVD",
                    vuln("CVE-1000", "NVD"),
                    Set.of(vuln("GHSA-1000", "GITHUB"), vuln("SNYK-1000", "SNYK")));
        });

        assertThat(getAllAliasGroups()).singleElement().isEqualTo(
                Set.of(vuln("CVE-1000", "NVD"), vuln("GHSA-1000", "GITHUB"), vuln("SNYK-1000", "SNYK")));

        final long unknownCount = jdbiHandle.createQuery("""
                        SELECT COUNT(*)
                         FROM "VULNERABILITY_ALIAS_ASSERTION"
                         WHERE "ASSERTER" = 'UNKNOWN'
                           AND "VULN_SOURCE" = 'NVD'
                           AND "VULN_ID" = 'CVE-1000'
                        """)
                .mapTo(Long.class).one();
        assertThat(unknownCount).isZero();
    }

    @Test
    void shouldHandleEmptyAliasesForVulnWithNoHistory() {
        jdbiHandle.useTransaction(txHandle -> {
            final var dao = new VulnerabilityAliasDao(txHandle);
            dao.syncAssertions("NVD", vuln("CVE-1000", "NVD"), Set.of());
        });

        assertThat(getAllAliasGroups()).isEmpty();
    }

    @Test
    void shouldMergeMultipleGroupsIntoOne() {
        jdbiHandle.useTransaction(txHandle -> {
            final var dao = new VulnerabilityAliasDao(txHandle);
            dao.syncAssertions("A0", vuln("CVE-1", "NVD"), Set.of(vuln("GHSA-1", "GITHUB")));
            dao.syncAssertions("A1", vuln("SNYK-1", "SNYK"), Set.of(vuln("GO-1", "OSV")));
        });

        assertThat(getAllAliasGroups()).hasSize(2);

        jdbiHandle.useTransaction(txHandle -> new VulnerabilityAliasDao(txHandle)
                .syncAssertions("A2", vuln("CVE-1", "NVD"), Set.of(vuln("SNYK-1", "SNYK"))));

        assertThat(getAllAliasGroups()).singleElement().isEqualTo(
                Set.of(
                        vuln("CVE-1", "NVD"),
                        vuln("GHSA-1", "GITHUB"),
                        vuln("SNYK-1", "SNYK"),
                        vuln("GO-1", "OSV")));
    }

    private record AliasRow(UUID groupId, String source, String vulnId) {
    }

    private List<Set<VulnerabilityKey>> getAllAliasGroups() {
        return jdbiHandle
                .createQuery("""
                        SELECT "GROUP_ID", "SOURCE", "VULN_ID"
                          FROM "VULNERABILITY_ALIAS"
                         ORDER BY "GROUP_ID", "SOURCE", "VULN_ID"
                        """)
                .map((rs, ctx) -> new AliasRow(
                        rs.getObject("GROUP_ID", UUID.class),
                        rs.getString("SOURCE"),
                        rs.getString("VULN_ID")))
                .list()
                .stream()
                .collect(Collectors.groupingBy(AliasRow::groupId))
                .values().stream()
                .map(rows -> rows.stream()
                        .map(row -> vuln(row.vulnId(), row.source()))
                        .collect(Collectors.<VulnerabilityKey>toUnmodifiableSet()))
                .toList();
    }

    private record AssertionInput(String asserter, VulnerabilityKey vulnKey, Set<VulnerabilityKey> aliasKeys) {
    }

    private static AssertionInput a(int asserterId, VulnerabilityKey vulnKey, VulnerabilityKey... aliasKeys) {
        return new AssertionInput("A" + asserterId, vulnKey, Set.of(aliasKeys));
    }

    private static VulnerabilityKey vuln(String vulnId, String source) {
        return new VulnerabilityKey(vulnId, source);
    }

    private static Stream<Arguments> shouldSyncAssertionsAndComputeGroupsArguments() {
        return Stream.of(
                Arguments.of(
                        Named.of("disjoint identifiers are not merged", List.of(
                                a(0, vuln("GHSA-1000", "GITHUB"), vuln("SNYK-2000", "SNYK")),
                                a(1, vuln("CVE-1000", "NVD"), vuln("SNYK-1000", "SNYK")))),
                        List.of(
                                Set.of(vuln("CVE-1000", "NVD"), vuln("SNYK-1000", "SNYK")),
                                Set.of(vuln("GHSA-1000", "GITHUB"), vuln("SNYK-2000", "SNYK")))
                ),
                Arguments.of(
                        Named.of("shared identifier merges into same group", List.of(
                                a(0, vuln("CVE-1000", "NVD"), vuln("GO-1000", "OSV")),
                                a(1, vuln("CVE-1000", "NVD"), vuln("GO-2000", "OSV")),
                                a(2, vuln("CVE-1000", "NVD"), vuln("GO-2000", "OSV"), vuln("SNYK-1000", "SNYK")))),
                        List.of(
                                Set.of(
                                        vuln("CVE-1000", "NVD"),
                                        vuln("GO-1000", "OSV"),
                                        vuln("GO-2000", "OSV"),
                                        vuln("SNYK-1000", "SNYK")))
                ),
                Arguments.of(
                        Named.of("disjoint identifiers are not merged (a)", List.of(
                                a(0, vuln("CVE-1000", "NVD"), vuln("SNYK-1000", "SNYK")),
                                a(1, vuln("GHSA-1000", "GITHUB"), vuln("GO-1000", "OSV")))),
                        List.of(
                                Set.of(vuln("CVE-1000", "NVD"), vuln("SNYK-1000", "SNYK")),
                                Set.of(vuln("GHSA-1000", "GITHUB"), vuln("GO-1000", "OSV")))
                ),
                Arguments.of(
                        Named.of("disjoint identifiers are not merged (b)", List.of(
                                a(0, vuln("GHSA-1000", "GITHUB"), vuln("GO-1000", "OSV")),
                                a(1, vuln("CVE-1000", "NVD"), vuln("SNYK-1000", "SNYK")))),
                        List.of(
                                Set.of(vuln("CVE-1000", "NVD"), vuln("SNYK-1000", "SNYK")),
                                Set.of(vuln("GHSA-1000", "GITHUB"), vuln("GO-1000", "OSV")))
                ),
                Arguments.of(
                        Named.of("one matching identifier merges (a)", List.of(
                                a(0, vuln("CVE-1000", "NVD"), vuln("GO-1000", "OSV")),
                                a(1, vuln("CVE-1000", "NVD"), vuln("SNYK-1000", "SNYK")))),
                        List.of(
                                Set.of(
                                        vuln("CVE-1000", "NVD"),
                                        vuln("GO-1000", "OSV"),
                                        vuln("SNYK-1000", "SNYK")))
                ),
                Arguments.of(
                        Named.of("one matching identifier merges (b)", List.of(
                                a(0, vuln("CVE-1000", "NVD"), vuln("SNYK-1000", "SNYK")),
                                a(1, vuln("CVE-1000", "NVD"), vuln("GO-1000", "OSV")))),
                        List.of(
                                Set.of(
                                        vuln("CVE-1000", "NVD"),
                                        vuln("SNYK-1000", "SNYK"),
                                        vuln("GO-1000", "OSV")))
                ),
                Arguments.of(
                        Named.of("one matching with multiple additional merges (a)", List.of(
                                a(0, vuln("CVE-1000", "NVD"), vuln("SNYK-1000", "SNYK")),
                                a(1, vuln("CVE-1000", "NVD"), vuln("GHSA-1000", "GITHUB"), vuln("GO-1000", "OSV")))),
                        List.of(
                                Set.of(
                                        vuln("CVE-1000", "NVD"),
                                        vuln("SNYK-1000", "SNYK"),
                                        vuln("GHSA-1000", "GITHUB"),
                                        vuln("GO-1000", "OSV")))
                ),
                Arguments.of(
                        Named.of("one matching with multiple additional merges (b)", List.of(
                                a(0, vuln("CVE-1000", "NVD"), vuln("GHSA-1000", "GITHUB"), vuln("GO-1000", "OSV")),
                                a(1, vuln("CVE-1000", "NVD"), vuln("SNYK-1000", "SNYK")))),
                        List.of(
                                Set.of(
                                        vuln("CVE-1000", "NVD"),
                                        vuln("GHSA-1000", "GITHUB"),
                                        vuln("GO-1000", "OSV"),
                                        vuln("SNYK-1000", "SNYK")))
                ),
                Arguments.of(
                        Named.of("two matching identifiers merge (a)", List.of(
                                a(0, vuln("CVE-1000", "NVD"), vuln("GHSA-1000", "GITHUB"), vuln("SNYK-1000", "SNYK")),
                                a(1, vuln("CVE-1000", "NVD"), vuln("GHSA-1000", "GITHUB"), vuln("GO-1000", "OSV")))),
                        List.of(
                                Set.of(
                                        vuln("CVE-1000", "NVD"),
                                        vuln("GHSA-1000", "GITHUB"),
                                        vuln("SNYK-1000", "SNYK"),
                                        vuln("GO-1000", "OSV")))
                ),
                Arguments.of(
                        Named.of("two matching identifiers merge (b)", List.of(
                                a(0, vuln("CVE-1000", "NVD"), vuln("GHSA-1000", "GITHUB"), vuln("GO-1000", "OSV")),
                                a(1, vuln("CVE-1000", "NVD"), vuln("GHSA-1000", "GITHUB"), vuln("SNYK-1000", "SNYK")))),
                        List.of(
                                Set.of(
                                        vuln("CVE-1000", "NVD"),
                                        vuln("GHSA-1000", "GITHUB"),
                                        vuln("GO-1000", "OSV"),
                                        vuln("SNYK-1000", "SNYK")))
                ),
                Arguments.of(
                        Named.of("multiple IDs per source are all preserved", List.of(
                                a(0, vuln("CVE-1000", "NVD"), vuln("GO-1000", "OSV")),
                                a(1, vuln("CVE-1000", "NVD"), vuln("GO-2000", "OSV")))),
                        List.of(
                                Set.of(
                                        vuln("CVE-1000", "NVD"),
                                        vuln("GO-1000", "OSV"),
                                        vuln("GO-2000", "OSV")))
                ),
                Arguments.of(
                        Named.of("identical identifiers do not create duplicates", List.of(
                                a(0, vuln("CVE-1000", "NVD"), vuln("SNYK-1000", "SNYK")),
                                a(1, vuln("CVE-1000", "NVD"), vuln("SNYK-1000", "SNYK")))),
                        List.of(
                                Set.of(vuln("CVE-1000", "NVD"), vuln("SNYK-1000", "SNYK")))
                ),
                Arguments.of(
                        Named.of("GO-2022-0586", List.of(
                                a(0, vuln("CVE-2022-26945", "NVD"), vuln("GO-2022-0586", "OSV")),
                                a(1, vuln("CVE-2022-30321", "NVD"), vuln("GO-2022-0586", "OSV")),
                                a(2, vuln("CVE-2022-30322", "NVD"), vuln("GO-2022-0586", "OSV")),
                                a(3, vuln("CVE-2022-30323", "NVD"), vuln("GO-2022-0586", "OSV")),
                                a(4, vuln("GHSA-28r2-q6m8-9hpx", "GITHUB"), vuln("GO-2022-0586", "OSV")),
                                a(5, vuln("GHSA-cjr4-fv6c-f3mv", "GITHUB"), vuln("GO-2022-0586", "OSV")),
                                a(6, vuln("GHSA-fcgg-rvwg-jv58", "GITHUB"), vuln("GO-2022-0586", "OSV")),
                                a(7, vuln("GHSA-x24g-9w7v-vprh", "GITHUB"), vuln("GO-2022-0586", "OSV")))),
                        List.of(
                                Set.of(
                                        vuln("CVE-2022-26945", "NVD"),
                                        vuln("CVE-2022-30321", "NVD"),
                                        vuln("CVE-2022-30322", "NVD"),
                                        vuln("CVE-2022-30323", "NVD"),
                                        vuln("GHSA-28r2-q6m8-9hpx", "GITHUB"),
                                        vuln("GHSA-cjr4-fv6c-f3mv", "GITHUB"),
                                        vuln("GHSA-fcgg-rvwg-jv58", "GITHUB"),
                                        vuln("GHSA-x24g-9w7v-vprh", "GITHUB"),
                                        vuln("GO-2022-0586", "OSV")))
                ),
                Arguments.of(
                        Named.of("SNYK-JAVA-ORGECLIPSEJETTY-2945452/53", List.of(
                                a(0, vuln("CVE-1000", "NVD"), vuln("SNYK-1000", "SNYK")),
                                a(1, vuln("GHSA-1000", "GITHUB"), vuln("SNYK-1000", "SNYK")),
                                a(2, vuln("GHSA-1000", "GITHUB"), vuln("SNYK-2000", "SNYK")),
                                a(3, vuln("CVE-1000", "NVD"), vuln("SNYK-2000", "SNYK")))),
                        List.of(
                                Set.of(
                                        vuln("CVE-1000", "NVD"),
                                        vuln("GHSA-1000", "GITHUB"),
                                        vuln("SNYK-1000", "SNYK"),
                                        vuln("SNYK-2000", "SNYK")))
                ),
                Arguments.of(
                        Named.of("SNYK-JAVA-COMFASTERXMLWOODSTOX-3091135", List.of(
                                a(0, vuln("GHSA-9fwf-46g9-45rx", "GITHUB"), vuln("SNYK-JAVA-COMFASTERXMLWOODSTOX-3091135", "SNYK")),
                                a(1, vuln("GHSA-3f7h-mf4q-vrm4", "GITHUB"), vuln("SNYK-JAVA-COMFASTERXMLWOODSTOX-3091135", "SNYK")),
                                a(2, vuln("GHSA-5hc5-c3m9-8vcj", "GITHUB"), vuln("SNYK-JAVA-COMFASTERXMLWOODSTOX-3091135", "SNYK")),
                                a(3, vuln("GHSA-fv22-xp26-mm9w", "GITHUB"), vuln("SNYK-JAVA-COMFASTERXMLWOODSTOX-3091135", "SNYK")),
                                a(4, vuln("GHSA-4rv7-wj6m-6c6r", "GITHUB"), vuln("SNYK-JAVA-COMFASTERXMLWOODSTOX-3091135", "SNYK")),
                                a(5, vuln("CVE-2022-40152", "NVD"), vuln("SNYK-JAVA-COMFASTERXMLWOODSTOX-3091135", "SNYK")),
                                a(6, vuln("CVE-2022-40152", "NVD"), vuln("GHSA-3f7h-mf4q-vrm4", "GITHUB")),
                                a(7, vuln("CVE-2022-40154", "NVD"), vuln("GHSA-9fwf-46g9-45rx", "GITHUB")),
                                a(8, vuln("CVE-2022-40156", "NVD"), vuln("GHSA-4rv7-wj6m-6c6r", "GITHUB")),
                                a(9, vuln("CVE-2022-40153", "NVD"), vuln("GHSA-fv22-xp26-mm9w", "GITHUB")),
                                a(10, vuln("CVE-2022-40155", "NVD"), vuln("GHSA-5hc5-c3m9-8vcj", "GITHUB")))),
                        List.of(
                                Set.of(
                                        vuln("CVE-2022-40152", "NVD"),
                                        vuln("CVE-2022-40153", "NVD"),
                                        vuln("CVE-2022-40154", "NVD"),
                                        vuln("CVE-2022-40155", "NVD"),
                                        vuln("CVE-2022-40156", "NVD"),
                                        vuln("GHSA-9fwf-46g9-45rx", "GITHUB"),
                                        vuln("GHSA-3f7h-mf4q-vrm4", "GITHUB"),
                                        vuln("GHSA-5hc5-c3m9-8vcj", "GITHUB"),
                                        vuln("GHSA-fv22-xp26-mm9w", "GITHUB"),
                                        vuln("GHSA-4rv7-wj6m-6c6r", "GITHUB"),
                                        vuln("SNYK-JAVA-COMFASTERXMLWOODSTOX-3091135", "SNYK")))
                ),
                Arguments.of(
                        Named.of("SNYK-JAVA-IONETTY-10822*", List.of(
                                a(0, vuln("CVE-2021-21290", "NVD"), vuln("SNYK-JAVA-IONETTY-1082234", "SNYK")),
                                a(1, vuln("GHSA-5mcr-gq6c-3hq2", "GITHUB"), vuln("SNYK-JAVA-IONETTY-1082234", "SNYK")),
                                a(2, vuln("CVE-2021-21290", "NVD"), vuln("SNYK-JAVA-IONETTY-1082235", "SNYK")),
                                a(3, vuln("GHSA-5mcr-gq6c-3hq2", "GITHUB"), vuln("SNYK-JAVA-IONETTY-1082235", "SNYK")),
                                a(4, vuln("CVE-2021-21290", "NVD"), vuln("SNYK-JAVA-IONETTY-1082236", "SNYK")),
                                a(5, vuln("GHSA-5mcr-gq6c-3hq2", "GITHUB"), vuln("SNYK-JAVA-IONETTY-1082236", "SNYK")),
                                a(6, vuln("CVE-2021-21290", "NVD"), vuln("SNYK-JAVA-IONETTY-1082238", "SNYK")),
                                a(7, vuln("GHSA-5mcr-gq6c-3hq2", "GITHUB"), vuln("SNYK-JAVA-IONETTY-1082238", "SNYK")),
                                a(8, vuln("CVE-2021-21290", "NVD"), vuln("GHSA-5mcr-gq6c-3hq2", "GITHUB")))),
                        List.of(
                                Set.of(
                                        vuln("CVE-2021-21290", "NVD"),
                                        vuln("GHSA-5mcr-gq6c-3hq2", "GITHUB"),
                                        vuln("SNYK-JAVA-IONETTY-1082234", "SNYK"),
                                        vuln("SNYK-JAVA-IONETTY-1082235", "SNYK"),
                                        vuln("SNYK-JAVA-IONETTY-1082236", "SNYK"),
                                        vuln("SNYK-JAVA-IONETTY-1082238", "SNYK")))
                )
        );
    }

}
