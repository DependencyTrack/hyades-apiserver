/*
 * This file is part of Dependency-Track.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 * Copyright (c) OWASP Foundation. All Rights Reserved.
 */
package org.dependencytrack.vulnanalysis;

import org.dependencytrack.PersistenceCapableTest;
import org.dependencytrack.model.Severity;
import org.dependencytrack.model.VulnIdAndSource;
import org.dependencytrack.model.Vulnerability;
import org.dependencytrack.model.Vulnerability.Source;
import org.jdbi.v3.core.Handle;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import java.math.BigDecimal;
import java.util.Date;
import java.util.List;
import java.util.Map;

import static org.assertj.core.api.Assertions.assertThat;
import static org.dependencytrack.persistence.jdbi.JdbiFactory.openJdbiHandle;

class VulnerabilityDaoTest extends PersistenceCapableTest {

    private Handle jdbiHandle;
    private VulnerabilityDao dao;

    @BeforeEach
    void beforeEach() {
        jdbiHandle = openJdbiHandle();
        dao = new VulnerabilityDao(jdbiHandle);
    }

    @AfterEach
    void afterEach() {
        if (jdbiHandle != null) {
            jdbiHandle.close();
        }
    }

    @Test
    void syncAllShouldReturnPrePopulatedIdsWithoutDbAccess() {
        final var vuln = new Vulnerability();
        vuln.setId(42);
        vuln.setVulnId("CVE-2024-0001");
        vuln.setSource(Source.NVD);

        final Map<VulnIdAndSource, Long> result = dao.syncAll(
                List.of(vuln), source -> true);

        assertThat(result).containsExactlyEntriesOf(
                Map.of(new VulnIdAndSource("CVE-2024-0001", "NVD"), 42L));
    }

    @Test
    void syncAllShouldInsertNewVulnerability() {
        final var vuln = new Vulnerability();
        vuln.setVulnId("CVE-2024-0001");
        vuln.setSource(Source.NVD);
        vuln.setDescription("Test vulnerability");
        vuln.setSeverity(Severity.HIGH);

        final Map<VulnIdAndSource, Long> result = dao.syncAll(
                List.of(vuln), source -> true);

        assertThat(result).hasSize(1);
        final long dbId = result.get(new VulnIdAndSource("CVE-2024-0001", "NVD"));
        assertThat(dbId).isPositive();

        assertThat(getVulnDescriptionById(dbId)).isEqualTo("Test vulnerability");
    }

    @Test
    void syncAllShouldResolveExistingVulnerabilityWhenNotUpdatable() {
        final long existingId = createVuln("CVE-2024-0001", Source.NVD, "Original", new Date(1000));

        final var incoming = new Vulnerability();
        incoming.setVulnId("CVE-2024-0001");
        incoming.setSource(Source.NVD);
        incoming.setDescription("Should not overwrite");
        incoming.setUpdated(new Date(2000));

        final Map<VulnIdAndSource, Long> result = dao.syncAll(
                List.of(incoming), source -> false);

        assertThat(result).containsExactlyEntriesOf(
                Map.of(new VulnIdAndSource("CVE-2024-0001", "NVD"), existingId));
        assertThat(getVulnDescriptionById(existingId)).isEqualTo("Original");
    }

    @Test
    void syncAllShouldInsertNewVulnerabilityEvenWhenNotUpdatable() {
        final var vuln = new Vulnerability();
        vuln.setVulnId("CVE-2024-0001");
        vuln.setSource(Source.NVD);
        vuln.setDescription("Inserted despite not updatable");

        final Map<VulnIdAndSource, Long> result = dao.syncAll(
                List.of(vuln), source -> false);

        assertThat(result).hasSize(1);
        final long dbId = result.get(new VulnIdAndSource("CVE-2024-0001", "NVD"));
        assertThat(dbId).isPositive();

        assertThat(getVulnDescriptionById(dbId)).isEqualTo("Inserted despite not updatable");
    }

    @Test
    void syncAllShouldUpdateExistingVulnerabilityWhenUpdatable() {
        final long existingId = createVuln("CVE-2024-0001", Source.NVD, "Original", new Date(1000));

        final var incoming = new Vulnerability();
        incoming.setVulnId("CVE-2024-0001");
        incoming.setSource(Source.NVD);
        incoming.setDescription("Updated");
        incoming.setUpdated(new Date(2000));

        final Map<VulnIdAndSource, Long> result = dao.syncAll(
                List.of(incoming), source -> true);

        assertThat(result).containsExactlyEntriesOf(
                Map.of(new VulnIdAndSource("CVE-2024-0001", "NVD"), existingId));
        assertThat(getVulnDescriptionById(existingId)).isEqualTo("Updated");
    }

    @Test
    void syncAllShouldNotUpdateWhenIncomingDataIsOlder() {
        final long existingId = createVuln("CVE-2024-0001", Source.NVD, "Newer data", new Date(2000));

        final var incoming = new Vulnerability();
        incoming.setVulnId("CVE-2024-0001");
        incoming.setSource(Source.NVD);
        incoming.setDescription("Older data");
        incoming.setUpdated(new Date(1000));

        final Map<VulnIdAndSource, Long> result = dao.syncAll(
                List.of(incoming), source -> true);

        assertThat(result).containsExactlyEntriesOf(
                Map.of(new VulnIdAndSource("CVE-2024-0001", "NVD"), existingId));
        assertThat(getVulnDescriptionById(existingId)).isEqualTo("Newer data");
    }

    @Test
    void syncAllShouldHandleMixOfPrePopulatedAndNewVulnerabilities() {
        final var preResolved = new Vulnerability();
        preResolved.setId(99);
        preResolved.setVulnId("INT-001");
        preResolved.setSource(Source.INTERNAL);

        final var newVuln = new Vulnerability();
        newVuln.setVulnId("CVE-2024-0001");
        newVuln.setSource(Source.NVD);
        newVuln.setDescription("New");

        final Map<VulnIdAndSource, Long> result = dao.syncAll(
                List.of(preResolved, newVuln), source -> true);

        assertThat(result).hasSize(2);
        assertThat(result).containsEntry(new VulnIdAndSource("INT-001", "INTERNAL"), 99L);
        assertThat(result.get(new VulnIdAndSource("CVE-2024-0001", "NVD"))).isPositive();
    }

    @Test
    void syncAllShouldNotUpdateExistingWhenNotUpdatableButStillInsertNonExisting() {
        final long existingId = createVuln("CVE-2024-0001", Source.NVD, "Original", new Date(1000));

        final var existingVuln = new Vulnerability();
        existingVuln.setVulnId("CVE-2024-0001");
        existingVuln.setSource(Source.NVD);
        existingVuln.setDescription("Should not overwrite");
        existingVuln.setUpdated(new Date(2000));

        final var newVuln = new Vulnerability();
        newVuln.setVulnId("CVE-2024-0002");
        newVuln.setSource(Source.NVD);
        newVuln.setDescription("New vuln");

        final Map<VulnIdAndSource, Long> result = dao.syncAll(
                List.of(existingVuln, newVuln), source -> false);

        assertThat(result).hasSize(2);
        assertThat(result).containsEntry(new VulnIdAndSource("CVE-2024-0001", "NVD"), existingId);
        assertThat(getVulnDescriptionById(existingId)).isEqualTo("Original");

        final long newId = result.get(new VulnIdAndSource("CVE-2024-0002", "NVD"));
        assertThat(newId).isPositive();
        assertThat(getVulnDescriptionById(newId)).isEqualTo("New vuln");
    }

    @Test
    void syncAllShouldPopulateAllColumns() {
        final var vuln = new Vulnerability();
        vuln.setVulnId("CVE-2024-0001");
        vuln.setSource(Source.NVD);
        vuln.setFriendlyVulnId("friendly-id");
        vuln.setTitle("Test Title");
        vuln.setSubTitle("Test SubTitle");
        vuln.setDescription("Test Description");
        vuln.setDetail("Test Detail");
        vuln.setRecommendation("Test Recommendation");
        vuln.setReferences("Test References");
        vuln.setCredits("Test Credits");
        vuln.setCreated(new Date(1000));
        vuln.setPublished(new Date(2000));
        vuln.setUpdated(new Date(3000));
        vuln.setCwes(List.of(79, 89));
        vuln.setCvssV2BaseScore(new BigDecimal("6.8"));
        vuln.setCvssV2ImpactSubScore(new BigDecimal("6.4"));
        vuln.setCvssV2ExploitabilitySubScore(new BigDecimal("8.6"));
        vuln.setCvssV2Vector("(AV:N/AC:M/Au:N/C:P/I:P/A:P)");
        vuln.setCvssV3BaseScore(new BigDecimal("9.8"));
        vuln.setCvssV3ImpactSubScore(new BigDecimal("5.9"));
        vuln.setCvssV3ExploitabilitySubScore(new BigDecimal("3.9"));
        vuln.setCvssV3Vector("CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H");
        vuln.setCvssV4Score(new BigDecimal("5.9"));
        vuln.setCvssV4Vector("CVSS:4.0/AV:L/AC:L/AT:N/PR:H/UI:N/VC:N/VI:N/VA:N/SC:H/SI:N/SA:N");
        vuln.setOwaspRRLikelihoodScore(new BigDecimal("4.5"));
        vuln.setOwaspRRTechnicalImpactScore(new BigDecimal("5.0"));
        vuln.setOwaspRRBusinessImpactScore(new BigDecimal("3.5"));
        vuln.setOwaspRRVector("SL:5/M:5/O:2/S:9/ED:4/EE:2/A:7/ID:2/LC:2/LI:2/LAV:7/LAC:9/FD:3/RD:5/NC:0/PV:7");
        vuln.setSeverity(Severity.CRITICAL);
        vuln.setVulnerableVersions("< 2.0.0");
        vuln.setPatchedVersions(">= 2.0.0");

        dao.syncAll(List.of(vuln), source -> true);

        final Vulnerability persisted = qm.getVulnerabilityByVulnId(Source.NVD, "CVE-2024-0001");
        assertThat(persisted).isNotNull();
        assertThat(persisted.getVulnId()).isEqualTo(vuln.getVulnId());
        assertThat(persisted.getSource()).isEqualTo(vuln.getSource());
        assertThat(persisted.getFriendlyVulnId()).isEqualTo(vuln.getFriendlyVulnId());
        assertThat(persisted.getTitle()).isEqualTo(vuln.getTitle());
        assertThat(persisted.getSubTitle()).isEqualTo(vuln.getSubTitle());
        assertThat(persisted.getDescription()).isEqualTo(vuln.getDescription());
        assertThat(persisted.getDetail()).isEqualTo(vuln.getDetail());
        assertThat(persisted.getRecommendation()).isEqualTo(vuln.getRecommendation());
        assertThat(persisted.getReferences()).isEqualTo(vuln.getReferences());
        assertThat(persisted.getCredits()).isEqualTo(vuln.getCredits());
        assertThat(persisted.getCreated()).isEqualTo(vuln.getCreated());
        assertThat(persisted.getPublished()).isEqualTo(vuln.getPublished());
        assertThat(persisted.getUpdated()).isEqualTo(vuln.getUpdated());
        assertThat(persisted.getCwes()).isEqualTo(vuln.getCwes());
        assertThat(persisted.getCvssV2BaseScore()).isEqualByComparingTo(vuln.getCvssV2BaseScore());
        assertThat(persisted.getCvssV2ImpactSubScore()).isEqualByComparingTo(vuln.getCvssV2ImpactSubScore());
        assertThat(persisted.getCvssV2ExploitabilitySubScore()).isEqualByComparingTo(vuln.getCvssV2ExploitabilitySubScore());
        assertThat(persisted.getCvssV2Vector()).isEqualTo(vuln.getCvssV2Vector());
        assertThat(persisted.getCvssV3BaseScore()).isEqualByComparingTo(vuln.getCvssV3BaseScore());
        assertThat(persisted.getCvssV3ImpactSubScore()).isEqualByComparingTo(vuln.getCvssV3ImpactSubScore());
        assertThat(persisted.getCvssV3ExploitabilitySubScore()).isEqualByComparingTo(vuln.getCvssV3ExploitabilitySubScore());
        assertThat(persisted.getCvssV3Vector()).isEqualTo(vuln.getCvssV3Vector());
        assertThat(persisted.getCvssV4Score()).isEqualByComparingTo(vuln.getCvssV4Score());
        assertThat(persisted.getCvssV4Vector()).isEqualTo(vuln.getCvssV4Vector());
        assertThat(persisted.getOwaspRRLikelihoodScore()).isEqualByComparingTo(vuln.getOwaspRRLikelihoodScore());
        assertThat(persisted.getOwaspRRTechnicalImpactScore()).isEqualByComparingTo(vuln.getOwaspRRTechnicalImpactScore());
        assertThat(persisted.getOwaspRRBusinessImpactScore()).isEqualByComparingTo(vuln.getOwaspRRBusinessImpactScore());
        assertThat(persisted.getOwaspRRVector()).isEqualTo(vuln.getOwaspRRVector());
        assertThat(persisted.getSeverity()).isEqualTo(vuln.getSeverity());
        assertThat(persisted.getVulnerableVersions()).isEqualTo(vuln.getVulnerableVersions());
        assertThat(persisted.getPatchedVersions()).isEqualTo(vuln.getPatchedVersions());
        assertThat(persisted.getUuid()).isNotNull();
    }

    @Test
    void syncAllShouldHandlePerSourceUpdatePredicate() {
        final long nvdId = createVuln("CVE-2024-0001", Source.NVD, "NVD original", new Date(1000));

        final var nvdVuln = new Vulnerability();
        nvdVuln.setVulnId("CVE-2024-0001");
        nvdVuln.setSource(Source.NVD);
        nvdVuln.setDescription("NVD updated");
        nvdVuln.setUpdated(new Date(2000));

        final var ghVuln = new Vulnerability();
        ghVuln.setVulnId("GHSA-0001");
        ghVuln.setSource(Source.GITHUB);
        ghVuln.setDescription("GitHub new");

        final Map<VulnIdAndSource, Long> result = dao.syncAll(
                List.of(nvdVuln, ghVuln),
                source -> !"NVD".equals(source));

        assertThat(result).hasSize(2);
        assertThat(getVulnDescriptionById(nvdId)).isEqualTo("NVD original");
        assertThat(getVulnDescriptionById(result.get(new VulnIdAndSource("GHSA-0001", "GITHUB"))))
                .isEqualTo("GitHub new");
    }

    private long createVuln(String vulnId, Source source, String description, Date updated) {
        final var vuln = new Vulnerability();
        vuln.setVulnId(vulnId);
        vuln.setSource(source);
        vuln.setDescription(description);
        vuln.setUpdated(updated);
        qm.persist(vuln);
        return vuln.getId();
    }

    private String getVulnDescriptionById(long id) {
        return jdbiHandle.createQuery("""
                        SELECT "DESCRIPTION"
                          FROM "VULNERABILITY"
                         WHERE "ID" = :id
                        """)
                .bind("id", id)
                .mapTo(String.class)
                .one();
    }

}
