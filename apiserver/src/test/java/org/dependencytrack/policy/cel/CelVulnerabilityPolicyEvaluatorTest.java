/*
 * This file is part of Dependency-Track.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 * Copyright (c) OWASP Foundation. All Rights Reserved.
 */
package org.dependencytrack.policy.cel;

import org.dependencytrack.PersistenceCapableTest;
import org.dependencytrack.TestCacheManager;
import org.dependencytrack.model.VulnerabilityAlias;
import org.dependencytrack.policy.vulnerability.VulnerabilityPolicy;
import org.dependencytrack.policy.vulnerability.VulnerabilityPolicyEvaluator;
import org.dependencytrack.policy.vulnerability.VulnerabilityPolicyProvider;
import org.dependencytrack.proto.policy.v1.Component;
import org.dependencytrack.proto.policy.v1.Project;
import org.dependencytrack.proto.policy.v1.Vulnerability;
import org.junit.Before;
import org.junit.Test;

import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.UUID;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;

import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.doReturn;
import static org.mockito.Mockito.mock;

public class CelVulnerabilityPolicyEvaluatorTest extends PersistenceCapableTest {

    private VulnerabilityPolicyProvider policyProviderMock;
    private VulnerabilityPolicyEvaluator policyEvaluator;

    @Before
    public void before() throws Exception {
        super.before();

        final var cacheManager = new TestCacheManager(30, TimeUnit.SECONDS, 5);
        final var policyScriptHost = CelPolicyScriptHost.getInstance(CelPolicyType.VULNERABILITY);
        policyProviderMock = mock(VulnerabilityPolicyProvider.class);
        policyEvaluator = new CelVulnerabilityPolicyEvaluator(policyProviderMock, policyScriptHost, cacheManager);
    }

    @Test
    public void testEvaluateWithNoApplicablePolicies() {
        final var project = Project.newBuilder()
                .setUuid(UUID.randomUUID().toString())
                .setName("acme-app")
                .build();
        final var component = Component.newBuilder()
                .setUuid(UUID.randomUUID().toString())
                .setName("acme-lib")
                .build();
        final UUID vulnUuid = UUID.randomUUID();
        final var vuln = Vulnerability.newBuilder()
                .setUuid(vulnUuid.toString())
                .setId("CVE-123")
                .build();

        doReturn(Collections.emptyList())
                .when(policyProviderMock).getApplicablePolicies(any(Project.class));

        assertThat(policyEvaluator.evaluate(List.of(vuln), component, project)).isEmpty();
    }

    @Test
    public void testEvaluateWithNoMatchingPolicies() {
        final var project = Project.newBuilder()
                .setUuid(UUID.randomUUID().toString())
                .setName("acme-app")
                .build();
        final var component = Component.newBuilder()
                .setUuid(UUID.randomUUID().toString())
                .setName("acme-lib")
                .build();
        final UUID vulnUuid = UUID.randomUUID();
        final var vuln = Vulnerability.newBuilder()
                .setUuid(vulnUuid.toString())
                .setId("CVE-123")
                .build();

        final var policyA = new VulnerabilityPolicy();
        policyA.setName("policyA");
        policyA.setConditions(List.of("component.name == 'foo'"));
        final var policyB = new VulnerabilityPolicy();
        policyB.setName("policyB");
        policyB.setConditions(List.of("project.name == 'bar'"));
        final var policyC = new VulnerabilityPolicy();
        policyC.setName("policyC");
        policyC.setConditions(List.of("vuln.id == 'baz'"));

        doReturn(List.of(policyA, policyB, policyC))
                .when(policyProviderMock).getApplicablePolicies(any(Project.class));

        assertThat(policyEvaluator.evaluate(List.of(vuln), component, project)).isEmpty();
    }

    @Test
    public void testEvaluateWithMultipleMatchingPolicies() {
        final var project = Project.newBuilder()
                .setUuid(UUID.randomUUID().toString())
                .setName("acme-app")
                .build();
        final var component = Component.newBuilder()
                .setUuid(UUID.randomUUID().toString())
                .setName("acme-lib")
                .build();
        final UUID vulnUuid = UUID.randomUUID();
        final var vuln = Vulnerability.newBuilder()
                .setUuid(vulnUuid.toString())
                .setId("CVE-123")
                .build();

        // Create multiple policies which all match the given evaluation input.
        final var policyA = new VulnerabilityPolicy();
        policyA.setName("policyA");
        policyA.setConditions(List.of("component.name == 'acme-lib'"));
        final var policyB = new VulnerabilityPolicy();
        policyB.setName("policyB");
        policyB.setConditions(List.of("project.name == 'acme-app'"));
        final var policyC = new VulnerabilityPolicy();
        policyC.setName("policyC");
        policyC.setConditions(List.of("vuln.id == 'CVE-123'"));

        doReturn(List.of(policyA, policyB, policyC))
                .when(policyProviderMock).getApplicablePolicies(any(Project.class));

        // Policies are supposed to be evaluated in order, so policyA should be the only match.
        assertThat(policyEvaluator.evaluate(List.of(vuln), component, project))
                .hasEntrySatisfying(vulnUuid, policy -> {
                    assertThat(policy.getName()).isEqualTo("policyA");
                });
    }

    @Test
    public void testEvaluateWithAdditionalRequiredFields() throws Exception {
        final var persistentProject = new org.dependencytrack.model.Project();
        persistentProject.setName("acme-app");
        persistentProject.setVersion("1.0.0");
        qm.persist(persistentProject);

        final var persistentComponent = new org.dependencytrack.model.Component();
        persistentComponent.setProject(persistentProject);
        persistentComponent.setName("acme-lib");
        persistentComponent.setVersion("2.0.0");
        qm.persist(persistentComponent);

        final var persistentVuln = new org.dependencytrack.model.Vulnerability();
        persistentVuln.setVulnId("CVE-123");
        persistentVuln.setSource(org.dependencytrack.model.Vulnerability.Source.NVD);
        persistentVuln.setCvssV3Vector("CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:C/C:L/I:H/A:L");
        qm.persist(persistentVuln);

        final var alias = new VulnerabilityAlias();
        alias.setCveId("CVE-123");
        alias.setGhsaId("GHSA-123");
        qm.synchronizeVulnerabilityAlias(alias);

        final var project = Project.newBuilder()
                .setUuid(persistentProject.getUuid().toString())
                .setName("acme-app")
                .build();
        final var component = Component.newBuilder()
                .setUuid(persistentComponent.getUuid().toString())
                .setName("acme-lib")
                .build();
        final var vuln = Vulnerability.newBuilder()
                .setUuid(persistentVuln.getUuid().toString())
                .setId("CVE-123")
                .build();

        // Access more fields than provided in the evaluation arguments.
        // The evaluator should load those fields from the database.
        final var policy = new VulnerabilityPolicy();
        policy.setName("policy");
        policy.setConditions(List.of("""
                project.name == "acme-app"
                  && project.version == "1.0.0"
                  && component.name == "acme-lib"
                  && component.version == "2.0.0"
                  && vuln.id == "CVE-123"
                  && vuln.cvssv3_vector == "CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:C/C:L/I:H/A:L"
                  && vuln.aliases.exists(alias, alias.id == "GHSA-123")
                """));

        doReturn(List.of(policy))
                .when(policyProviderMock).getApplicablePolicies(any(Project.class));

        // We want evaluation as a whole to be thread safe!
        final var startLatch = new CountDownLatch(1);
        final ExecutorService executor = Executors.newFixedThreadPool(10);
        final var exceptionsThrown = new ConcurrentLinkedQueue<Exception>();
        try {
            for (int i = 0; i < 1000; i++) {
                executor.submit(() -> {
                    try {
                        startLatch.await();
                    } catch (InterruptedException e) {
                        throw new RuntimeException(e);
                    }

                    try {
                        assertThat(policyEvaluator.evaluate(List.of(vuln), component, project))
                                .containsOnly(Map.entry(persistentVuln.getUuid(), policy));
                    } catch (Exception e) {
                        // If we throw here, the exception won't bubble up to the test.
                        // Collect all encountered exceptions here and assert on all of them later.
                        exceptionsThrown.add(e);
                    }
                });
            }

            // Open the flood gates :)
            startLatch.countDown();
        } finally {
            executor.shutdown();
            assertThat(executor.awaitTermination(90, TimeUnit.SECONDS)).isTrue();
        }

        assertThat(exceptionsThrown).isEmpty();
    }

}