/*
 * This file is part of Dependency-Track.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 * Copyright (c) OWASP Foundation. All Rights Reserved.
 */
package org.dependencytrack.policy.cel;

import org.dependencytrack.PersistenceCapableTest;
import org.dependencytrack.model.VulnerabilityAlias;
import org.dependencytrack.persistence.jdbi.VulnerabilityPolicyDao;
import org.dependencytrack.policy.vulnerability.VulnerabilityPolicy;
import org.dependencytrack.policy.vulnerability.VulnerabilityPolicyAnalysis;
import org.dependencytrack.policy.vulnerability.VulnerabilityPolicyEvaluator;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;

import static org.assertj.core.api.Assertions.assertThat;
import static org.dependencytrack.persistence.jdbi.JdbiFactory.withJdbiHandle;

public class CelVulnerabilityPolicyEvaluatorTest extends PersistenceCapableTest {

    private VulnerabilityPolicyEvaluator policyEvaluator;

    @BeforeEach
    public void before() throws Exception {
        super.before();

        final var policyScriptHost = CelPolicyScriptHost.getInstance(CelPolicyType.VULNERABILITY);
        policyEvaluator = new CelVulnerabilityPolicyEvaluator(policyScriptHost);
    }

    @Test
    public void testEvaluateAllWithNoApplicablePolicies() {
        final var project = new org.dependencytrack.model.Project();
        project.setName("acme-app");
        qm.persist(project);

        final var component = new org.dependencytrack.model.Component();
        component.setProject(project);
        component.setName("acme-lib");
        qm.persist(component);

        final var vuln = new org.dependencytrack.model.Vulnerability();
        vuln.setVulnId("CVE-123");
        vuln.setSource(org.dependencytrack.model.Vulnerability.Source.NVD);
        qm.persist(vuln);

        assertThat(policyEvaluator.evaluateAll(project.getId(), Map.of(component.getId(), Set.of(vuln.getId())))).isEmpty();
    }

    @Test
    public void testEvaluateAllWithNoMatchingPolicies() {
        final var project = new org.dependencytrack.model.Project();
        project.setName("acme-app");
        qm.persist(project);

        final var component = new org.dependencytrack.model.Component();
        component.setProject(project);
        component.setName("acme-lib");
        qm.persist(component);

        final var vuln = new org.dependencytrack.model.Vulnerability();
        vuln.setVulnId("CVE-123");
        vuln.setSource(org.dependencytrack.model.Vulnerability.Source.NVD);
        qm.persist(vuln);

        createPolicy("policyA", List.of("component.name == 'foo'"));
        createPolicy("policyB", List.of("project.name == 'bar'"));
        createPolicy("policyC", List.of("vuln.id == 'baz'"));

        assertThat(policyEvaluator.evaluateAll(project.getId(), Map.of(component.getId(), Set.of(vuln.getId())))).isEmpty();
    }

    @Test
    public void testEvaluateAllWithMultipleMatchingPolicies() {
        final var project = new org.dependencytrack.model.Project();
        project.setName("acme-app");
        qm.persist(project);

        final var component = new org.dependencytrack.model.Component();
        component.setProject(project);
        component.setName("acme-lib");
        qm.persist(component);

        final var vuln = new org.dependencytrack.model.Vulnerability();
        vuln.setVulnId("CVE-123");
        vuln.setSource(org.dependencytrack.model.Vulnerability.Source.NVD);
        qm.persist(vuln);

        // Create multiple policies which all match the given evaluation input.
        createPolicy("policyA", List.of("component.name == 'acme-lib'"));
        createPolicy("policyB", List.of("project.name == 'acme-app'"));
        createPolicy("policyC", List.of("vuln.id == 'CVE-123'"));

        // Policies are evaluated in order, so policyA should be the only match.
        final Map<Long, Map<Long, VulnerabilityPolicy>> result =
                policyEvaluator.evaluateAll(project.getId(), Map.of(component.getId(), Set.of(vuln.getId())));
        assertThat(result).containsKey(component.getId());
        assertThat(result.get(component.getId()))
                .hasEntrySatisfying(vuln.getId(), policy ->
                    assertThat(policy.getName()).isEqualTo("policyA"));
    }

    @Test
    public void testEvaluateAllWithMultipleComponents() {
        final var project = new org.dependencytrack.model.Project();
        project.setName("acme-app");
        qm.persist(project);

        final var componentA = new org.dependencytrack.model.Component();
        componentA.setProject(project);
        componentA.setName("acme-lib-a");
        qm.persist(componentA);

        final var componentB = new org.dependencytrack.model.Component();
        componentB.setProject(project);
        componentB.setName("acme-lib-b");
        qm.persist(componentB);

        final var vuln1 = new org.dependencytrack.model.Vulnerability();
        vuln1.setVulnId("CVE-001");
        vuln1.setSource(org.dependencytrack.model.Vulnerability.Source.NVD);
        qm.persist(vuln1);

        final var vuln2 = new org.dependencytrack.model.Vulnerability();
        vuln2.setVulnId("CVE-002");
        vuln2.setSource(org.dependencytrack.model.Vulnerability.Source.NVD);
        qm.persist(vuln2);

        // Policy matches only componentA.
        createPolicy("policyForA", List.of("component.name == 'acme-lib-a'"));

        final Map<Long, Set<Long>> vulnIdsByComponentId = Map.of(
                componentA.getId(), Set.of(vuln1.getId()),
                componentB.getId(), Set.of(vuln2.getId()));

        final Map<Long, Map<Long, VulnerabilityPolicy>> result =
                policyEvaluator.evaluateAll(project.getId(), vulnIdsByComponentId);

        // Only componentA should have matches.
        assertThat(result).hasSize(1);
        assertThat(result).containsKey(componentA.getId());
        assertThat(result.get(componentA.getId())).containsKey(vuln1.getId());
    }

    @Test
    public void testEvaluateAllWithEmptyInput() {
        final var project = new org.dependencytrack.model.Project();
        project.setName("acme-app");
        qm.persist(project);

        assertThat(policyEvaluator.evaluateAll(project.getId(), Map.of())).isEmpty();
    }

    @Test
    public void testEvaluateAllWithAdditionalRequiredFields() throws Exception {
        final var persistentProject = new org.dependencytrack.model.Project();
        persistentProject.setName("acme-app");
        persistentProject.setVersion("1.0.0");
        qm.persist(persistentProject);

        final var persistentComponent = new org.dependencytrack.model.Component();
        persistentComponent.setProject(persistentProject);
        persistentComponent.setName("acme-lib");
        persistentComponent.setVersion("2.0.0");
        qm.persist(persistentComponent);

        final var persistentVuln = new org.dependencytrack.model.Vulnerability();
        persistentVuln.setVulnId("CVE-123");
        persistentVuln.setSource(org.dependencytrack.model.Vulnerability.Source.NVD);
        persistentVuln.setCvssV3Vector("CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:C/C:L/I:H/A:L");
        qm.persist(persistentVuln);

        final var alias = new VulnerabilityAlias();
        alias.setCveId("CVE-123");
        alias.setGhsaId("GHSA-123");
        qm.synchronizeVulnerabilityAlias(alias);

        final long projectId = persistentProject.getId();
        final long componentId = persistentComponent.getId();
        final long vulnId = persistentVuln.getId();

        // Access more fields than provided in the evaluation arguments.
        // The evaluator should load those fields from the database.
        createPolicy("policy", List.of("""
                project.name == "acme-app"
                  && project.version == "1.0.0"
                  && component.name == "acme-lib"
                  && component.version == "2.0.0"
                  && vuln.id == "CVE-123"
                  && vuln.cvssv3_vector == "CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:C/C:L/I:H/A:L"
                  && vuln.aliases.exists(alias, alias.id == "GHSA-123")
                """));

        // We want evaluation as a whole to be thread safe!
        final var startLatch = new CountDownLatch(1);
        final ExecutorService executor = Executors.newFixedThreadPool(10);
        final var exceptionsThrown = new ConcurrentLinkedQueue<Exception>();
        try {
            for (int i = 0; i < 1000; i++) {
                executor.submit(() -> {
                    try {
                        startLatch.await();
                    } catch (InterruptedException e) {
                        throw new RuntimeException(e);
                    }

                    try {
                        final Map<Long, Map<Long, VulnerabilityPolicy>> result =
                                policyEvaluator.evaluateAll(projectId, Map.of(componentId, Set.of(vulnId)));
                        assertThat(result).containsKey(componentId);
                        assertThat(result.get(componentId))
                                .hasEntrySatisfying(vulnId, policy ->
                                    assertThat(policy.getName()).isEqualTo("policy"));
                    } catch (Exception e) {
                        // If we throw here, the exception won't bubble up to the test.
                        // Collect all encountered exceptions here and assert on all of them later.
                        exceptionsThrown.add(e);
                    }
                });
            }

            // Open the flood gates :)
            startLatch.countDown();
        } finally {
            executor.shutdown();
            assertThat(executor.awaitTermination(90, TimeUnit.SECONDS)).isTrue();
        }

        assertThat(exceptionsThrown).isEmpty();
    }

    private static void createPolicy(String name, List<String> conditions) {
        final var analysis = new VulnerabilityPolicyAnalysis();
        analysis.setState(VulnerabilityPolicyAnalysis.State.FALSE_POSITIVE);

        final var policy = new VulnerabilityPolicy();
        policy.setName(name);
        policy.setConditions(conditions);
        policy.setAnalysis(analysis);
        withJdbiHandle(handle -> handle.attach(VulnerabilityPolicyDao.class).create(policy));
    }

}
