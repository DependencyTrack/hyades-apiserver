/*
 * This file is part of Dependency-Track.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 * Copyright (c) OWASP Foundation. All Rights Reserved.
 */
package org.dependencytrack.event.kafka.processor;

import alpine.common.logging.Logger;
import com.github.packageurl.MalformedPackageURLException;
import com.github.packageurl.PackageURL;
import io.github.nscuro.versatile.Comparator;
import io.github.nscuro.versatile.Constraint;
import io.github.nscuro.versatile.Vers;
import io.github.nscuro.versatile.VersException;
import io.github.nscuro.versatile.version.VersioningScheme;
import org.apache.commons.lang3.StringUtils;
import org.apache.kafka.clients.consumer.ConsumerRecord;
import org.cyclonedx.proto.v1_6.Bom;
import org.cyclonedx.proto.v1_6.Component;
import org.cyclonedx.proto.v1_6.VulnerabilityAffects;
import org.dependencytrack.event.kafka.processor.api.Processor;
import org.dependencytrack.model.Vulnerability;
import org.dependencytrack.model.VulnerableSoftware;
import org.dependencytrack.parser.dependencytrack.ModelConverterCdxToVuln;
import org.dependencytrack.parser.nvd.ModelConverter;
import org.dependencytrack.persistence.QueryManager;
import us.springett.parsers.cpe.exceptions.CpeEncodingException;
import us.springett.parsers.cpe.exceptions.CpeParsingException;

import java.util.ArrayList;
import java.util.List;
import java.util.Optional;

/**
 * A {@link Processor} that ingests vulnerability data from CycloneDX Bill of Vulnerabilities.
 */
public class VulnerabilityMirrorProcessor implements Processor<String, Bom> {

    static final String PROCESSOR_NAME = "vuln.mirror";

    private static final Logger LOGGER = Logger.getLogger(VulnerabilityMirrorProcessor.class);

    @Override
    public void process(final ConsumerRecord<String, Bom> record) {
        try (QueryManager qm = new QueryManager()) {
            LOGGER.debug("Synchronizing Mirrored Vulnerability : " + record.key());
            Bom bom = record.value();
            String key = record.key();
            String mirrorSource = key.substring(0, key.indexOf("/"));
            Vulnerability.Source source = Vulnerability.Source.valueOf(mirrorSource);
            final Vulnerability vulnerability = ModelConverterCdxToVuln.convert(qm, bom, bom.getVulnerabilities(0), false);
            final List<VulnerableSoftware> vsListOld = qm.detach(qm.getVulnerableSoftwareByVulnId(vulnerability.getSource(), vulnerability.getVulnId()));
            final Vulnerability synchronizedVulnerability = qm.synchronizeVulnerability(vulnerability, false);
            var cycloneVuln = bom.getVulnerabilities(0);
            // Alias synchronization across multiple sources is too unreliable right now.
            // We can re-enable this once we have more confidence in data quality, or a better
            // way of auditing reported aliases. See also: https://github.com/google/osv.dev/issues/888
            /* if (!cycloneVuln.getReferencesList().isEmpty()) {
                cycloneVuln.getReferencesList().stream().forEach(reference -> {
                    final String alias = reference.getId();
                    final VulnerabilityAlias vulnerabilityAlias = new VulnerabilityAlias();

                    // OSV will use IDs of other vulnerability databases for its
                    // primary advisory ID (e.g. GHSA-45hx-wfhj-473x). We need to ensure
                    // that we don't falsely report GHSA IDs as stemming from OSV.
                    final Vulnerability.Source advisorySource = extractSource(cycloneVuln.getId(), cycloneVuln.getSource());
                    if (mirrorSource.equals("OSV")) {
                        switch (advisorySource) {
                            case NVD -> vulnerabilityAlias.setCveId(cycloneVuln.getId());
                            case GITHUB -> vulnerabilityAlias.setGhsaId(cycloneVuln.getId());
                            default -> vulnerabilityAlias.setOsvId(cycloneVuln.getId());
                        }
                    }
                    if (alias.startsWith("CVE") && Vulnerability.Source.NVD != advisorySource) {
                        vulnerabilityAlias.setCveId(alias);
                        qm.synchronizeVulnerabilityAlias(vulnerabilityAlias);
                    } else if (alias.startsWith("GHSA") && Vulnerability.Source.GITHUB != advisorySource) {
                        vulnerabilityAlias.setGhsaId(alias);
                        qm.synchronizeVulnerabilityAlias(vulnerabilityAlias);
                    }
                });
            }*/
            final List<VulnerableSoftware> vsList = new ArrayList<>();
            for (final VulnerabilityAffects affect : cycloneVuln.getAffectsList()) {
                final Optional<Component> component = bom.getComponentsList().stream()
                        .filter(c -> c.getBomRef().equals(affect.getRef()))
                        .findFirst();
                if (component.isEmpty()) {
                    LOGGER.warn("No component in the BOV for %s is matching the BOM ref \"%s\" of the affects node; Skipping"
                            .formatted(synchronizedVulnerability.getVulnId(), affect.getRef()));
                    continue;
                }

                affect.getVersionsList().forEach(version -> {
                    if (version.hasRange()) {
                        final List<VulnerableSoftware> vs = mapAffectedRangeToVulnerableSoftwares(qm,
                                vulnerability.getVulnId(), version.getRange(), component.get().getPurl(), component.get().getCpe());
                        if (vs != null) {
                            vsList.addAll(vs);
                        }
                    }
                    if (version.hasVersion()) {
                        final VulnerableSoftware vs = mapAffectedVersionToVulnerableSoftware(qm,
                                vulnerability.getVulnId(), version.getVersion(), component.get().getPurl(), component.get().getCpe());
                        if (vs != null) {
                            vsList.add(vs);
                        }
                    }
                });
            }
            if (!vsList.isEmpty()) {
                qm.persist(vsList);
                qm.updateAffectedVersionAttributions(synchronizedVulnerability, vsList, source);
                var reconciledVsList = qm.reconcileVulnerableSoftware(synchronizedVulnerability, vsListOld, vsList, source);
                synchronizedVulnerability.setVulnerableSoftware(reconciledVsList);
            }
            qm.persist(synchronizedVulnerability);
        }
    }

    public VulnerableSoftware mapAffectedVersionToVulnerableSoftware(final QueryManager qm, final String vulnId,
                                                                     String version, String purlStr, String cpeStr) {
        version = StringUtils.trimToNull(version);
        cpeStr = StringUtils.trimToNull(cpeStr);
        purlStr = StringUtils.trimToNull(purlStr);
        if (version == null || (cpeStr == null && purlStr == null)) {
            return null;
        }

        var vs = new VulnerableSoftware();
        if (purlStr != null) {
            final PackageURL purl;
            try {
                purl = new PackageURL(purlStr);
                vs = qm.getVulnerableSoftwareByPurlAndVersion(purl.getType(), purl.getNamespace(), purl.getName(), version);
                if (vs != null) {
                    return vs;
                } else {
                    vs = new VulnerableSoftware();
                    vs.setPurlType(purl.getType());
                    vs.setPurlNamespace(purl.getNamespace());
                    vs.setPurlName(purl.getName());
                    vs.setPurl(purl.canonicalize());
                    vs.setVersion(version);
                }
            } catch (MalformedPackageURLException e) {
                LOGGER.warn("Failed to parse PURL from \"%s\" for %s; Skipping".formatted(purlStr, vulnId), e);
                return null;
            }
        } else {
            try {
                vs = qm.getVulnerableSoftwareByCpe23AndVersion(cpeStr, version);
                if (vs != null) {
                    return vs;
                } else {
                    vs = ModelConverter.convertCpe23UriToVulnerableSoftware(cpeStr);
                    vs.setVersion(version);
                }
            } catch (CpeParsingException | CpeEncodingException e) {
                LOGGER.warn("Failed to parse CPE from \"%s\" for %s; Skipping".formatted(cpeStr, vulnId), e);
                return null;
            }
        }
        vs.setVulnerable(true);
        return vs;
    }

    public List<VulnerableSoftware> mapAffectedRangeToVulnerableSoftwares(final QueryManager qm, final String vulnId,
                                                                          String range, String purlStr, String cpeStr) {
        range = StringUtils.trimToNull(range);
        cpeStr = StringUtils.trimToNull(cpeStr);
        purlStr = StringUtils.trimToNull(purlStr);
        if (range == null || (cpeStr == null && purlStr == null)) {
            return null;
        }

        final List<VulnerableSoftware> vsList = new ArrayList<>();
        final List<Vers> versList;
        try {
            versList = convertRangeToVersList(range);
        } catch (VersException e) {
            LOGGER.warn("Failed to parse vers range from \"%s\" for %s".formatted(range, vulnId), e);
            return null;
        }

        for (var vers : versList) {
            if (vers.constraints().isEmpty()) {
                LOGGER.debug("Vers range \"%s\" (parsed: %s) for %s does not contain any constraints; Skipping".formatted(range, vers, vulnId));
                continue;
            }
            else if (vers.constraints().size() == 1) {
                var versConstraint = vers.constraints().get(0);
                if (versConstraint.comparator() == Comparator.WILDCARD) {
                    // Wildcards in VulnerableSoftware can be represented via either:
                    //   * version=*, or
                    //   * versionStartIncluding=0
                    // We choose the more explicit first option.
                    //
                    // Also, as wildcards have the potential to lead to lots of false positives,
                    // we want to be informed when they enter our system. So logging a warning.
                    LOGGER.warn("Wildcard range %s was reported for %s".formatted(vers, vulnId));
                    vsList.add(mapAffectedVersionToVulnerableSoftware(qm, vulnId, "*", purlStr, cpeStr));
                    continue;
                }
            }
            var vulnerableSoftware = convertVersToVulnerableSoftware(qm, vers, vulnId, purlStr, cpeStr);
            if (vulnerableSoftware != null) {
                vsList.add(vulnerableSoftware);
            }
        }
        return vsList;
    }

    public static List<Vers> convertRangeToVersList(String range) {
        try {
            Vers parsedVers = Vers.parse(range);
            // Calling split to address ranges with all possible length of constraints
            return parsedVers.validate().split();
        } catch (VersException versException) {
            if (versException.getMessage().contains("invalid versioning scheme")) {
                // Fall back the invalid versioning scheme to 'generic' and reparse
                String[] rangeParts = range.split(":", 2);
                String[] versions = rangeParts[1].split("/", 2);
                var genericRange = rangeParts[0] + ":" + VersioningScheme.GENERIC.name().toLowerCase() + "/" + versions[1];
                return convertRangeToVersList(genericRange);
            } else {
                throw versException;
            }
        }
    }

    private VulnerableSoftware convertVersToVulnerableSoftware(QueryManager qm, Vers vers, String vulnId, String purlStr, String cpeStr) {

        String versionStartIncluding = null;
        String versionStartExcluding = null;
        String versionEndIncluding = null;
        String versionEndExcluding = null;

        for (final Constraint constraint : vers.constraints()) {
            if (constraint.version() == null
                || constraint.version().equals("0")
                || constraint.version().equals("*")) {
                // Semantically, ">=0" is equivalent to versionStartIncluding=null,
                // and ">0" is equivalent to versionStartExcluding=null.
                //
                // "<0", "<=0", and "=0" can be normalized to versionStartIncluding=null.
                //
                // "*" is a wildcard and can only be used on its own, without any comparator.
                // The Vers parsing / validation performed above will thus fail for ranges like "vers:generic/>=*".
                continue;
            }

            switch (constraint.comparator()) {
                case GREATER_THAN -> versionStartExcluding = String.valueOf(constraint.version());
                case GREATER_THAN_OR_EQUAL -> versionStartIncluding = String.valueOf(constraint.version());
                case LESS_THAN_OR_EQUAL -> versionEndIncluding = String.valueOf(constraint.version());
                case LESS_THAN -> versionEndExcluding = String.valueOf(constraint.version());
                default -> LOGGER.warn("Encountered unexpected comparator %s in %s for %s; Skipping"
                        .formatted(constraint.comparator(), vers, vulnId));
            }
        }

        if (versionStartIncluding == null && versionStartExcluding == null
            && versionEndIncluding == null && versionEndExcluding == null) {
            LOGGER.warn("Unable to assemble a version range from %s for %s".formatted(vers, vulnId));
            return null;
        }
        if ((versionStartIncluding != null || versionStartExcluding != null)
            && (versionEndIncluding == null && versionEndExcluding == null)) {
            LOGGER.warn("Skipping indefinite version range assembled from %s for %s".formatted(vers, vulnId));
            return null;
        }

        VulnerableSoftware vs;
        if (purlStr != null) {
            final PackageURL purl;
            try {
                purl = new PackageURL(purlStr);
            } catch (MalformedPackageURLException e) {
                LOGGER.warn("Failed to parse PURL from \"%s\" for %s; Skipping".formatted(purlStr, vulnId), e);
                return null;
            }
            vs = qm.getVulnerableSoftwareByPurl(purl.getType(), purl.getNamespace(), purl.getName(),
                    versionEndExcluding, versionEndIncluding, null, versionStartIncluding);
            if (vs != null) {
                return vs;
            }
            vs = new VulnerableSoftware();
            vs.setPurlType(purl.getType());
            vs.setPurlNamespace(purl.getNamespace());
            vs.setPurlName(purl.getName());
            vs.setPurl(purl.canonicalize());
        } else {
            vs = qm.getVulnerableSoftwareByCpe23(cpeStr, versionEndExcluding,
                    versionEndIncluding, versionStartExcluding, versionStartIncluding);
            if (vs != null) {
                return vs;
            }
            try {
                vs = ModelConverter.convertCpe23UriToVulnerableSoftware(cpeStr);
            } catch (CpeParsingException | CpeEncodingException e) {
                LOGGER.warn("Failed to parse CPE from \"%s\" for %s; Skipping".formatted(cpeStr, vulnId), e);
                return null;
            }
        }

        vs.setVulnerable(true);
        vs.setVersionStartExcluding(versionStartExcluding);
        vs.setVersionStartIncluding(versionStartIncluding);
        vs.setVersionEndExcluding(versionEndExcluding);
        vs.setVersionEndIncluding(versionEndIncluding);
        return vs;
    }
}
