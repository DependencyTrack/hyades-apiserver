/*
 * This file is part of Dependency-Track.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 * Copyright (c) OWASP Foundation. All Rights Reserved.
 */
package org.dependencytrack.persistence.jdbi;

import org.dependencytrack.model.VulnerabilityKey;
import org.jdbi.v3.core.Handle;
import org.jdbi.v3.core.mapper.RowMapper;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeSet;
import java.util.UUID;
import java.util.stream.Collectors;

import static java.util.Objects.requireNonNull;

/**
 * @since 5.7.0
 */
public final class VulnerabilityAliasDao {

    private static final Logger LOGGER = LoggerFactory.getLogger(VulnerabilityAliasDao.class);
    private static final String UNKNOWN_ASSERTER = "UNKNOWN";

    private final Handle jdbiHandle;

    public VulnerabilityAliasDao(Handle jdbiHandle) {
        this.jdbiHandle = jdbiHandle;
    }

    public void syncAssertions(String asserter, VulnerabilityKey vulnKey, Set<VulnerabilityKey> aliasKeys) {
        syncAssertions(asserter, Map.of(vulnKey, aliasKeys));
    }

    public void syncAssertions(String asserter, Map<VulnerabilityKey, Set<VulnerabilityKey>> assertionsByVulnKey) {
        requireNonNull(asserter, "asserter must not be null");
        if (assertionsByVulnKey.isEmpty()) {
            return;
        }

        // Synchronization is not concurrency-safe, so we need to acquire advisory locks for
        // all vuln keys we're processing. Note that we MUST acquire them in deterministic order,
        // as otherwise we'd be risking deadlocks.
        acquireAdvisoryLocks(assertionsByVulnKey.keySet());

        final Map<VulnerabilityKey, List<Assertion>> existingByVulnKey =
                getAssertions(assertionsByVulnKey.keySet());
        LOGGER.debug(
                "Found existing aliasKey assertion(s) for {}/{} vulnerabilities",
                existingByVulnKey.size(),
                assertionsByVulnKey.size());

        final ReconcileAssertionsResult reconcileAssertionsResult =
                reconcileAssertions(
                        asserter,
                        assertionsByVulnKey,
                        existingByVulnKey);
        if (!reconcileAssertionsResult.hasModifications()) {
            LOGGER.debug("Alias assertions unchanged; Nothing to do");
            return;
        }

        final int assertionsDeleted = deleteAssertions(reconcileAssertionsResult.assertionsToDelete());
        if (assertionsDeleted > 0) {
            LOGGER.debug("Deleted {} aliasKey assertion(s)", assertionsDeleted);
        }

        final int assertionsCreated = createAssertions(reconcileAssertionsResult.assertionsToCreate());
        if (assertionsCreated > 0) {
            LOGGER.debug("Created {} aliasKey assertion(s)", assertionsCreated);
        }

        final int unknownAssertionsDeleted = deleteAssertionsOfUnknownAsserter(
                reconcileAssertionsResult.vulnsNeedingUnknownCleanup());
        if (unknownAssertionsDeleted > 0) {
            LOGGER.debug("Deleted {} aliasKey assertion(s) of unknown asserter", unknownAssertionsDeleted);
        }

        // (Re-) compute alias groups for all vulnerabilities that had changes
        // in their alias attributions.
        computeAliasGroups(reconcileAssertionsResult.modifiedVulnKeys());
    }

    private void acquireAdvisoryLocks(Collection<VulnerabilityKey> vulnKeys) {
        if (vulnKeys.isEmpty()) {
            return;
        }

        final var lockKeys = new String[vulnKeys.size()];

        int i = 0;
        for (final VulnerabilityKey vulnKey : vulnKeys) {
            lockKeys[i] = "vuln-alias-sync|%s|%s".formatted(vulnKey.source(), vulnKey.vulnId());
            i++;
        }

        jdbiHandle
                .createQuery(/* language=SQL */ """
                        SELECT PG_ADVISORY_XACT_LOCK(HASHTEXT(key))
                          FROM (
                            SELECT DISTINCT UNNEST(:keys) AS key
                             ORDER BY 1
                          ) AS t
                        """)
                .bind("keys", lockKeys)
                .mapToMap()
                .list();
    }

    private record Assertion(
            String asserter,
            VulnerabilityKey vulnKey,
            VulnerabilityKey aliasKey) {

        private static final RowMapper<Assertion> ROW_MAPPER = (rs, ctx) ->
                new Assertion(
                        rs.getString("asserter"),
                        new VulnerabilityKey(rs.getString("vuln_id"), rs.getString("vuln_source")),
                        new VulnerabilityKey(rs.getString("alias_id"), rs.getString("alias_source")));

    }

    private Map<VulnerabilityKey, List<Assertion>> getAssertions(Collection<VulnerabilityKey> vulnKeys) {
        if (vulnKeys.isEmpty()) {
            return Map.of();
        }

        final var sources = new String[vulnKeys.size()];
        final var vulnIds = new String[vulnKeys.size()];

        int i = 0;
        for (final VulnerabilityKey vulnKey : vulnKeys) {
            sources[i] = vulnKey.source().name();
            vulnIds[i] = vulnKey.vulnId();
            i++;
        }

        return jdbiHandle
                .createQuery(/* language=SQL */ """
                        SELECT "ASSERTER"
                             , "VULN_SOURCE"
                             , "VULN_ID"
                             , "ALIAS_SOURCE"
                             , "ALIAS_ID"
                          FROM "VULNERABILITY_ALIAS_ASSERTION"
                         WHERE ("VULN_SOURCE", "VULN_ID") IN (SELECT * FROM UNNEST(:sources, :vulnIds))
                        """)
                .bind("sources", sources)
                .bind("vulnIds", vulnIds)
                .map(Assertion.ROW_MAPPER)
                .collect(Collectors.groupingBy(Assertion::vulnKey));
    }

    private record ReconcileAssertionsResult(
            List<Assertion> assertionsToCreate,
            List<Assertion> assertionsToDelete,
            Set<VulnerabilityKey> vulnsNeedingUnknownCleanup,
            Set<VulnerabilityKey> modifiedVulnKeys) {

        private boolean hasModifications() {
            return !modifiedVulnKeys.isEmpty();
        }

    }

    private ReconcileAssertionsResult reconcileAssertions(
            String asserter,
            Map<VulnerabilityKey, Set<VulnerabilityKey>> incomingAliasesByVulnKey,
            Map<VulnerabilityKey, List<Assertion>> existingAssertionsByVulnKey) {
        final var assertionsToDelete = new ArrayList<Assertion>();
        final var assertionsToCreate = new ArrayList<Assertion>();
        final var vulnsNeedingUnknownCleanup = new HashSet<VulnerabilityKey>();
        final var modifiedVulnKeys = new HashSet<VulnerabilityKey>();

        for (final var entry : incomingAliasesByVulnKey.entrySet()) {
            final VulnerabilityKey incomingVulnKey = entry.getKey();
            final Set<VulnerabilityKey> incomingAliasKeys = entry.getValue();
            final List<Assertion> existingAssertions = existingAssertionsByVulnKey.getOrDefault(incomingVulnKey, List.of());

            final var existingForAsserter = new HashSet<VulnerabilityKey>();
            final var unknownAliases = new HashSet<VulnerabilityKey>();

            for (final Assertion existingAssertion : existingAssertions) {
                if (asserter.equals(existingAssertion.asserter())) {
                    existingForAsserter.add(existingAssertion.aliasKey());
                } else if (UNKNOWN_ASSERTER.equals(existingAssertion.asserter())) {
                    unknownAliases.add(existingAssertion.aliasKey());
                }
            }

            final boolean shouldDeleteUnknownAssertions =
                    !UNKNOWN_ASSERTER.equals(asserter) && !unknownAliases.isEmpty();

            final var toDelete = new HashSet<>(existingForAsserter);
            toDelete.removeAll(incomingAliasKeys);

            final var toInsert = new HashSet<>(incomingAliasKeys);
            toInsert.removeAll(existingForAsserter);

            if (toDelete.isEmpty() && toInsert.isEmpty() && !shouldDeleteUnknownAssertions) {
                continue;
            }

            for (final VulnerabilityKey aliasKey : toDelete) {
                assertionsToDelete.add(new Assertion(asserter, incomingVulnKey, aliasKey));
            }
            for (final VulnerabilityKey aliasKey : toInsert) {
                assertionsToCreate.add(new Assertion(asserter, incomingVulnKey, aliasKey));
            }

            modifiedVulnKeys.add(incomingVulnKey);
            modifiedVulnKeys.addAll(toDelete);
            modifiedVulnKeys.addAll(toInsert);

            if (shouldDeleteUnknownAssertions) {
                vulnsNeedingUnknownCleanup.add(incomingVulnKey);
                modifiedVulnKeys.addAll(unknownAliases);
            }
        }

        return new ReconcileAssertionsResult(
                assertionsToCreate,
                assertionsToDelete,
                vulnsNeedingUnknownCleanup,
                modifiedVulnKeys);
    }

    private int createAssertions(Collection<Assertion> assertions) {
        if (assertions.isEmpty()) {
            return 0;
        }

        final var asserters = new String[assertions.size()];
        final var vulnSources = new String[assertions.size()];
        final var vulnIds = new String[assertions.size()];
        final var aliasSources = new String[assertions.size()];
        final var aliasIds = new String[assertions.size()];

        int i = 0;
        for (final Assertion assertion : assertions) {
            asserters[i] = assertion.asserter();
            vulnSources[i] = assertion.vulnKey().source().name();
            vulnIds[i] = assertion.vulnKey().vulnId();
            aliasSources[i] = assertion.aliasKey().source().name();
            aliasIds[i] = assertion.aliasKey().vulnId();
            i++;
        }

        return jdbiHandle
                .createUpdate(/* language=SQL */ """
                        INSERT INTO "VULNERABILITY_ALIAS_ASSERTION" (
                          "ASSERTER"
                        , "VULN_SOURCE"
                        , "VULN_ID"
                        , "ALIAS_SOURCE"
                        , "ALIAS_ID"
                        )
                        SELECT *
                          FROM UNNEST(:asserters, :vulnSources, :vulnIds, :aliasSources, :aliasIds)
                        """)
                .bind("asserters", asserters)
                .bind("vulnSources", vulnSources)
                .bind("vulnIds", vulnIds)
                .bind("aliasSources", aliasSources)
                .bind("aliasIds", aliasIds)
                .execute();
    }

    private int deleteAssertions(Collection<Assertion> assertions) {
        if (assertions.isEmpty()) {
            return 0;
        }

        final var asserters = new String[assertions.size()];
        final var vulnSources = new String[assertions.size()];
        final var vulnIds = new String[assertions.size()];
        final var aliasSources = new String[assertions.size()];
        final var aliasIds = new String[assertions.size()];

        int i = 0;
        for (final Assertion assertion : assertions) {
            asserters[i] = assertion.asserter();
            vulnSources[i] = assertion.vulnKey().source().name();
            vulnIds[i] = assertion.vulnKey().vulnId();
            aliasSources[i] = assertion.aliasKey().source().name();
            aliasIds[i] = assertion.aliasKey().vulnId();
            i++;
        }

        return jdbiHandle
                .createUpdate(/* language=SQL */ """
                        DELETE
                          FROM "VULNERABILITY_ALIAS_ASSERTION"
                         WHERE ("ASSERTER", "VULN_SOURCE", "VULN_ID", "ALIAS_SOURCE", "ALIAS_ID")
                            IN (SELECT * FROM UNNEST(:asserters, :vulnSources, :vulnIds, :aliasSources, :aliasIds))
                        """)
                .bind("asserters", asserters)
                .bind("vulnSources", vulnSources)
                .bind("vulnIds", vulnIds)
                .bind("aliasSources", aliasSources)
                .bind("aliasIds", aliasIds)
                .execute();
    }

    private int deleteAssertionsOfUnknownAsserter(Collection<VulnerabilityKey> vulnKeys) {
        if (vulnKeys.isEmpty()) {
            return 0;
        }

        final var sources = new String[vulnKeys.size()];
        final var vulnIds = new String[vulnKeys.size()];

        int i = 0;
        for (final VulnerabilityKey vulnKey : vulnKeys) {
            sources[i] = vulnKey.source().name();
            vulnIds[i] = vulnKey.vulnId();
            i++;
        }

        return jdbiHandle
                .createUpdate(/* language=SQL */ """
                        DELETE
                          FROM "VULNERABILITY_ALIAS_ASSERTION"
                         WHERE "ASSERTER" = :asserter
                           AND ("VULN_SOURCE", "VULN_ID") IN (SELECT * FROM UNNEST(:sources, :vulnIds))
                        """)
                .bind("asserter", UNKNOWN_ASSERTER)
                .bind("sources", sources)
                .bind("vulnIds", vulnIds)
                .execute();
    }

    private record Alias(VulnerabilityKey vulnKey, UUID groupId) {

        private static final RowMapper<Alias> ROW_MAPPER = (rs, ctx) ->
                new Alias(
                        new VulnerabilityKey(
                                rs.getString("vuln_id"),
                                rs.getString("source")),
                        rs.getObject("group_id", UUID.class));

    }

    private void computeAliasGroups(Collection<VulnerabilityKey> vulnKeys) {
        if (vulnKeys.isEmpty()) {
            return;
        }

        // Alias group computation requires knowledge of all transitively related
        // vuln keys, not just the ones that were directly modified. For example,
        // if CVE-1 is being linked to GHSA-1, but GHSA-1 is already in a group
        // with GHSA-2, we need to include GHSA-2 to produce a correct merged group.
        final ExpandAliasesResult expansion = expandAliases(vulnKeys);
        LOGGER.debug("Computing alias groups for {} vulnerabilities", expansion.aliases().size());

        // NB: Technically we should acquire advisory locks for all expanded
        // vuln keys. Practically that could lead to deadlocks, or require
        // us to restart the entire procedure. We do not do this for now,
        // as the risk for data races at this point is low.
        //
        // The worst case here is that we produce incomplete or suboptimal
        // groups, which would self-heal during the next computation run anyway.

        // Build union-find from assertions.
        final var unionFind = new UnionFind<VulnerabilityKey>();
        for (final Assertion assertion : expansion.assertions()) {
            unionFind.unionSets(assertion.vulnKey(), assertion.aliasKey());
        }

        // Map vuln keys to their existing group ID for easier lookup.
        final Map<VulnerabilityKey, UUID> existingGroupIdByVulnKey =
                expansion.aliases().stream()
                        .collect(Collectors.toMap(
                                Alias::vulnKey,
                                Alias::groupId));

        // Compute desired state: upsert rows that are new or changed,
        // delete orphaned rows that are no longer in any component.
        final var desiredAliases = new ArrayList<Alias>();
        final var desiredVulnKeys = new HashSet<VulnerabilityKey>();

        for (final List<VulnerabilityKey> component : unionFind.components()) {
            final var existingGroups = new TreeSet<UUID>();
            for (final VulnerabilityKey vulnKey : component) {
                final UUID existing = existingGroupIdByVulnKey.get(vulnKey);
                if (existing != null) {
                    existingGroups.add(existing);
                }
            }

            // Pick an existing group ID, or generate a new one.
            // NB: This is deterministic due to existingGroups being a tree set.
            final UUID groupId = !existingGroups.isEmpty()
                    ? existingGroups.first()
                    : UUID.randomUUID();

            for (final VulnerabilityKey vulnKey : component) {
                desiredAliases.add(new Alias(vulnKey, groupId));
                desiredVulnKeys.add(vulnKey);
            }
        }

        final int aliasesUpserted = upsertAll(desiredAliases);
        if (aliasesUpserted > 0) {
            LOGGER.debug("Upserted {} aliases", aliasesUpserted);
        }

        // Delete orphaned aliases.
        // Orphans existed in old groups but not in any new ones.
        final var orphanedVulnKeys = new HashSet<>(existingGroupIdByVulnKey.keySet());
        orphanedVulnKeys.removeAll(desiredVulnKeys);

        final int orphansDeleted = deleteAll(orphanedVulnKeys);
        if (orphansDeleted > 0) {
            LOGGER.debug("Deleted {} orphaned aliases", orphansDeleted);
        }
    }

    private record ExpandAliasesResult(
            List<Alias> aliases,
            List<Assertion> assertions) {
    }

    private ExpandAliasesResult expandAliases(Collection<VulnerabilityKey> vulnKeys) {
        final var allAliases = new ArrayList<Alias>();
        final var allAssertions = new ArrayList<Assertion>();
        final var expandedVulnKeys = new HashSet<VulnerabilityKey>();
        var pairsToExpand = new HashSet<>(vulnKeys);

        while (!pairsToExpand.isEmpty()) {
            final List<Alias> aliases = getAll(pairsToExpand);
            allAliases.addAll(aliases);
            for (final Alias alias : aliases) {
                pairsToExpand.add(alias.vulnKey());
            }

            expandedVulnKeys.addAll(pairsToExpand);

            final List<Assertion> assertions = getAssertionsReferencingAny(pairsToExpand);
            allAssertions.addAll(assertions);

            final var nextBatch = new HashSet<VulnerabilityKey>();
            for (final Assertion assertion : assertions) {
                if (!expandedVulnKeys.contains(assertion.vulnKey())) {
                    nextBatch.add(assertion.vulnKey());
                }
                if (!expandedVulnKeys.contains(assertion.aliasKey())) {
                    nextBatch.add(assertion.aliasKey());
                }
            }
            pairsToExpand = nextBatch;
        }

        return new ExpandAliasesResult(allAliases, allAssertions);
    }

    private List<Alias> getAll(Collection<VulnerabilityKey> vulnKeys) {
        if (vulnKeys.isEmpty()) {
            return List.of();
        }

        final var sources = new String[vulnKeys.size()];
        final var vulnIds = new String[vulnKeys.size()];

        int i = 0;
        for (final VulnerabilityKey pair : vulnKeys) {
            sources[i] = pair.source().name();
            vulnIds[i] = pair.vulnId();
            i++;
        }

        return jdbiHandle
                .createQuery(/* language=SQL */ """
                        SELECT va."SOURCE"
                             , va."VULN_ID"
                             , va."GROUP_ID"
                          FROM "VULNERABILITY_ALIAS" AS va
                         WHERE va."GROUP_ID" IN (
                           SELECT "GROUP_ID"
                             FROM "VULNERABILITY_ALIAS" AS va2
                            WHERE (va2."SOURCE", va2."VULN_ID") IN (
                              SELECT *
                                FROM UNNEST(:sources, :vulnIds)
                            )
                         )
                        """)
                .bind("sources", sources)
                .bind("vulnIds", vulnIds)
                .map(Alias.ROW_MAPPER)
                .list();
    }

    private List<Assertion> getAssertionsReferencingAny(Collection<VulnerabilityKey> vulnKeys) {
        if (vulnKeys.isEmpty()) {
            return List.of();
        }

        final var sources = new String[vulnKeys.size()];
        final var vulnIds = new String[vulnKeys.size()];

        int i = 0;
        for (final VulnerabilityKey pair : vulnKeys) {
            sources[i] = pair.source().name();
            vulnIds[i] = pair.vulnId();
            i++;
        }

        return new ArrayList<>(jdbiHandle
                .createQuery(/* language=SQL */ """
                        SELECT DISTINCT "ASSERTER", "VULN_SOURCE", "VULN_ID", "ALIAS_SOURCE", "ALIAS_ID"
                          FROM "VULNERABILITY_ALIAS_ASSERTION"
                         WHERE ("VULN_SOURCE", "VULN_ID") IN (SELECT * FROM UNNEST(:sources, :vulnIds))
                            OR ("ALIAS_SOURCE", "ALIAS_ID") IN (SELECT * FROM UNNEST(:sources, :vulnIds))
                        """)
                .bind("sources", sources)
                .bind("vulnIds", vulnIds)
                .map(Assertion.ROW_MAPPER)
                .list());
    }

    private int upsertAll(Collection<Alias> aliases) {
        if (aliases.isEmpty()) {
            return 0;
        }

        final var groupIds = new UUID[aliases.size()];
        final var sources = new String[aliases.size()];
        final var vulnIds = new String[aliases.size()];

        int i = 0;
        for (final Alias alias : aliases) {
            groupIds[i] = alias.groupId();
            sources[i] = alias.vulnKey().source().name();
            vulnIds[i] = alias.vulnKey().vulnId();
            i++;
        }

        return jdbiHandle
                .createUpdate(/* language=SQL */ """
                        INSERT INTO "VULNERABILITY_ALIAS" AS va ("GROUP_ID", "SOURCE", "VULN_ID")
                        SELECT * FROM UNNEST(:groupIds, :sources, :vulnIds)
                        ON CONFLICT ("SOURCE", "VULN_ID") DO UPDATE
                        SET "GROUP_ID" = EXCLUDED."GROUP_ID"
                        WHERE va."GROUP_ID" IS DISTINCT FROM EXCLUDED."GROUP_ID"
                        """)
                .bind("groupIds", groupIds)
                .bind("sources", sources)
                .bind("vulnIds", vulnIds)
                .execute();
    }

    private int deleteAll(Collection<VulnerabilityKey> vulnKeys) {
        if (vulnKeys.isEmpty()) {
            return 0;
        }

        final var sources = new String[vulnKeys.size()];
        final var vulnIds = new String[vulnKeys.size()];

        int i = 0;
        for (final VulnerabilityKey vulnKey : vulnKeys) {
            sources[i] = vulnKey.source().name();
            vulnIds[i] = vulnKey.vulnId();
            i++;
        }

        return jdbiHandle
                .createUpdate(/* language=SQL */ """
                        DELETE
                          FROM "VULNERABILITY_ALIAS"
                         WHERE ("SOURCE", "VULN_ID")
                            IN (SELECT * FROM UNNEST(:sources, :vulnIds))
                        """)
                .bind("sources", sources)
                .bind("vulnIds", vulnIds)
                .execute();
    }

    /**
     * Minimal union-set implementation that we use to group aliases.
     * <p>
     * Uses path compression and union by size as optimizations,
     * although that's unlikely to matter much given alias groups
     * are small most of the time.
     *
     * @see <a href="https://cp-algorithms.com/data_structures/disjoint_set_union.html">Reference</a>
     */
    private static final class UnionFind<T> {

        private final Map<T, T> parent = new HashMap<>();
        private final Map<T, Integer> size = new HashMap<>();

        private void unionSets(T a, T b) {
            a = findSet(makeSet(a));
            b = findSet(makeSet(b));

            if (!a.equals(b)) {
                if (size.get(a) < size.get(b)) {
                    final T tmp = a;
                    a = b;
                    b = tmp;
                }
                parent.put(b, a);
                size.merge(a, size.get(b), Integer::sum);
            }
        }

        private T findSet(T v) {
            final T p = parent.get(v);
            if (v.equals(p)) {
                return v;
            }

            final T root = findSet(p);
            parent.put(v, root);
            return root;
        }

        private T makeSet(T v) {
            parent.putIfAbsent(v, v);
            size.putIfAbsent(v, 1);
            return v;
        }

        private Collection<List<T>> components() {
            final var result = new HashMap<T, List<T>>();
            for (final T element : parent.keySet()) {
                result.computeIfAbsent(findSet(element), k -> new ArrayList<>())
                        .add(element);
            }
            return result.values();
        }

    }

}
