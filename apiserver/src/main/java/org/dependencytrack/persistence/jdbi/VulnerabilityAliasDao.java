/*
 * This file is part of Dependency-Track.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 * Copyright (c) OWASP Foundation. All Rights Reserved.
 */
package org.dependencytrack.persistence.jdbi;

import org.dependencytrack.model.VulnIdAndSource;
import org.dependencytrack.model.Vulnerability;
import org.dependencytrack.model.VulnerabilityAlias;
import org.jdbi.v3.core.Handle;

import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.TreeSet;
import java.util.UUID;

/**
 * @since 5.7.0
 */
public final class VulnerabilityAliasDao {

    private final Handle jdbiHandle;

    public VulnerabilityAliasDao(Handle jdbiHandle) {
        this.jdbiHandle = jdbiHandle;
    }

    public void syncAll(Collection<VulnerabilityAlias> aliases) {
        if (aliases == null || aliases.isEmpty()) {
            return;
        }

        // Collect all unique source-vulnId pairs, tracking connectivity between them.
        // Pairs from the same alias must end up in the same group.
        final var pairByIndex = new HashMap<VulnIdAndSource, Integer>();
        final var indexedPairs = new ArrayList<VulnIdAndSource>();
        final var edges = new ArrayList<int[]>();

        for (final VulnerabilityAlias alias : aliases) {
            final Map<Vulnerability.Source, String> vulnIdBySource = alias.getAllBySource();
            if (vulnIdBySource.isEmpty()) {
                continue;
            }

            int firstPairIndex = -1;
            for (final var entry : vulnIdBySource.entrySet()) {
                final Vulnerability.Source source = entry.getKey();
                final String vulnId = entry.getValue();
                final var pair = new VulnIdAndSource(vulnId, source);

                Integer pairIndex = pairByIndex.get(pair);
                if (pairIndex == null) {
                    pairIndex = indexedPairs.size();
                    pairByIndex.put(pair, pairIndex);
                    indexedPairs.add(pair);
                }

                if (firstPairIndex == -1) {
                    firstPairIndex = pairIndex;
                } else {
                    edges.add(new int[]{firstPairIndex, pairIndex});
                }
            }
        }

        if (indexedPairs.isEmpty()) {
            return;
        }

        final var lockKeys = new String[indexedPairs.size()];
        final var sources = new String[indexedPairs.size()];
        final var vulnIds = new String[indexedPairs.size()];

        for (int i = 0; i < indexedPairs.size(); i++) {
            final VulnIdAndSource pair = indexedPairs.get(i);
            lockKeys[i] = "%s|%s".formatted(pair.source(), pair.vulnId());
            sources[i] = pair.source().name();
            vulnIds[i] = pair.vulnId();
        }

        // Grouping is not concurrency-safe, so we need to acquire advisory locks for
        // all pairs we're processing. Note that we MUST acquire them in deterministic order,
        // as otherwise we'd be risking deadlocks.
        jdbiHandle
                .createQuery(/* language=SQL */ """
                        SELECT PG_ADVISORY_XACT_LOCK(HASHTEXT(key))
                          FROM (
                            SELECT DISTINCT UNNEST(:keys) AS key
                            ORDER BY 1
                          ) AS t
                        """)
                .bind("keys", lockKeys)
                .mapToMap()
                .list();

        // Fetch existing alias records.
        final List<VulnerabilityAliasRow> existingRows = jdbiHandle
                .createQuery(/* language=SQL */ """
                        SELECT "SOURCE"
                             , "VULN_ID"
                             , "GROUP_ID"
                          FROM "VULNERABILITY_ALIAS"
                         WHERE ("SOURCE", "VULN_ID") IN (
                            SELECT * FROM UNNEST(:sources, :vulnIds)
                         )
                        """)
                .bind("sources", sources)
                .bind("vulnIds", vulnIds)
                .map((rs, ctx) -> new VulnerabilityAliasRow(
                        new VulnIdAndSource(
                                rs.getString("vuln_id"),
                                rs.getString("source")),
                        rs.getObject("group_id", UUID.class)))
                .list();

        final var existingGroupIdByPairIndex = new HashMap<Integer, UUID>(existingRows.size());
        for (final VulnerabilityAliasRow existingRow : existingRows) {
            final Integer index = pairByIndex.get(existingRow.vulnIdAndSource());
            if (index != null) {
                existingGroupIdByPairIndex.put(index, existingRow.groupId());
            }
        }

        // Initialize union-find and merge sets based on the information
        // provided as this method's input. This does not include existing
        // sets from the database yet.
        final var unionFind = new UnionFind(indexedPairs.size());
        for (int i = 0; i < indexedPairs.size(); i++) {
            unionFind.makeSet(i);
        }
        for (final int[] edge : edges) {
            unionFind.unionSets(edge[0], edge[1]);
        }

        // Merge with existing sets from the database.
        final var pairIndexByGroupId = new HashMap<UUID, Integer>();
        for (final var entry : existingGroupIdByPairIndex.entrySet()) {
            final Integer pairIndex = entry.getKey();
            final UUID existingGroupId = entry.getValue();

            final Integer previousPairIndex = pairIndexByGroupId.get(existingGroupId);
            if (previousPairIndex != null) {
                unionFind.unionSets(previousPairIndex, pairIndex);
            } else {
                pairIndexByGroupId.put(existingGroupId, pairIndex);
            }
        }

        // Identify components (i.e. subgraphs, or effectively alias groups).
        final var components = new HashMap<Integer, List<Integer>>();
        for (int i = 0; i < indexedPairs.size(); i++) {
            components
                    .computeIfAbsent(unionFind.findSet(i), k -> new ArrayList<>())
                    .add(i);
        }

        final var groupIdsToInsert = new ArrayList<UUID>();
        final var sourcesToInsert = new ArrayList<String>();
        final var vulnIdsToInsert = new ArrayList<String>();

        for (final var component : components.values()) {
            final var existingGroups = new TreeSet<UUID>();
            for (final Integer pairIndex : component) {
                final UUID groupId = existingGroupIdByPairIndex.get(pairIndex);
                if (groupId != null) {
                    existingGroups.add(groupId);
                }
            }

            // Pick an existing group ID, or generate a new one.
            // NB: This is deterministic due to existingGroups being a tree set.
            final UUID groupId = !existingGroups.isEmpty()
                    ? existingGroups.first()
                    : UUID.randomUUID();

            // If we have more than one existing group, merge them into one.
            if (existingGroups.size() > 1) {
                jdbiHandle
                        .createUpdate(/* language=SQL */ """
                                UPDATE "VULNERABILITY_ALIAS"
                                   SET "GROUP_ID" = :toGroup
                                 WHERE "GROUP_ID" = ANY(:fromGroups)
                                   AND "GROUP_ID" != :toGroup
                                """)
                        .bind("toGroup", groupId)
                        .bindArray("fromGroups", UUID.class, existingGroups)
                        .execute();
            }

            // Queue all pairs for batch insert.
            for (final int pairIndex : component) {
                final VulnIdAndSource pair = indexedPairs.get(pairIndex);
                groupIdsToInsert.add(groupId);
                sourcesToInsert.add(pair.source().name());
                vulnIdsToInsert.add(pair.vulnId());
            }
        }

        // Batch-insert all pairs.
        if (!groupIdsToInsert.isEmpty()) {
            jdbiHandle
                    .createUpdate(/* language=SQL */ """
                            INSERT INTO "VULNERABILITY_ALIAS" ("GROUP_ID", "SOURCE", "VULN_ID")
                            SELECT * FROM UNNEST(:groupIds, :sources, :vulnIds)
                            ON CONFLICT DO NOTHING
                            """)
                    .bindArray("groupIds", UUID.class, groupIdsToInsert)
                    .bindArray("sources", String.class, sourcesToInsert)
                    .bindArray("vulnIds", String.class, vulnIdsToInsert)
                    .execute();
        }
    }

    public void sync(VulnerabilityAlias alias) {
        syncAll(List.of(alias));
    }

    private record VulnerabilityAliasRow(VulnIdAndSource vulnIdAndSource, UUID groupId) {
    }

    /**
     * Minimal union-set implementation that we use to group aliases.
     * <p>
     * This implementation uses path compression and union by size
     * as optimizations, although that's unlikely to matter much given
     * alias groups are not large most of the time.
     *
     * @see <a href="https://cp-algorithms.com/data_structures/disjoint_set_union.html">Reference</a>
     */
    private static class UnionFind {

        private final int[] parent;
        private final int[] size;

        private UnionFind(int size) {
            this.parent = new int[size];
            this.size = new int[size];
        }

        private void makeSet(int v) {
            parent[v] = v;
            size[v] = 1;
        }

        private int findSet(int v) {
            if (v == parent[v]) {
                return v;
            }

            return parent[v] = findSet(parent[v]);
        }

        private void unionSets(int a, int b) {
            a = findSet(a);
            b = findSet(b);

            if (a != b) {
                if (size[a] < size[b]) {
                    // swap(a, b)
                    // There is no native Java method for this.
                    int tmp = a;
                    a = b;
                    b = tmp;
                }
                parent[b] = a;
                size[a] += size[b];
            }
        }

    }

}
