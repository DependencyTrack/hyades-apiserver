/*
 * This file is part of Dependency-Track.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 * Copyright (c) OWASP Foundation. All Rights Reserved.
 */
package org.dependencytrack.persistence.jdbi;

import alpine.persistence.PaginatedResult;
import org.dependencytrack.model.Analysis;
import org.dependencytrack.model.AnalysisJustification;
import org.dependencytrack.model.AnalysisResponse;
import org.dependencytrack.model.AnalysisState;
import org.dependencytrack.persistence.jdbi.mapping.AnalysisRowMapper;
import org.dependencytrack.persistence.jdbi.mapping.PaginatedVulnerabilityPolicyRowReducer;
import org.dependencytrack.policy.vulnerability.VulnerabilityPolicy;
import org.dependencytrack.util.AnalysisCommentFormatter.AnalysisCommentField;
import org.jdbi.v3.sqlobject.SqlObject;
import org.jdbi.v3.sqlobject.config.RegisterBeanMapper;
import org.jdbi.v3.sqlobject.customizer.Bind;
import org.jdbi.v3.sqlobject.customizer.BindBean;
import org.jdbi.v3.sqlobject.statement.GetGeneratedKeys;
import org.jdbi.v3.sqlobject.statement.SqlQuery;
import org.jdbi.v3.sqlobject.statement.SqlUpdate;
import org.jdbi.v3.sqlobject.statement.UseRowReducer;

import java.util.ArrayList;
import java.util.List;

import static org.dependencytrack.util.AnalysisCommentFormatter.formatComment;

@RegisterBeanMapper(VulnerabilityPolicy.class)
public interface VulnerabilityPolicyDao extends SqlObject {

    @SqlQuery("""  
            SELECT * FROM "VULNERABILITY_POLICY"
            """)
    List<VulnerabilityPolicy> getAll();

    @SqlQuery("""
            SELECT
              *
            FROM
              "VULNERABILITY_POLICY"
            WHERE
              ("VALID_FROM" IS NULL OR "VALID_FROM" <= NOW())
              AND ("VALID_UNTIL" IS NULL OR "VALID_UNTIL" >= NOW())
              AND ("OPERATION_MODE" != 'DISABLED')
            """)
    List<VulnerabilityPolicy> getAllEnabledAndValid();

    @SqlQuery(/* language=InjectedFreeMarker */ """
            <#-- @ftlvariable name="apiFilterParameter" type="String" -->
            <#-- @ftlvariable name="apiOrderByClause" type="String" -->
            <#-- @ftlvariable name="apiOffsetLimitClause" type="String" -->
            SELECT
              "ID"            AS "id",
              "ANALYSIS",
              "AUTHOR"        AS "author",
              "CONDITIONS",
              "CREATED"       AS "created",
              "NAME"          AS "name",
              "RATINGS",
              "UPDATED"       AS "updated",
              "VALID_FROM"    AS "validFrom",
              "VALID_UNTIL"   AS "validUntil",
              "OPERATION_MODE" AS "operationMode",
              COUNT(*) OVER() AS "totalCount"
            FROM
              "VULNERABILITY_POLICY"
            <#if apiFilterParameter??>
            WHERE
              "NAME" LIKE ('%' || ${apiFilterParameter} || '%')
            </#if>
            ${apiOrderByClause!}
            ${apiOffsetLimitClause!}
            """)
    @AllowApiOrdering(alwaysBy = "id", by = {
            @AllowApiOrdering.Column(name = "id"),
            @AllowApiOrdering.Column(name = "author"),
            @AllowApiOrdering.Column(name = "created"),
            @AllowApiOrdering.Column(name = "name"),
            @AllowApiOrdering.Column(name = "updated"),
            @AllowApiOrdering.Column(name = "validFrom"),
            @AllowApiOrdering.Column(name = "validUntil"),
            @AllowApiOrdering.Column(name = "operationMode")
    })
    @UseRowReducer(PaginatedVulnerabilityPolicyRowReducer.class)
    PaginatedResult getPage();

    @SqlQuery("""  
            SELECT * FROM "VULNERABILITY_POLICY" WHERE "NAME" = ?
            """)
    VulnerabilityPolicy getByName(@Bind String name);

    @SqlUpdate("""
            INSERT INTO "VULNERABILITY_POLICY"
              ("ANALYSIS", "AUTHOR", "CONDITIONS", "CREATED", "DESCRIPTION", "NAME", "RATINGS", "VALID_FROM", "VALID_UNTIL", "OPERATION_MODE")
            VALUES
              ((:analysis)::JSONB, :author, :conditions, NOW(), :description, :name, (:ratings)::JSONB, :validFrom, :validUntil, :operationMode)
            RETURNING *
            """)
    @GetGeneratedKeys("*")
    VulnerabilityPolicy create(@BindBean VulnerabilityPolicy vulnerabilityPolicy);

    @SqlUpdate("""
            DELETE FROM "VULNERABILITY_POLICY" WHERE "NAME" = ?
            """)
    int deleteByName(@Bind String name);

    @SqlUpdate("""
            UPDATE "VULNERABILITY_POLICY"
            SET
              "ANALYSIS"    = (:analysis)::JSONB,
              "AUTHOR"      = :author,
              "CONDITIONS"  = :conditions,
              "DESCRIPTION" = :description,
              "RATINGS"     = (:ratings)::JSONB,
              "UPDATED"     = NOW(),
              "VALID_FROM"  = :validFrom,
              "VALID_UNTIL" = :validUntil,
              "OPERATION_MODE" = :operationMode
            WHERE
              "NAME" = :name AND (
                -- Using IS DISTINCT FROM instead of != for nullable columns
                -- because != does not handle NULL.
                "ANALYSIS"       != (:analysis)::JSONB
                OR "AUTHOR"      IS DISTINCT FROM :author
                OR "CONDITIONS"  != (:conditions)::TEXT[]
                OR "DESCRIPTION" IS DISTINCT FROM :description
                OR "RATINGS"     IS DISTINCT FROM (:ratings)::JSONB
                OR "VALID_FROM"  IS DISTINCT FROM :validFrom
                OR "VALID_UNTIL" IS DISTINCT FROM :validUntil
                OR "OPERATION_MODE" IS DISTINCT FROM :operationMode
              )
            RETURNING *
            """)
    @GetGeneratedKeys("*")
    VulnerabilityPolicy update(@BindBean VulnerabilityPolicy vulnerabilityPolicy);

    default List<Analysis> unassignFromAnalysesByName(final String name) {
        // NB: Can't use interface method here due to https://github.com/jdbi/jdbi/issues/1807.
        return getHandle().createUpdate("""
                        WITH "CTE_VULN_POLICY" AS (
                          SELECT
                            "ID"
                          FROM
                            "VULNERABILITY_POLICY"
                          WHERE
                            "NAME" = :name
                        )
                        UPDATE
                          "ANALYSIS" AS "NEW"
                        SET
                          "STATE"                   = 'NOT_SET', -- Must be non-null
                          "JUSTIFICATION"           = NULL,
                          "RESPONSE"                = NULL,
                          "DETAILS"                 = NULL,
                          "SUPPRESSED"              = FALSE,
                          "SEVERITY"                = NULL,
                          "CVSSV2VECTOR"            = NULL,
                          "CVSSV2SCORE"             = NULL,
                          "CVSSV3VECTOR"            = NULL,
                          "CVSSV3SCORE"             = NULL,
                          "OWASPVECTOR"             = NULL,
                          "OWASPSCORE"              = NULL,
                          "VULNERABILITY_POLICY_ID" = NULL
                        FROM
                          "ANALYSIS" AS "OLD" -- Self-join to get access to pre-update values
                        WHERE
                          "NEW"."ID" = "OLD"."ID"
                          AND "NEW"."VULNERABILITY_POLICY_ID" IS NOT NULL
                          AND "NEW"."VULNERABILITY_POLICY_ID" = (SELECT "ID" FROM "CTE_VULN_POLICY")
                        RETURNING
                          "OLD"."ID",
                          "OLD"."STATE",
                          "OLD"."JUSTIFICATION",
                          "OLD"."RESPONSE",
                          "OLD"."DETAILS",
                          "OLD"."SUPPRESSED",
                          "OLD"."SEVERITY",
                          "OLD"."CVSSV2VECTOR",
                          "OLD"."CVSSV2SCORE",
                          "OLD"."CVSSV3VECTOR",
                          "OLD"."CVSSV3SCORE",
                          "OLD"."OWASPVECTOR",
                          "OLD"."OWASPSCORE"
                        """)
                .bind("name", name)
                .executeAndReturnGeneratedKeys()
                .map(new AnalysisRowMapper())
                .list();
    }

    /**
     * Un-assign a given {@link VulnerabilityPolicy} from any associated {@link Analysis}
     * records, reset the analyses' states, and populate the audit trail accordingly.
     *
     * @param name Name of the {@link VulnerabilityPolicy} to un-assign
     */
    default void unassignAndDeleteByName(String name) {
        final List<Analysis> unassignedAnalyses = unassignFromAnalysesByName(name);
        deleteByName(name);

        final var commenter = "[Policy{Name=%s}]".formatted(name);
        final var createCommentCommands = new ArrayList<AnalysisDao.CreateCommentCommand>();

        for (final Analysis analysis : unassignedAnalyses) {
            final long id = analysis.getId();
            createCommentCommands.add(new AnalysisDao.CreateCommentCommand(id, commenter, "Policy removed"));

            if (analysis.getAnalysisState() != null && analysis.getAnalysisState() != AnalysisState.NOT_SET) {
                final String comment = formatComment(AnalysisCommentField.STATE, analysis.getAnalysisState(), null);
                createCommentCommands.add(new AnalysisDao.CreateCommentCommand(id, commenter, comment));
            }
            if (analysis.getAnalysisJustification() != null && analysis.getAnalysisJustification() != AnalysisJustification.NOT_SET) {
                final String comment = formatComment(AnalysisCommentField.JUSTIFICATION, analysis.getAnalysisJustification(), null);
                createCommentCommands.add(new AnalysisDao.CreateCommentCommand(id, commenter, comment));
            }
            if (analysis.getAnalysisResponse() != null && analysis.getAnalysisResponse() != AnalysisResponse.NOT_SET) {
                final String comment = formatComment(AnalysisCommentField.RESPONSE, analysis.getAnalysisResponse(), null);
                createCommentCommands.add(new AnalysisDao.CreateCommentCommand(id, commenter, comment));
            }
            if (analysis.getAnalysisDetails() != null) {
                final String comment = formatComment(AnalysisCommentField.DETAILS, analysis.getAnalysisDetails(), null);
                createCommentCommands.add(new AnalysisDao.CreateCommentCommand(id, commenter, comment));
            }
            if (analysis.isSuppressed()) {
                final String comment = formatComment(AnalysisCommentField.SUPPRESSED, true, false);
                createCommentCommands.add(new AnalysisDao.CreateCommentCommand(id, commenter, comment));
            }
            if (analysis.getSeverity() != null) {
                final String comment = formatComment(AnalysisCommentField.SEVERITY, analysis.getSeverity(), null);
                createCommentCommands.add(new AnalysisDao.CreateCommentCommand(id, commenter, comment));
            }
            if (analysis.getCvssV2Vector() != null) {
                final String comment = formatComment(AnalysisCommentField.CVSSV2_VECTOR, analysis.getCvssV2Vector(), null);
                createCommentCommands.add(new AnalysisDao.CreateCommentCommand(id, commenter, comment));
            }
            if (analysis.getCvssV2Score() != null) {
                final String comment = formatComment(AnalysisCommentField.CVSSV2_SCORE, analysis.getCvssV2Score(), null);
                createCommentCommands.add(new AnalysisDao.CreateCommentCommand(id, commenter, comment));
            }
            if (analysis.getCvssV3Vector() != null) {
                final String comment = formatComment(AnalysisCommentField.CVSSV3_VECTOR, analysis.getCvssV3Vector(), null);
                createCommentCommands.add(new AnalysisDao.CreateCommentCommand(id, commenter, comment));
            }
            if (analysis.getCvssV3Score() != null) {
                final String comment = formatComment(AnalysisCommentField.CVSSV3_SCORE, analysis.getCvssV3Score(), null);
                createCommentCommands.add(new AnalysisDao.CreateCommentCommand(id, commenter, comment));
            }
            if (analysis.getCvssV4Vector() != null) {
                final String comment = formatComment(AnalysisCommentField.CVSSV4_VECTOR, analysis.getCvssV4Vector(), null);
                createCommentCommands.add(new AnalysisDao.CreateCommentCommand(id, commenter, comment));
            }
            if (analysis.getCvssV4Score() != null) {
                final String comment = formatComment(AnalysisCommentField.CVSSV4_SCORE, analysis.getCvssV4Score(), null);
                createCommentCommands.add(new AnalysisDao.CreateCommentCommand(id, commenter, comment));
            }
            if (analysis.getOwaspVector() != null) {
                final String comment = formatComment(AnalysisCommentField.OWASP_VECTOR, analysis.getOwaspVector(), null);
                createCommentCommands.add(new AnalysisDao.CreateCommentCommand(id, commenter, comment));
            }
            if (analysis.getOwaspScore() != null) {
                final String comment = formatComment(AnalysisCommentField.OWASP_SCORE, analysis.getOwaspScore(), null);
                createCommentCommands.add(new AnalysisDao.CreateCommentCommand(id, commenter, comment));
            }
        }

        if (!createCommentCommands.isEmpty()) {
            new AnalysisDao(getHandle()).createComments(createCommentCommands);
        }
    }

}
