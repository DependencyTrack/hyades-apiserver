/*
 * This file is part of Dependency-Track.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 * Copyright (c) OWASP Foundation. All Rights Reserved.
 */
package org.dependencytrack.persistence;

import alpine.persistence.PaginatedResult;
import alpine.resources.AlpineRequest;
import org.apache.commons.lang3.StringUtils;
import org.dependencytrack.model.AffectedVersionAttribution;
import org.dependencytrack.model.Analysis;
import org.dependencytrack.model.Component;
import org.dependencytrack.model.Epss;
import org.dependencytrack.model.FindingAttribution;
import org.dependencytrack.model.Project;
import org.dependencytrack.model.Tag;
import org.dependencytrack.model.Vulnerability;
import org.dependencytrack.model.VulnerabilityAlias;
import org.dependencytrack.model.VulnerableSoftware;
import org.dependencytrack.persistence.jdbi.VulnerabilityDao;
import org.dependencytrack.persistence.jdbi.VulnerabilityDao.AffectedProjectCountRow;
import org.jdbi.v3.core.Handle;

import javax.jdo.PersistenceManager;
import javax.jdo.Query;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.function.Function;
import java.util.stream.Collectors;

import static org.dependencytrack.persistence.jdbi.JdbiFactory.openJdbiHandle;
import static org.dependencytrack.persistence.jdbi.JdbiFactory.withJdbiHandle;
import static org.dependencytrack.util.PersistenceUtil.assertPersistent;
import static org.dependencytrack.util.PersistenceUtil.assertPersistentAll;

final class VulnerabilityQueryManager extends QueryManager implements IQueryManager {

    /**
     * Constructs a new QueryManager.
     * @param pm a PersistenceManager object
     */
    VulnerabilityQueryManager(final PersistenceManager pm) {
        super(pm);
    }

    /**
     * Constructs a new QueryManager.
     * @param pm a PersistenceManager object
     * @param request an AlpineRequest object
     */
    VulnerabilityQueryManager(final PersistenceManager pm, final AlpineRequest request) {
        super(pm, request);
    }

    /**
     * Creates a new Vulnerability.
     * @param vulnerability the vulnerability to persist
     * @param commitIndex specifies if the search index should be committed (an expensive operation)
     * @return a new vulnerability object
     */
    public Vulnerability createVulnerability(Vulnerability vulnerability, boolean commitIndex) {
        final Vulnerability result = persist(vulnerability);
        return result;
    }

    /**
     * Updates a vulnerability.
     * @param transientVulnerability the vulnerability to update
     * @param commitIndex specifies if the search index should be committed (an expensive operation)
     * @return a Vulnerability object
     */
    public Vulnerability updateVulnerability(Vulnerability transientVulnerability, boolean commitIndex) {
        final Vulnerability vulnerability;
        if (transientVulnerability.getId() > 0) {
            vulnerability = getObjectById(Vulnerability.class, transientVulnerability.getId());
        } else {
            vulnerability = getVulnerabilityByVulnId(transientVulnerability.getSource(), transientVulnerability.getVulnId());
        }
        if (vulnerability != null) {
            vulnerability.setCreated(transientVulnerability.getCreated());
            vulnerability.setPublished(transientVulnerability.getPublished());
            vulnerability.setUpdated(transientVulnerability.getUpdated());
            vulnerability.setVulnId(transientVulnerability.getVulnId());
            vulnerability.setSource(transientVulnerability.getSource());
            vulnerability.setCredits(transientVulnerability.getCredits());
            vulnerability.setVulnerableVersions(transientVulnerability.getVulnerableVersions());
            vulnerability.setPatchedVersions(transientVulnerability.getPatchedVersions());
            vulnerability.setDescription(transientVulnerability.getDescription());
            vulnerability.setDetail(transientVulnerability.getDetail());
            vulnerability.setTitle(transientVulnerability.getTitle());
            vulnerability.setSubTitle(transientVulnerability.getSubTitle());
            vulnerability.setReferences(transientVulnerability.getReferences());
            vulnerability.setRecommendation(transientVulnerability.getRecommendation());
            vulnerability.setSeverity(transientVulnerability.getSeverity());
            vulnerability.setCvssV2Vector(transientVulnerability.getCvssV2Vector());
            vulnerability.setCvssV2BaseScore(transientVulnerability.getCvssV2BaseScore());
            vulnerability.setCvssV2ImpactSubScore(transientVulnerability.getCvssV2ImpactSubScore());
            vulnerability.setCvssV2ExploitabilitySubScore(transientVulnerability.getCvssV2ExploitabilitySubScore());
            vulnerability.setCvssV3Vector(transientVulnerability.getCvssV3Vector());
            vulnerability.setCvssV3BaseScore(transientVulnerability.getCvssV3BaseScore());
            vulnerability.setCvssV3ImpactSubScore(transientVulnerability.getCvssV3ImpactSubScore());
            vulnerability.setCvssV3ExploitabilitySubScore(transientVulnerability.getCvssV3ExploitabilitySubScore());
            vulnerability.setOwaspRRLikelihoodScore(transientVulnerability.getOwaspRRLikelihoodScore());
            vulnerability.setOwaspRRBusinessImpactScore(transientVulnerability.getOwaspRRBusinessImpactScore());
            vulnerability.setOwaspRRTechnicalImpactScore(transientVulnerability.getOwaspRRTechnicalImpactScore());
            vulnerability.setOwaspRRVector(transientVulnerability.getOwaspRRVector());
            vulnerability.setCwes(transientVulnerability.getCwes());
            if (transientVulnerability.getVulnerableSoftware() != null) {
                vulnerability.setVulnerableSoftware(transientVulnerability.getVulnerableSoftware());
            }
            final Vulnerability result = persist(vulnerability);
            return result;
        }
        return null;
    }

    /**
     * Synchronizes a vulnerability. Method first checkes to see if the vulnerability already
     * exists and if so, updates the vulnerability. If the vulnerability does not already exist,
     * this method will create a new vulnerability.
     * @param vulnerability the vulnerability to synchronize
     * @param commitIndex specifies if the search index should be committed (an expensive operation)
     * @return a Vulnerability object
     */
    public Vulnerability synchronizeVulnerability(Vulnerability vulnerability, boolean commitIndex) {
        Vulnerability result = updateVulnerability(vulnerability, commitIndex);
        if (result == null) {
            result = createVulnerability(vulnerability, commitIndex);
        }
        return result;
    }

    /**
     * Returns a vulnerability by it's name (i.e. CVE-2017-0001) and source.
     * @param source the source of the vulnerability
     * @param vulnId the name of the vulnerability
     * @return the matching Vulnerability object, or null if not found
     */
    public Vulnerability getVulnerabilityByVulnId(String source, String vulnId, boolean includeVulnerableSoftware) {
        final Query<Vulnerability> query = pm.newQuery(Vulnerability.class, "source == :source && vulnId == :vulnId");
        query.getFetchPlan().addGroup(Vulnerability.FetchGroup.COMPONENTS.name());
        if (includeVulnerableSoftware) {
            query.getFetchPlan().addGroup(Vulnerability.FetchGroup.VULNERABLE_SOFTWARE.name());
        }
        query.setRange(0, 1);
        final Vulnerability vulnerability = singleResult(query.execute(source, vulnId));
        if (vulnerability != null) {
            vulnerability.setAliases(getVulnerabilityAliases(vulnerability));
            vulnerability.setEpss(getEpssByCveId(vulnerability.getVulnId()));
        }
        return vulnerability;
    }

    /**
     * Returns a vulnerability by it's name (i.e. CVE-2017-0001) and source.
     * @param source the source of the vulnerability
     * @param vulnId the name of the vulnerability
     * @return the matching Vulnerability object, or null if not found
     */
    public Vulnerability getVulnerabilityByVulnId(Vulnerability.Source source, String vulnId, boolean includeVulnerableSoftware) {
        return getVulnerabilityByVulnId(source.name(), vulnId, includeVulnerableSoftware);
    }

    /**
     * Adds a vulnerability to a component.
     * @param vulnerability the vulnerability to add
     * @param component the component affected by the vulnerability
     * @param analyzerIdentity the identify of the analyzer
     */
    public void addVulnerability(
            Vulnerability vulnerability,
            Component component,
            String analyzerIdentity) {
        this.addVulnerability(vulnerability, component, analyzerIdentity, null, null, null);
    }

    /**
     * Adds a vulnerability to a component.
     * @param vulnerability the vulnerability to add
     * @param component the component affected by the vulnerability
     * @param analyzerIdentity the identify of the analyzer
     * @param alternateIdentifier the optional identifier if the analyzer refers to the vulnerability by an alternative identifier
     * @param referenceUrl the optional URL that references the occurrence of the vulnerability if uniquely identified
     */
    public void addVulnerability(
            Vulnerability vulnerability,
            Component component,
            String analyzerIdentity,
            String alternateIdentifier,
            String referenceUrl) {
        this.addVulnerability(vulnerability, component, analyzerIdentity, alternateIdentifier, referenceUrl, null);
    }

    /**
     * Adds a vulnerability to a component.
     * @param vulnerability the vulnerability to add
     * @param component the component affected by the vulnerability
     * @param analyzerIdentity the identify of the analyzer
     * @param alternateIdentifier the optional identifier if the analyzer refers to the vulnerability by an alternative identifier
     * @param referenceUrl the optional URL that references the occurrence of the vulnerability if uniquely identified
     * @param attributedOn the optional attribution date of the vulnerability. Used primarily when cloning projects, leave null when adding a new one.
     */
    public void addVulnerability(
            Vulnerability vulnerability,
            Component component,
            String analyzerIdentity,
            String alternateIdentifier,
            String referenceUrl,
            Date attributedOn) {
        runInTransaction(() -> {
            if (!contains(vulnerability, component)) {
                component.addVulnerability(vulnerability);
            }
            final boolean attributionExists = hasExistingAttribution(vulnerability, component, analyzerIdentity);
            if (!attributionExists) {
                final var findingAttribution = new FindingAttribution(
                        component, vulnerability, analyzerIdentity, alternateIdentifier, referenceUrl);
                if (attributedOn != null) {
                    findingAttribution.setAttributedOn(attributedOn);
                }
                persist(findingAttribution);
            }
        });
    }

    /**
     * Removes a vulnerability from a component.
     * @param vulnerability the vulnerabillity to remove
     * @param component the component unaffected by the vulnerabiity
     */
    public void removeVulnerability(Vulnerability vulnerability, Component component) {
        runInTransaction(() -> {
            if (contains(vulnerability, component)) {
                component.removeVulnerability(vulnerability);
            }

            final List<FindingAttribution> fa = getFindingAttributions(vulnerability, component);
            if (fa != null) {
                delete(fa);
            }
        });
    }

    /**
     * Returns a FindingAttribution object form a given vulnerability and component.
     * @param vulnerability the vulnerabillity of the finding attribution
     * @param component the component of the finding attribution
     * @return a FindingAttribution object
     */
    public List<FindingAttribution> getFindingAttributions(Vulnerability vulnerability, Component component) {
        final Query<FindingAttribution> query = pm.newQuery(
                FindingAttribution.class,
                "vulnerability == :vulnerability && component == :component");
        query.setParameters(vulnerability, component);
        return executeAndCloseList(query);
    }

    private boolean hasExistingAttribution(Vulnerability vulnerability, Component component, String analyzerIdentity) {
        final Query<?> query = pm.newQuery(Query.SQL, /* language=SQL */ """
                SELECT EXISTS(
                  SELECT 1
                    FROM "FINDINGATTRIBUTION"
                   WHERE "COMPONENT_ID" = ?
                     AND "VULNERABILITY_ID" = ?
                     AND "ANALYZERIDENTITY" = ?
                     AND "DELETED_AT" IS NULL
                )
                """);
        query.setParameters(component.getId(), vulnerability.getId(), analyzerIdentity);
        return executeAndCloseResultUnique(query, Boolean.class);
    }

    /**
     * Determines if a Component is affected by a specific Vulnerability by checking
     * {@link Vulnerability#getSource()} and {@link Vulnerability#getVulnId()}.
     * @param vulnerability The vulnerability to check if associated with component
     * @param component     The component to check against
     * @return true if vulnerability is associated with the component, false if not
     */
    public boolean contains(Vulnerability vulnerability, Component component) {
        final Query<?> query = pm.newQuery(Query.SQL, /* language=SQL */ """
                SELECT EXISTS(
                  SELECT 1
                    FROM "COMPONENTS_VULNERABILITIES"
                   WHERE "COMPONENT_ID" = ?
                     AND "VULNERABILITY_ID" = ?
                )
                """);
        query.setParameters(component.getId(), vulnerability.getId());
        return executeAndCloseResultUnique(query, Boolean.class);
    }

    /**
     * Returns a List of all Vulnerabilities.
     * @return a List of Vulnerability objects
     */
    public PaginatedResult getVulnerabilities() {
        PaginatedResult result;
        final Query<Vulnerability> query = pm.newQuery(Vulnerability.class);
        query.getFetchPlan().setGroup(Vulnerability.FetchGroup.BASIC.name());
        if (orderBy == null) {
            query.setOrdering("id asc");
        }
        if (filter != null) {
            query.setFilter("vulnId.toLowerCase().matches(:vulnId)");
            final String filterString = ".*" + filter.toLowerCase() + ".*";
            result = execute(query, filterString);
        } else {
            result = execute(query);
        }
        Map<String, Epss> matchedEpssList = getEpssForCveIds(
                result.getList(Vulnerability.class).stream().map(Vulnerability::getVulnId).distinct().toList());
        final Map<Long, AffectedProjectCountRow> affectedProjectCountRows = withJdbiHandle(
                this.request,
                jdbiHandle -> jdbiHandle.attach(VulnerabilityDao.class).getAffectedProjectCount(
                        result.getList(Vulnerability.class).stream().map(Vulnerability::getId).toList(),
                        /* includeSuppressed */ false)).stream()
                .collect(Collectors.toMap(AffectedProjectCountRow::id, Function.identity()));
        for (final Vulnerability vulnerability : result.getList(Vulnerability.class)) {
            final AffectedProjectCountRow affectedProjects = affectedProjectCountRows.get(vulnerability.getId());
            if (affectedProjects != null) {
                vulnerability.setAffectedProjectCount(affectedProjects.totalProjectCount());
                vulnerability.setAffectedActiveProjectCount(affectedProjects.activeProjectCount());
                vulnerability.setAffectedInactiveProjectCount(affectedProjects.totalProjectCount() - affectedProjects.activeProjectCount());
            }
            vulnerability.setAliases(getVulnerabilityAliases(vulnerability));
            vulnerability.setEpss(matchedEpssList.get(vulnerability.getVulnId()));
        }
        return result;
    }

    /**
     * Returns a List of Vulnerability for the specified Component and excludes suppressed vulnerabilities.
     * @param component the Component to retrieve vulnerabilities of
     * @return a List of Vulnerability objects
     */
    public PaginatedResult getVulnerabilities(Component component) {
        return getVulnerabilities(component, false);
    }

    /**
     * Returns a List of Vulnerability for the specified Component.
     * @param component the Component to retrieve vulnerabilities of
     * @return a List of Vulnerability objects
     */
    public PaginatedResult getVulnerabilities(Component component, boolean includeSuppressed) {
        List<Vulnerability> componentVulnerabilities;
        List<AffectedProjectCountRow> affectedProjectCounts;

        try (final Handle jdbiHandle = openJdbiHandle(this.request)) {
            final var dao = jdbiHandle.attach(VulnerabilityDao.class);
            componentVulnerabilities = dao.getVulnerabilitiesByComponent(component.getId(), includeSuppressed);
            affectedProjectCounts = dao.getAffectedProjectCount(
                    componentVulnerabilities.stream().map(Vulnerability::getId).toList(),
                    includeSuppressed);
        }
        Map<Long, Vulnerability> vulnById = componentVulnerabilities.stream().collect(Collectors.toMap(Vulnerability::getId, vulnerability -> vulnerability));
        for (var vulnerabilityProjectCount : affectedProjectCounts) {
            var vulnerability = vulnById.get(vulnerabilityProjectCount.id());
            vulnerability.setAffectedProjectCount(vulnerabilityProjectCount.totalProjectCount());
            vulnerability.setAffectedActiveProjectCount(vulnerabilityProjectCount.activeProjectCount());
            vulnerability.setAffectedInactiveProjectCount(vulnerabilityProjectCount.totalProjectCount() - vulnerabilityProjectCount.activeProjectCount());
        }
        return (new PaginatedResult()).objects(componentVulnerabilities).total(componentVulnerabilities.size());
    }

    /**
     * Returns a List of Vulnerability for the specified Component and excludes suppressed vulnerabilities.
     * This method if designed NOT to provide paginated results.
     * @param component the Component to retrieve vulnerabilities of
     * @return a List of Vulnerability objects
     */
    public List<Vulnerability> getAllVulnerabilities(Component component) {
        return getAllVulnerabilities(component, false);
    }

    /**
     * Returns a List of Vulnerability for the specified Component.
     * This method if designed NOT to provide paginated results.
     * @param component the Component to retrieve vulnerabilities of
     * @return a List of Vulnerability objects
     */
    @SuppressWarnings("unchecked")
    public List<Vulnerability> getAllVulnerabilities(Component component, boolean includeSuppressed) {
        final String filter = includeSuppressed ? "components.contains(:component)" : "components.contains(:component)" + generateExcludeSuppressed(component.getProject(), component);
        final Query<Vulnerability> query = pm.newQuery(Vulnerability.class, filter);
        final List<Vulnerability> vulnerabilities = (List<Vulnerability>)query.execute(component);
        Map<String, Epss> matchedEpssList = getEpssForCveIds(
                vulnerabilities.stream().map(vuln -> vuln.getVulnId()).distinct().toList());
        for (final Vulnerability vulnerability: vulnerabilities) {
            //vulnerability.setAffectedProjectCount(this.getProjects(vulnerability).size());
            vulnerability.setAliases(getVulnerabilityAliases(vulnerability));
            vulnerability.setEpss(matchedEpssList.get(vulnerability.getVulnId()));
        }
        return vulnerabilities;
    }

    /**
     * Returns a List of Components affected by a specific vulnerability.
     * This method if designed NOT to provide paginated results.
     * @param project the Project to limit retrieval from
     * @param vulnerability the vulnerability to query on
     * @return a List of Component objects
     */
    public List<Component> getAllVulnerableComponents(Project project, Vulnerability vulnerability, boolean includeSuppressed) {
        final List<Component> components = new ArrayList<>();
        for (final Component component: getAllComponents(project)) {
            final Collection<Vulnerability> componentVulns = pm.detachCopyAll(
                    getAllVulnerabilities(component, includeSuppressed)
            );
            for (final Vulnerability componentVuln: componentVulns) {
                if (componentVuln.getUuid() == vulnerability.getUuid()) {
                    components.add(component);
                }
            }
        }
        return components;
    }

    /**
     * Returns a List of Vulnerability for the specified Project.
     * This method is unique and used by third-party integrations
     * such as ThreadFix for the retrieval of vulnerabilities from
     * a specific project along with the affected component(s).
     * @param project the Project to retrieve vulnerabilities of
     * @return a List of Vulnerability objects
     */
    public List<Vulnerability> getVulnerabilities(Project project, boolean includeSuppressed) {
        List<Vulnerability> projectVulnerabilities;
        var vulnerableComponents = new HashMap<Long, Component>();
        try (final Handle jdbiHandle = openJdbiHandle((this.request))) {
            final var dao = jdbiHandle.attach(VulnerabilityDao.class);
            projectVulnerabilities = dao.getVulnerabilitiesByProject(project.getId(), includeSuppressed);
            dao.getVulnerableComponents(project.getId(), projectVulnerabilities.stream().map(Vulnerability::getId).toList())
                    .stream().forEach(vc -> vulnerableComponents.put(vc.getId(), vc));
        }
        for (var projectVulnerability : projectVulnerabilities) {
            if (projectVulnerability.getComponents() != null) {
                projectVulnerability.setComponents(
                        projectVulnerability.getComponents().stream().map(c -> vulnerableComponents.get(c.getId())).toList());
            }
        }
        return projectVulnerabilities;
    }

    /**
     * Generates partial JDOQL statement excluding suppressed vulnerabilities for this project/component
     * and for globally suppressed vulnerabilities against the specified component.
     * @param component the component to query on
     * @param project the project to query on
     * @return a partial where clause
     */
    @SuppressWarnings("unchecked")
    private String generateExcludeSuppressed(Project project, Component component) {
        // Retrieve a list of all suppressed vulnerabilities
        final Query<Analysis> analysisQuery = pm.newQuery(Analysis.class, "project == :project && component == :component && suppressed == true");
        final List<Analysis> analysisList = (List<Analysis>)analysisQuery.execute(project, component);
        // Construct exclude clause based on above results
        String excludeClause = analysisList.stream().map(analysis -> "id != " + analysis.getVulnerability().getId() + " && ").collect(Collectors.joining());
        if (StringUtils.trimToNull(excludeClause) != null) {
            excludeClause = " && (" + excludeClause.substring(0, excludeClause.lastIndexOf(" && ")) + ")";
        }
        return excludeClause;
    }

    public List<VulnerabilityAlias> getVulnerabilityAliases(Vulnerability vulnerability) {
        final Query<?> query = pm.newQuery(Query.SQL, /* language=SQL */ """
                SELECT CASE WHEN va."SOURCE" = 'NVD'      THEN va."VULN_ID" END AS "cveId"
                     , CASE WHEN va."SOURCE" = 'GITHUB'   THEN va."VULN_ID" END AS "ghsaId"
                     , CASE WHEN va."SOURCE" = 'GSD'      THEN va."VULN_ID" END AS "gsdId"
                     , CASE WHEN va."SOURCE" = 'INTERNAL' THEN va."VULN_ID" END AS "internalId"
                     , CASE WHEN va."SOURCE" = 'OSV'      THEN va."VULN_ID" END AS "osvId"
                     , CASE WHEN va."SOURCE" = 'OSSINDEX' THEN va."VULN_ID" END AS "sonatypeId"
                     , CASE WHEN va."SOURCE" = 'SNYK'     THEN va."VULN_ID" END AS "snykId"
                     , CASE WHEN va."SOURCE" = 'VULNDB'   THEN va."VULN_ID" END AS "vulnDbId"
                     , CASE WHEN va."SOURCE" = 'CSAF'     THEN va."VULN_ID" END AS "csafId"
                  FROM "VULNERABILITY_ALIAS" AS va
                 WHERE va."GROUP_ID" IN (
                    SELECT "GROUP_ID"
                      FROM "VULNERABILITY_ALIAS" AS va2
                     WHERE va2."SOURCE" = :source
                       AND va2."VULN_ID" = :vulnId
                 )
                   AND NOT (va."SOURCE" = :source AND va."VULN_ID" = :vulnId)
                """);
        query.setNamedParameters(Map.ofEntries(
                Map.entry("source", vulnerability.getSource()),
                Map.entry("vulnId", vulnerability.getVulnId())));
        return query.executeResultList(VulnerabilityAlias.class);
    }

    /**
     * Fetch a {@link AffectedVersionAttribution} associated with a given
     * {@link Vulnerability}-{@link VulnerableSoftware} relationship.
     *
     * @param vulnerableSoftware the vulnerable software of the affected version attribution
     * @return a AffectedVersionAttribution object
     * @since 4.7.0
     */
    @Override
    public AffectedVersionAttribution getAffectedVersionAttribution(final Vulnerability vulnerability,
                                                                    final VulnerableSoftware vulnerableSoftware,
                                                                    final Vulnerability.Source source) {
        final Query<AffectedVersionAttribution> query = pm.newQuery(AffectedVersionAttribution.class, """
                vulnerability == :vulnerability && vulnerableSoftware == :vulnerableSoftware && source == :source
                """);
        query.setParameters(vulnerability, vulnerableSoftware, source);
        query.setRange(0, 1);
        return query.executeUnique();
    }

    /**
     * Fetch all {@link AffectedVersionAttribution}s associated with a given
     * {@link Vulnerability}-{@link VulnerableSoftware} relationship.
     *
     * @param vulnerability      The {@link Vulnerability} to fetch attributions for
     * @param vulnerableSoftware The {@link VulnerableSoftware} to fetch attributions for
     * @return A {@link List} of {@link AffectedVersionAttribution}s
     * @since 4.7.0
     */
    @Override
    public List<AffectedVersionAttribution> getAffectedVersionAttributions(final Vulnerability vulnerability,
                                                                           final VulnerableSoftware vulnerableSoftware) {
        final Query<AffectedVersionAttribution> query = pm.newQuery(AffectedVersionAttribution.class, """
                vulnerability == :vulnerability && vulnerableSoftware == :vulnerableSoftware
                """);
        query.setParameters(vulnerability, vulnerableSoftware);
        return query.executeList();
    }

    /**
     * Fetch all {@link AffectedVersionAttribution}s associated with a given {@link Vulnerability},
     * and any of the given {@link VulnerableSoftware}s.
     *
     * @param vulnerability       The {@link Vulnerability} to fetch attributions for
     * @param vulnerableSoftwares he {@link VulnerableSoftware}s to fetch attributions for
     * @return A {@link List} of {@link AffectedVersionAttribution}s
     * @since 4.10.0
     */
    @Override
    public List<AffectedVersionAttribution> getAffectedVersionAttributions(
            final Vulnerability vulnerability,
            final List<VulnerableSoftware> vulnerableSoftwares) {
        final Query<AffectedVersionAttribution> query = pm.newQuery(AffectedVersionAttribution.class);
        query.setFilter("vulnerability.id == :vulnId && :vsIdList.contains(vulnerableSoftware.id)");
        query.setNamedParameters(Map.of(
                "vulnId", vulnerability.getId(),
                "vsIdList", vulnerableSoftwares.stream().map(VulnerableSoftware::getId).toList()
        ));
        return executeAndCloseList(query);
    }

    /**
     * Delete all {@link AffectedVersionAttribution}s for a given {@link Vulnerability.Source},
     * that are associated with a given {@link Vulnerability}, and <em>any</em> of the given {@link VulnerableSoftware}s.
     *
     * @param vulnerability       The {@link Vulnerability} to delete attributions for
     * @param vulnerableSoftwares The {@link VulnerableSoftware}s to delete attributions for
     * @param source              The {@link Vulnerability.Source} to delete attributions for
     * @since 4.10.0
     */
    @Override
    public void deleteAffectedVersionAttributions(
            final Vulnerability vulnerability,
            final List<VulnerableSoftware> vulnerableSoftwares,
            final Vulnerability.Source source) {
        final Query<AffectedVersionAttribution> deleteAttributionQuery = pm.newQuery(AffectedVersionAttribution.class);
        deleteAttributionQuery.setFilter(":vsListToRemove.contains(vulnerableSoftware) && vulnerability == :vuln && source == :source");
        deleteAttributionQuery.setNamedParameters(Map.of(
                "vsListToRemove", vulnerableSoftwares,
                "vuln", vulnerability,
                "source", source));
        try {
            deleteAttributionQuery.deletePersistentAll();
        } finally {
            deleteAttributionQuery.closeAll();
        }
    }

    /**
     * Delete a {@link AffectedVersionAttribution}.
     *
     * @param vulnerability      The {@link Vulnerability} to delete the attribution for
     * @param vulnerableSoftware The {@link VulnerableSoftware} to delete the attribution for
     * @param source             The {@link Vulnerability.Source} to delete the attribution for
     * @since 4.7.0
     */
    @Override
    public void deleteAffectedVersionAttribution(final Vulnerability vulnerability,
                                                 final VulnerableSoftware vulnerableSoftware,
                                                 final Vulnerability.Source source) {
        final Query<AffectedVersionAttribution> query = pm.newQuery(AffectedVersionAttribution.class);
        query.setFilter("""
                vulnerability == :vulnerability
                && vulnerableSoftware == :vulnerableSoftware
                && source == :source
                """);
        query.setParameters(vulnerability, vulnerableSoftware, source);
        query.deletePersistentAll();
    }

    /**
     * Check if any {@link AffectedVersionAttribution} exists for a given {@link Vulnerability}-{@link VulnerableSoftware} relationship.
     *
     * @param vulnerability      The {@link Vulnerability} to check for
     * @param vulnerableSoftware The {@link VulnerableSoftware} to check for
     * @param source             The {@link Vulnerability.Source} to check for
     * @return {@code true} when an attribution exists, otherwise {@code false}
     * @since 4.10.0
     */
    @Override
    public boolean hasAffectedVersionAttribution(
            final Vulnerability vulnerability,
            final VulnerableSoftware vulnerableSoftware,
            final Vulnerability.Source source) {
        final Query<AffectedVersionAttribution> query = pm.newQuery(AffectedVersionAttribution.class);
        query.setFilter("source == :source && vulnerability == :vuln && vulnerableSoftware == :vs");
        query.setNamedParameters(Map.of(
                "source", source,
                "vuln", vulnerability,
                "vs", vulnerableSoftware));
        query.setResult("count(this)");
        return executeAndCloseResultUnique(query, Long.class) > 0;
    }

    /**
     * @since 5.6.0
     */
    @Override
    public boolean bind(final Vulnerability vuln, final Collection<Tag> tags, final boolean keepExisting) {
        assertPersistent(vuln, "vuln must be persistent");
        assertPersistentAll(tags, "tags must be persistent");

        return callInTransaction(() -> {
            boolean modified = false;

            if (!keepExisting) {
                final Iterator<Tag> existingTagsIterator = vuln.getTags().iterator();
                while (existingTagsIterator.hasNext()) {
                    final Tag existingTag = existingTagsIterator.next();
                    if (!tags.contains(existingTag)) {
                        existingTagsIterator.remove();
                        existingTag.getVulnerabilities().remove(vuln);
                        modified = true;
                    }
                }
            }
            for (final Tag tag : tags) {
                if (!vuln.getTags().contains(tag)) {
                    vuln.getTags().add(tag);

                    if (tag.getVulnerabilities() == null) {
                        tag.setVulnerabilities(new HashSet<>(Set.of(vuln)));
                    } else {
                        tag.getVulnerabilities().add(vuln);
                    }

                    modified = true;
                }
            }
            return modified;
        });
    }

    /**
     * Binds the two objects together in a corresponding join table.
     *
     * @param vulnerability a Vulnerability object
     * @param tags    a List of Tag objects
     */
    public void bind(Vulnerability vulnerability, Collection<Tag> tags) {
        bind(vulnerability, tags, /* keepExisting */ false);
    }

    /**
     * Returns a paginated result of vulnerabilities by tag.
     *
     * @param tag the tag associated with the Vulnerability
     * @return a List of vulnerabilities that contain the tag
     */
    public PaginatedResult getVulnerabilities(final Tag tag) {
        final Query<Vulnerability> query = pm.newQuery(Vulnerability.class);
        if (orderBy == null) {
            query.setOrdering("vulnId asc, id asc");
        }
        query.setFilter("(tags.contains(:tag))");
        Map<String, Object> params = new HashMap<>();
        params.put("tag", tag);
        return execute(query, params);
    }
}
