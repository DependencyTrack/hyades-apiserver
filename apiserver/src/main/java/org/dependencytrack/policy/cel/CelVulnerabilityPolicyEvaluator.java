/*
 * This file is part of Dependency-Track.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 * Copyright (c) OWASP Foundation. All Rights Reserved.
 */
package org.dependencytrack.policy.cel;

import alpine.common.logging.Logger;
import alpine.common.metrics.Metrics;
import alpine.server.cache.AbstractCacheManager;
import alpine.server.cache.CacheManager;
import com.google.api.expr.v1alpha1.Type;
import com.google.protobuf.Timestamp;
import com.google.protobuf.util.Timestamps;
import io.micrometer.core.instrument.Timer;
import org.apache.commons.codec.digest.DigestUtils;
import org.apache.commons.collections4.MultiValuedMap;
import org.apache.commons.collections4.multimap.HashSetValuedHashMap;
import org.dependencytrack.policy.cel.persistence.CelPolicyDao;
import org.dependencytrack.policy.vulnerability.VulnerabilityPolicy;
import org.dependencytrack.policy.vulnerability.VulnerabilityPolicyEvaluator;
import org.dependencytrack.policy.vulnerability.VulnerabilityPolicyProvider;
import org.dependencytrack.proto.policy.v1.Component;
import org.dependencytrack.proto.policy.v1.Project;
import org.dependencytrack.proto.policy.v1.Vulnerability;
import org.projectnessie.cel.tools.ScriptCreateException;
import org.projectnessie.cel.tools.ScriptExecutionException;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.ServiceLoader;
import java.util.UUID;
import java.util.function.Function;
import java.util.stream.Collectors;

import static java.util.Objects.requireNonNull;
import static org.dependencytrack.persistence.jdbi.JdbiFactory.withJdbiHandle;
import static org.dependencytrack.policy.cel.definition.CelPolicyTypes.TYPE_COMPONENT;
import static org.dependencytrack.policy.cel.definition.CelPolicyTypes.TYPE_LICENSE;
import static org.dependencytrack.policy.cel.definition.CelPolicyTypes.TYPE_LICENSE_GROUP;
import static org.dependencytrack.policy.cel.definition.CelPolicyTypes.TYPE_PROJECT;
import static org.dependencytrack.policy.cel.definition.CelPolicyTypes.TYPE_PROJECT_METADATA;
import static org.dependencytrack.policy.cel.definition.CelPolicyTypes.TYPE_PROJECT_PROPERTY;
import static org.dependencytrack.policy.cel.definition.CelPolicyTypes.TYPE_VULNERABILITY;

/**
 * A {@link VulnerabilityPolicyEvaluator} capable of evaluating conditions as CEL expressions.
 */
public class CelVulnerabilityPolicyEvaluator implements VulnerabilityPolicyEvaluator {

    private static final Logger LOGGER = Logger.getLogger(CelVulnerabilityPolicyEvaluator.class);

    private final VulnerabilityPolicyProvider policyProvider;
    private final CelPolicyScriptHost scriptHost;
    private final AbstractCacheManager cacheManager;

    @SuppressWarnings("unused") // Called by ServiceLoader
    public CelVulnerabilityPolicyEvaluator() {
        this(ServiceLoader.load(VulnerabilityPolicyProvider.class).findFirst().orElseThrow(),
                CelPolicyScriptHost.getInstance(CelPolicyType.VULNERABILITY), CacheManager.getInstance());
    }

    public CelVulnerabilityPolicyEvaluator(final VulnerabilityPolicyProvider policyProvider,
                                           final CelPolicyScriptHost scriptHost, final AbstractCacheManager cacheManager) {
        this.policyProvider = policyProvider;
        this.scriptHost = scriptHost;
        this.cacheManager = cacheManager;

        // FIXME: Caches are not initialized until the first entry is added...
        cacheManager.put("%s-init".formatted(getClass().getSimpleName()), Project.getDefaultInstance());
        cacheManager.put("%s-init".formatted(getClass().getSimpleName()), Component.getDefaultInstance());
    }

    @Override
    public Map<UUID, VulnerabilityPolicy> evaluate(final Collection<Vulnerability> vulns, final Component component, final Project project) {
        final Timer.Sample timerSample = Timer.start();
        try {
            return evaluateInternal(vulns, component, project);
        } finally {
            timerSample.stop(Timer
                    .builder("vuln_policy_evaluation")
                    .register(Metrics.getRegistry()));
        }
    }

    private Map<UUID, VulnerabilityPolicy> evaluateInternal(final Collection<Vulnerability> vulns, final Component component, final Project project) {
        requireNonNull(project, "project must not be null");
        requireNonNull(component, "component must not be null");
        requireNonNull(vulns, "vulns must not be null");

        // UUIDs are the bare minimum, everything else can be loaded if required.
        if (project.getUuid().isBlank()) {
            throw new IllegalArgumentException("project must have a UUID");
        }
        if (component.getUuid().isBlank()) {
            throw new IllegalArgumentException("component must have a UUID");
        }
        for (final Vulnerability vuln : vulns) {
            if (vuln.getUuid().isBlank()) {
                throw new IllegalArgumentException("vulns must have a UUID");
            }
        }

        if (vulns.isEmpty()) {
            LOGGER.debug("No vulnerabilities to evaluate policies for");
            return Collections.emptyMap();
        }

        // TODO: Can this be cached? Would be good to avoid having to do a DB query for each component.
        //   Alternatively, we can consider caching an implementation detail of the respective provider.
        final List<VulnerabilityPolicy> applicablePolicies = policyProvider.getApplicablePolicies(project);
        if (applicablePolicies == null || applicablePolicies.isEmpty()) {
            LOGGER.debug("No applicable policies found");
            return Collections.emptyMap();
        }

        // Compile condition scripts and group them by policy name.
        // Using LinkedHashMap to preserve the order of the policies.
        final var compiledScriptsByPolicyName = new LinkedHashMap<String, List<CelPolicyScript>>();
        for (final VulnerabilityPolicy policy : applicablePolicies) {
            for (final String condition : policy.getConditions()) {
                compiledScriptsByPolicyName.compute(policy.getName(), (policyName, compiledScripts) -> {
                    final CelPolicyScript compiledScript = compileConditionScript(condition);
                    if (compiledScript == null) {
                        return compiledScripts;
                    }
                    if (compiledScripts == null) {
                        final var scripts = new ArrayList<CelPolicyScript>();
                        scripts.add(compiledScript);
                        return scripts;
                    } else {
                        compiledScripts.add(compiledScript);
                        return compiledScripts;
                    }
                });
            }
        }

        // Determine requirements across all condition scripts.
        final MultiValuedMap<Type, String> scriptRequirements = compiledScriptsByPolicyName.values().stream()
                .flatMap(Collection::stream)
                .map(CelPolicyScript::getRequirements)
                .reduce(new HashSetValuedHashMap<>(), (lhs, rhs) -> {
                    lhs.putAll(rhs);
                    return lhs;
                });

        final Project scriptArgProject;
        if (scriptRequirements.containsKey(TYPE_PROJECT)) {
            scriptArgProject = ensureRequirementsLoaded(project, scriptRequirements);
        } else {
            scriptArgProject = org.dependencytrack.proto.policy.v1.Project.getDefaultInstance();
        }

        final Component scriptArgComponent;
        if (scriptRequirements.containsKey(TYPE_COMPONENT)) {
            scriptArgComponent = ensureRequirementsLoaded(component, scriptRequirements);
        } else {
            scriptArgComponent = org.dependencytrack.proto.policy.v1.Component.getDefaultInstance();
        }

        final Map<String, Vulnerability> scriptArgVulns;
        if (scriptRequirements.containsKey(TYPE_VULNERABILITY)) {
            scriptArgVulns = ensureRequirementsLoaded(vulns, scriptRequirements);
        } else {
            scriptArgVulns = vulns.stream()
                    .map(vuln -> Map.entry(vuln.getUuid(), vuln))
                    .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));
        }

        // Index policies by their (unique) name to make lookups easier.
        final Map<String, VulnerabilityPolicy> policiesByName = applicablePolicies.stream()
                .collect(Collectors.toMap(VulnerabilityPolicy::getName, Function.identity()));

        // Iterate over all policies IN THE ORDER THEY WERE GIVEN TO US, evaluating their conditions
        // IN THE ORDER THEY WERE GIVEN TO US.
        // TODO: Clean this up; Those nested for loops are hideous.
        final var matchedPolicies = new HashMap<UUID, VulnerabilityPolicy>();
        final Timestamp protoNow = Timestamps.now(); // Use consistent now timestamp for all evaluations.
        for (final Vulnerability protoVuln : scriptArgVulns.values()) {
            final var shortCircuitedPolicies = new HashSet<String>();

            policyLoop:
            for (final Map.Entry<String, List<CelPolicyScript>> policyNameAndScripts : compiledScriptsByPolicyName.entrySet()) {
                if (shortCircuitedPolicies.contains(policyNameAndScripts.getKey())) {
                    LOGGER.debug("Policy %s already short-circuited");
                    continue;
                }

                for (final CelPolicyScript script : policyNameAndScripts.getValue()) {
                    final Map<String, Object> scriptArguments = Map.ofEntries(
                            Map.entry(CelPolicyVariable.COMPONENT.variableName(), scriptArgComponent),
                            Map.entry(CelPolicyVariable.PROJECT.variableName(), scriptArgProject),
                            Map.entry(CelPolicyVariable.VULN.variableName(), protoVuln),
                            Map.entry(CelPolicyVariable.NOW.variableName(), protoNow)
                    );
                    try {
                        final boolean conditionMatched = script.execute(scriptArguments);
                        if (conditionMatched && policyNameAndScripts.getValue().lastIndexOf(script) == policyNameAndScripts.getValue().size() - 1) {
                            matchedPolicies.put(UUID.fromString(protoVuln.getUuid()), policiesByName.get(policyNameAndScripts.getKey()));

                            // We already matched a policy; We're done for this vulnerability.
                            break policyLoop;
                        } else if (!conditionMatched) {
                            // If we have any other policies in the pipeline with the EXACT same condition in them,
                            // mark them as short-circuited; They'll not yield a match.
                            // TODO: This should be more efficient
                            for (final Map.Entry<String, List<CelPolicyScript>> otherPolicyNameAndScripts : compiledScriptsByPolicyName.entrySet()) {
                                if (!otherPolicyNameAndScripts.getKey().equals(policyNameAndScripts.getKey()) && otherPolicyNameAndScripts.getValue().contains(script)) {
                                    LOGGER.debug("Short-circuiting policy %s".formatted(otherPolicyNameAndScripts.getKey()));
                                    shortCircuitedPolicies.add(otherPolicyNameAndScripts.getKey());
                                }
                            }

                            // Move on to the next policy in the pipeline.
                            continue policyLoop;
                        }
                    } catch (ScriptExecutionException e) {
                        // TODO: Add emergency latch to disable policies that reached a certain failure threshold?
                        //  If a condition execution fails, it's unlikely to recover magically.
                        LOGGER.warn("Failed to execute script for condition #%d of policy %s with arguments %s"
                                .formatted(policyNameAndScripts.getValue().indexOf(script), policyNameAndScripts.getKey(), scriptArguments), e);
                        break policyLoop; // This policy can not succeed anymore; Move on to the next.
                    }
                }
            }
        }

        return matchedPolicies;
    }

    private Project ensureRequirementsLoaded(final Project project, final MultiValuedMap<Type, String> requirements) {
        return cacheManager.get(Project.class, buildCacheKey(project, requirements), cacheKey ->
                withJdbiHandle(handle -> handle.attach(CelPolicyDao.class).loadRequiredFields(project, requirements))
        );
    }

    private Component ensureRequirementsLoaded(final Component component, final MultiValuedMap<Type, String> requirements) {
        return cacheManager.get(Component.class, buildCacheKey(component, requirements), cacheKey ->
                withJdbiHandle(handle -> handle.attach(CelPolicyDao.class).loadRequiredFields(component, requirements))
        );
    }

    private Map<String, Vulnerability> ensureRequirementsLoaded(final Collection<Vulnerability> vulns,
                                                                final MultiValuedMap<Type, String> requirements) {
        return vulns.stream()
                .map(vuln -> Map.entry(vuln.getUuid(), ensureRequirementsLoaded(vuln, requirements)))
                .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));
    }

    private Vulnerability ensureRequirementsLoaded(final Vulnerability vuln, final MultiValuedMap<Type, String> requirements) {
        // Vulnerabilities are not currently cached, as we expect them to change more or less frequently
        // when processing vulnerability scan results. For external vulnerability sources like OSS Index
        // or Snyk, processing scan results is the only way we get to know about vulnerability updates.
        //
        // Luckily, for the same reason as above, the Vulnerability objects passed to this method will be
        // already pre-populated in those cases, so in the best case no additional feels need to be loaded anyway.
        return withJdbiHandle(handle -> handle.attach(CelPolicyDao.class).loadRequiredFields(vuln, requirements));
    }

    private CelPolicyScript compileConditionScript(final String conditionScriptSrc) {
        try {
            return scriptHost.compile(conditionScriptSrc, CelPolicyScriptHost.CacheMode.CACHE);
        } catch (ScriptCreateException e) {
            LOGGER.warn("Failed to compile script %s; Condition will be skipped"
                    .formatted(conditionScriptSrc), e);
            return null;
        }
    }

    private static String buildCacheKey(final Project project, final MultiValuedMap<Type, String> requirements) {
        final var cacheKeyParts = new ArrayList<>(requirements.get(TYPE_PROJECT));
        if (cacheKeyParts.contains("properties") && requirements.containsKey(TYPE_PROJECT_PROPERTY)) {
            for (final String propertyFieldName : requirements.get(TYPE_PROJECT_PROPERTY)) {
                cacheKeyParts.add("property.%s".formatted(propertyFieldName));
            }
        }
        if (cacheKeyParts.contains("metadata") && requirements.containsKey(TYPE_PROJECT_METADATA)) {
            for (final String metadataFieldName : requirements.get(TYPE_PROJECT_METADATA)) {
                cacheKeyParts.add("metadata.%s".formatted(metadataFieldName));
            }
        }

        final String rawCacheKey = "%s|%s"
                .formatted(project.getUuid(), cacheKeyParts.stream().sorted().collect(Collectors.joining("|")));
        return DigestUtils.sha256Hex(rawCacheKey);
    }

    private static String buildCacheKey(final Component component, final MultiValuedMap<Type, String> requirements) {
        final var cacheKeyParts = new ArrayList<>(requirements.get(TYPE_COMPONENT));
        if (cacheKeyParts.contains("resolved_license") && requirements.containsKey(TYPE_LICENSE)) {
            for (final String licenseFieldName : requirements.get(TYPE_LICENSE)) {
                cacheKeyParts.add("license.%s".formatted(licenseFieldName));
            }

            if (requirements.get(TYPE_LICENSE).contains("groups") && requirements.containsKey(TYPE_LICENSE_GROUP)) {
                for (final String licenseGroupFieldName : requirements.get(TYPE_LICENSE_GROUP)) {
                    cacheKeyParts.add("license_group.%s".formatted(licenseGroupFieldName));
                }
            }
        }

        final String rawCacheKey = "%s|%s"
                .formatted(component.getUuid(), cacheKeyParts.stream().sorted().collect(Collectors.joining("|")));
        return DigestUtils.sha256Hex(rawCacheKey);
    }

}
