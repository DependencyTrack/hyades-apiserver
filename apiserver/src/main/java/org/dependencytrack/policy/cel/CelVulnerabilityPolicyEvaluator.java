/*
 * This file is part of Dependency-Track.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 * Copyright (c) OWASP Foundation. All Rights Reserved.
 */
package org.dependencytrack.policy.cel;

import alpine.common.logging.Logger;
import com.google.api.expr.v1alpha1.Type;
import com.google.protobuf.Timestamp;
import com.google.protobuf.util.Timestamps;
import io.micrometer.core.instrument.Metrics;
import io.micrometer.core.instrument.Timer;
import org.apache.commons.collections4.MultiValuedMap;
import org.apache.commons.collections4.multimap.HashSetValuedHashMap;
import org.dependencytrack.persistence.jdbi.VulnerabilityPolicyDao;
import org.dependencytrack.policy.cel.persistence.CelPolicyDao;
import org.dependencytrack.policy.vulnerability.VulnerabilityPolicy;
import org.dependencytrack.policy.vulnerability.VulnerabilityPolicyEvaluator;
import org.dependencytrack.proto.policy.v1.Component;
import org.dependencytrack.proto.policy.v1.Project;
import org.dependencytrack.proto.policy.v1.Vulnerability;
import org.projectnessie.cel.tools.ScriptCreateException;
import org.projectnessie.cel.tools.ScriptExecutionException;

import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.function.Function;
import java.util.stream.Collectors;

import static java.util.Objects.requireNonNull;
import static org.dependencytrack.persistence.jdbi.JdbiFactory.withJdbiHandle;
import static org.dependencytrack.policy.cel.definition.CelPolicyTypes.TYPE_COMPONENT;
import static org.dependencytrack.policy.cel.definition.CelPolicyTypes.TYPE_PROJECT;
import static org.dependencytrack.policy.cel.definition.CelPolicyTypes.TYPE_VULNERABILITY;

/**
 * A {@link VulnerabilityPolicyEvaluator} capable of evaluating conditions as CEL expressions.
 */
public class CelVulnerabilityPolicyEvaluator implements VulnerabilityPolicyEvaluator {

    private static final Logger LOGGER = Logger.getLogger(CelVulnerabilityPolicyEvaluator.class);

    private final CelPolicyScriptHost scriptHost;

    @SuppressWarnings("unused") // Called by ServiceLoader
    public CelVulnerabilityPolicyEvaluator() {
        this(CelPolicyScriptHost.getInstance(CelPolicyType.VULNERABILITY));
    }

    public CelVulnerabilityPolicyEvaluator(final CelPolicyScriptHost scriptHost) {
        this.scriptHost = scriptHost;
    }

    @Override
    public Map<Long, Map<Long, VulnerabilityPolicy>> evaluateAll(
            long projectId,
            Map<Long, Set<Long>> vulnIdsByComponentId) {
        final Timer.Sample timerSample = Timer.start();
        try {
            return evaluateAllInternal(projectId, vulnIdsByComponentId);
        } finally {
            timerSample.stop(Timer
                    .builder("vuln_policy_evaluation")
                    .register(Metrics.globalRegistry));
        }
    }

    private Map<Long, Map<Long, VulnerabilityPolicy>> evaluateAllInternal(
            final long projectId,
            final Map<Long, Set<Long>> vulnIdsByComponentId) {
        requireNonNull(vulnIdsByComponentId, "vulnIdsByComponentId must not be null");

        if (vulnIdsByComponentId.isEmpty()) {
            LOGGER.debug("No components to evaluate policies for");
            return Map.of();
        }

        final List<VulnerabilityPolicy> applicablePolicies = withJdbiHandle(handle ->
                handle.attach(VulnerabilityPolicyDao.class).getAllEnabledAndValid());
        if (applicablePolicies == null || applicablePolicies.isEmpty()) {
            LOGGER.debug("No applicable policies found");
            return Map.of();
        }

        // Compile condition scripts and group them by policy name.
        // Using LinkedHashMap to preserve the order of the policies.
        final var compiledScriptsByPolicyName = new LinkedHashMap<String, List<CelPolicyScript>>();
        for (final VulnerabilityPolicy policy : applicablePolicies) {
            for (final String condition : policy.getConditions()) {
                compiledScriptsByPolicyName.compute(policy.getName(), (policyName, compiledScripts) -> {
                    final CelPolicyScript compiledScript = compileConditionScript(condition);
                    if (compiledScript == null) {
                        return compiledScripts;
                    }
                    if (compiledScripts == null) {
                        final var scripts = new ArrayList<CelPolicyScript>();
                        scripts.add(compiledScript);
                        return scripts;
                    } else {
                        compiledScripts.add(compiledScript);
                        return compiledScripts;
                    }
                });
            }
        }

        if (compiledScriptsByPolicyName.isEmpty()) {
            return Map.of();
        }

        // Determine requirements across all condition scripts.
        final MultiValuedMap<Type, String> scriptRequirements = compiledScriptsByPolicyName.values().stream()
                .flatMap(Collection::stream)
                .map(CelPolicyScript::getRequirements)
                .reduce(new HashSetValuedHashMap<>(), (lhs, rhs) -> {
                    lhs.putAll(rhs);
                    return lhs;
                });

        // Load required project data.
        final Project scriptArgProject;
        if (scriptRequirements.containsKey(TYPE_PROJECT)) {
            scriptArgProject = withJdbiHandle(handle ->
                    handle.attach(CelPolicyDao.class).loadRequiredFields(projectId, scriptRequirements));
        } else {
            scriptArgProject = Project.getDefaultInstance();
        }

        // Load required component data.
        final Map<Long, Component> loadedComponentsById;
        if (scriptRequirements.containsKey(TYPE_COMPONENT)) {
            loadedComponentsById = withJdbiHandle(handle ->
                    handle.attach(CelPolicyDao.class).loadRequiredComponentFields(
                            vulnIdsByComponentId.keySet(), scriptRequirements));
        } else {
            loadedComponentsById = vulnIdsByComponentId.keySet().stream()
                    .collect(Collectors.toMap(
                            Function.identity(),
                            ignored -> Component.getDefaultInstance()));
        }

        // Load required vulnerability data.
        final Set<Long> uniqueVulnIds =
                vulnIdsByComponentId.values().stream()
                        .flatMap(Collection::stream)
                        .collect(Collectors.toSet());
        final Map<Long, Vulnerability> loadedVulnsById;
        if (scriptRequirements.containsKey(TYPE_VULNERABILITY)) {
            loadedVulnsById = withJdbiHandle(handle ->
                    handle.attach(CelPolicyDao.class).loadRequiredVulnerabilityFields(
                            uniqueVulnIds, scriptRequirements));
        } else {
            loadedVulnsById = uniqueVulnIds.stream()
                    .collect(Collectors.toMap(
                            Function.identity(),
                            ignored -> Vulnerability.getDefaultInstance()));
        }

        final Map<String, VulnerabilityPolicy> policiesByName =
                applicablePolicies.stream()
                        .collect(Collectors.toMap(
                                VulnerabilityPolicy::getName,
                                Function.identity()));

        final var results = new HashMap<Long, Map<Long, VulnerabilityPolicy>>();
        final Timestamp protoNow = Timestamps.now();

        for (final var entry : vulnIdsByComponentId.entrySet()) {
            final long componentId = entry.getKey();
            final Collection<Long> vulnIds = entry.getValue();
            if (vulnIds.isEmpty()) {
                continue;
            }

            final Component scriptArgComponent = loadedComponentsById.getOrDefault(
                    componentId, Component.getDefaultInstance());

            final Map<Long, VulnerabilityPolicy> componentResults = evaluateForComponent(
                    vulnIds,
                    scriptArgComponent,
                    scriptArgProject,
                    loadedVulnsById,
                    compiledScriptsByPolicyName,
                    policiesByName,
                    protoNow);

            if (!componentResults.isEmpty()) {
                results.put(componentId, componentResults);
            }
        }

        return results;
    }

    private static Map<Long, VulnerabilityPolicy> evaluateForComponent(
            Collection<Long> vulnIds,
            Component scriptArgComponent,
            Project scriptArgProject,
            Map<Long, Vulnerability> loadedVulnsById,
            LinkedHashMap<String, List<CelPolicyScript>> compiledScriptsByPolicyName,
            Map<String, VulnerabilityPolicy> policiesByName,
            Timestamp protoNow) {
        final var matchedPolicies = new HashMap<Long, VulnerabilityPolicy>();

        for (final long vulnId : vulnIds) {
            final Vulnerability protoVuln = loadedVulnsById.getOrDefault(
                    vulnId, Vulnerability.getDefaultInstance());
            final var shortCircuitedPolicies = new HashSet<String>();

            policyLoop:
            for (final var policyNameAndScripts : compiledScriptsByPolicyName.entrySet()) {
                if (shortCircuitedPolicies.contains(policyNameAndScripts.getKey())) {
                    LOGGER.debug("Policy %s already short-circuited".formatted(policyNameAndScripts.getKey()));
                    continue;
                }

                for (final CelPolicyScript script : policyNameAndScripts.getValue()) {
                    final Map<String, Object> scriptArguments = Map.ofEntries(
                            Map.entry(CelPolicyVariable.COMPONENT.variableName(), scriptArgComponent),
                            Map.entry(CelPolicyVariable.PROJECT.variableName(), scriptArgProject),
                            Map.entry(CelPolicyVariable.VULN.variableName(), protoVuln),
                            Map.entry(CelPolicyVariable.NOW.variableName(), protoNow)
                    );
                    try {
                        final boolean conditionMatched = script.execute(scriptArguments);
                        if (conditionMatched && policyNameAndScripts.getValue().lastIndexOf(script) == policyNameAndScripts.getValue().size() - 1) {
                            matchedPolicies.put(vulnId, policiesByName.get(policyNameAndScripts.getKey()));
                            break policyLoop;
                        } else if (!conditionMatched) {
                            for (final Map.Entry<String, List<CelPolicyScript>> otherPolicyNameAndScripts : compiledScriptsByPolicyName.entrySet()) {
                                if (!otherPolicyNameAndScripts.getKey().equals(policyNameAndScripts.getKey()) && otherPolicyNameAndScripts.getValue().contains(script)) {
                                    LOGGER.debug("Short-circuiting policy %s".formatted(otherPolicyNameAndScripts.getKey()));
                                    shortCircuitedPolicies.add(otherPolicyNameAndScripts.getKey());
                                }
                            }
                            continue policyLoop;
                        }
                    } catch (ScriptExecutionException e) {
                        LOGGER.warn("Failed to execute script for condition #%d of policy %s with arguments %s"
                                .formatted(policyNameAndScripts.getValue().indexOf(script), policyNameAndScripts.getKey(), scriptArguments), e);
                        break policyLoop;
                    }
                }
            }
        }

        return matchedPolicies;
    }

    private CelPolicyScript compileConditionScript(final String conditionScriptSrc) {
        try {
            return scriptHost.compile(conditionScriptSrc, CelPolicyScriptHost.CacheMode.CACHE);
        } catch (ScriptCreateException e) {
            LOGGER.warn("Failed to compile script %s; Condition will be skipped"
                    .formatted(conditionScriptSrc), e);
            return null;
        }
    }

}
