package org.dependencytrack.tasks.vulnerabilitypolicy;

import com.github.tomakehurst.wiremock.client.WireMock;
import com.github.tomakehurst.wiremock.junit.WireMockRule;
import org.apache.http.HttpStatus;
import org.dependencytrack.AbstractPostgresEnabledTest;
import org.dependencytrack.model.ConfigPropertyConstants;
import org.junit.After;
import org.junit.Before;
import org.junit.Rule;
import org.junit.Test;
import org.junit.contrib.java.lang.system.EnvironmentVariables;

import java.io.IOException;
import java.nio.file.Paths;

import static com.github.tomakehurst.wiremock.core.WireMockConfiguration.options;
import static org.assertj.core.api.Assertions.assertThat;
import static org.junit.Assert.assertThrows;

public class NginxPolicyFetcherTest extends AbstractPostgresEnabledTest {

    @Rule
    public WireMockRule wireMockRule = new WireMockRule(options().dynamicPort());

    @Rule
    public EnvironmentVariables environmentVariables = new EnvironmentVariables();

    @Test
    public void parseAndSaveVulnerabilityPolicyTest() {
        StringBuilder out = new StringBuilder("""
                apiVersion: v1.0
                type: Vulnerability Policy
                name: Example2
                description: Foo bar
                author: Jane Doe
                created: 2023-11-22T06:06:05Z
                updated: 2023-11-23T07:07:17Z
                validFrom: 2024-01-01T00:00:00Z
                validUntil: 2024-01-01T00:00:00Z
                conditions:
                  - vuln.id == "CVE-125" || vuln.aliases.exists(alias, alias.id == "CVE-123")
                  - |-
                    vuln.id == "CVE-156" || vuln.aliases.exists(alias, alias.id == "CVE-156")
                analysis:
                  state: NOT_AFFECTED
                  justification: CODE_NOT_REACHABLE
                  details: Because foo bar baz
                  suppress: true
                  vendorResponse: CAN_NOT_FIX
                ratings:
                  - method: CVSSV3
                    vector: CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:L
                    severity: MEDIUM
                    score: 6.3
                  - method: CVSSV2
                    vector: CVSS:2.0/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:L
                    severity: HIGH
                    score: 8.3""");
        NginxStorageHandler nginxStorageHandler = new NginxStorageHandler();
        assertThat(nginxStorageHandler.parseAndSaveVulnerabilityPolicy(out)).isTrue();

    }

    @Before
    public void beforeTest() {
        environmentVariables.set("VULNERABILITY_POLICY_FETCH_URL", wireMockRule.baseUrl() + "/bundles/test.zip");
        environmentVariables.set("VULNERABILITY_POLICY_FETCH_SOURCE_NAME", "NGINX");
    }

    @After
    public void afterTest(){
        environmentVariables.clear("VULNERABILITY_POLICY_FETCH_URL", "VULNERABILITY_POLICY_FETCH_SOURCE_NAME");
    }

    @Test
    public void testVerifyDownloadNeeded() throws IOException {
        WireMock.stubFor(WireMock.head(WireMock.urlPathMatching("/bundles/test.zip"))
                .willReturn(WireMock.aResponse().withStatus(HttpStatus.SC_OK)
                        .withHeader("ETag", "65708810-3a5")));
        NginxStorageHandler nginxStorageHandler = new NginxStorageHandler();
        assertThat(nginxStorageHandler.verifyDownloadNeeded()).isTrue();

    }

    @Test
    public void testVerifyDownloadNeededWithLastModifiedNull() throws IOException {
        if (qm.getConfigProperty(ConfigPropertyConstants.VULNERABILITY_POLICY_POLICY_FILE_LAST_MODIFIED_HASH.getGroupName(),
                ConfigPropertyConstants.VULNERABILITY_POLICY_POLICY_FILE_LAST_MODIFIED_HASH.getPropertyName()) == null) {
            qm.createConfigProperty(ConfigPropertyConstants.VULNERABILITY_POLICY_POLICY_FILE_LAST_MODIFIED_HASH.getGroupName(),
                    ConfigPropertyConstants.VULNERABILITY_POLICY_POLICY_FILE_LAST_MODIFIED_HASH.getPropertyName(),
                    null,
                    ConfigPropertyConstants.VULNERABILITY_POLICY_POLICY_FILE_LAST_MODIFIED_HASH.getPropertyType(),
                    ConfigPropertyConstants.VULNERABILITY_POLICY_POLICY_FILE_LAST_MODIFIED_HASH.getDescription());
        } else {
            qm.getConfigProperty(ConfigPropertyConstants.VULNERABILITY_POLICY_POLICY_FILE_LAST_MODIFIED_HASH.getGroupName(),
                    ConfigPropertyConstants.VULNERABILITY_POLICY_POLICY_FILE_LAST_MODIFIED_HASH.getPropertyName()).setPropertyValue(null);
        }
        WireMock.stubFor(WireMock.head(WireMock.urlPathMatching("/bundles/test.zip"))
                .willReturn(WireMock.aResponse().withStatus(HttpStatus.SC_OK)
                        .withHeader("Last-Modified", "Wed, 06 Dec 2023 14:41:20 GMT")
                        .withHeader("ETag", "65708810-3a5")));
        NginxStorageHandler nginxStorageHandler = new NginxStorageHandler();
        assertThat(nginxStorageHandler.verifyDownloadNeeded()).isTrue();

    }

    @Test
    public void testVerifyDownloadNeededWithLastModifiedSameAsUpstream() throws IOException {
        if (qm.getConfigProperty(ConfigPropertyConstants.VULNERABILITY_POLICY_POLICY_FILE_LAST_MODIFIED_HASH.getGroupName(),
                ConfigPropertyConstants.VULNERABILITY_POLICY_POLICY_FILE_LAST_MODIFIED_HASH.getPropertyName()) == null) {
            qm.createConfigProperty(ConfigPropertyConstants.VULNERABILITY_POLICY_POLICY_FILE_LAST_MODIFIED_HASH.getGroupName(),
                    ConfigPropertyConstants.VULNERABILITY_POLICY_POLICY_FILE_LAST_MODIFIED_HASH.getPropertyName(),
                    "65708810-3a5",
                    ConfigPropertyConstants.VULNERABILITY_POLICY_POLICY_FILE_LAST_MODIFIED_HASH.getPropertyType(),
                    ConfigPropertyConstants.VULNERABILITY_POLICY_POLICY_FILE_LAST_MODIFIED_HASH.getDescription());
        } else {
            qm.getConfigProperty(ConfigPropertyConstants.VULNERABILITY_POLICY_POLICY_FILE_LAST_MODIFIED_HASH.getGroupName(),
                    ConfigPropertyConstants.VULNERABILITY_POLICY_POLICY_FILE_LAST_MODIFIED_HASH.getPropertyName()).setPropertyValue("65708810-3a5");
        }
        WireMock.stubFor(WireMock.head(WireMock.urlPathMatching("/bundles/test.zip"))
                .willReturn(WireMock.aResponse().withStatus(HttpStatus.SC_OK)
                        .withHeader("Last-Modified", "Wed, 06 Dec 2023 14:41:20 GMT")
                        .withHeader("ETag", "65708810-3a5")));
        NginxStorageHandler nginxStorageHandler = new NginxStorageHandler();
        assertThat(nginxStorageHandler.verifyDownloadNeeded()).isFalse();

    }

    @Test
    public void testDownloadAndParseZipContent() throws IOException {
        WireMock.stubFor(WireMock.get(WireMock.urlPathMatching("/bundles/test.zip"))
                .willReturn(WireMock.aResponse().withBody(java.nio.file.Files.readAllBytes(Paths.get("src/test/resources/unit/tasks/vulnerabilitypolicy/test.zip")))
                        .withStatus(HttpStatus.SC_OK)));
        NginxStorageHandler nginxStorageHandler = new NginxStorageHandler();
        assertThat(nginxStorageHandler.downloadAndparseZippedContent()).isTrue();

    }

    @Test
    public void testVerifyDownloadNeededEndPointReturningNon200Status() {
        WireMock.stubFor(WireMock.head(WireMock.urlPathMatching("/bundles/test.zip"))
                .willReturn(WireMock.aResponse()
                        .withStatus(HttpStatus.SC_NOT_FOUND)));
        NginxStorageHandler nginxStorageHandler = new NginxStorageHandler();
        assertThrows(IOException.class, nginxStorageHandler::verifyDownloadNeeded);
    }
}
