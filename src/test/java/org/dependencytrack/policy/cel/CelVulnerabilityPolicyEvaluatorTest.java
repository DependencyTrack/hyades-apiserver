package org.dependencytrack.policy.cel;

import alpine.server.cache.AbstractCacheManager;
import org.dependencytrack.AbstractPostgresEnabledTest;
import org.dependencytrack.model.VulnerabilityAlias;
import org.dependencytrack.policy.vulnerability.VulnerabilityPolicy;
import org.dependencytrack.policy.vulnerability.VulnerabilityPolicyEvaluator;
import org.dependencytrack.policy.vulnerability.VulnerabilityPolicyProvider;
import org.dependencytrack.proto.policy.v1.Component;
import org.dependencytrack.proto.policy.v1.Project;
import org.dependencytrack.proto.policy.v1.Vulnerability;
import org.junit.Before;
import org.junit.Test;

import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.UUID;
import java.util.concurrent.TimeUnit;

import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.doReturn;
import static org.mockito.Mockito.mock;

public class CelVulnerabilityPolicyEvaluatorTest extends AbstractPostgresEnabledTest {

    private VulnerabilityPolicyProvider policyProviderMock;
    private VulnerabilityPolicyEvaluator policyEvaluator;

    @Before
    public void setUp() throws Exception {
        super.setUp();

        final var cacheManager = new TestCacheManager();
        final var policyScriptHost = CelPolicyScriptHost.getInstance(CelPolicyType.VULNERABILITY);
        policyProviderMock = mock(VulnerabilityPolicyProvider.class);
        policyEvaluator = new CelVulnerabilityPolicyEvaluator(policyProviderMock, policyScriptHost, cacheManager);
    }

    @Test
    public void testEvaluateWithNoApplicablePolicies() {
        final var project = Project.newBuilder()
                .setUuid(UUID.randomUUID().toString())
                .setName("acme-app")
                .build();
        final var component = Component.newBuilder()
                .setUuid(UUID.randomUUID().toString())
                .setName("acme-lib")
                .build();
        final UUID vulnUuid = UUID.randomUUID();
        final var vuln = Vulnerability.newBuilder()
                .setUuid(vulnUuid.toString())
                .setId("CVE-123")
                .build();

        doReturn(Collections.emptyList())
                .when(policyProviderMock).getApplicablePolicies(any(Project.class));

        assertThat(policyEvaluator.evaluate(List.of(vuln), component, project)).isEmpty();
    }

    @Test
    public void testEvaluateWithNoMatchingPolicies() {
        final var project = Project.newBuilder()
                .setUuid(UUID.randomUUID().toString())
                .setName("acme-app")
                .build();
        final var component = Component.newBuilder()
                .setUuid(UUID.randomUUID().toString())
                .setName("acme-lib")
                .build();
        final UUID vulnUuid = UUID.randomUUID();
        final var vuln = Vulnerability.newBuilder()
                .setUuid(vulnUuid.toString())
                .setId("CVE-123")
                .build();

        final var policyA = new VulnerabilityPolicy();
        policyA.setName("policyA");
        policyA.setConditions(List.of("component.name == 'foo'"));
        final var policyB = new VulnerabilityPolicy();
        policyB.setName("policyB");
        policyB.setConditions(List.of("project.name == 'bar'"));
        final var policyC = new VulnerabilityPolicy();
        policyC.setName("policyC");
        policyC.setConditions(List.of("vuln.id == 'baz'"));

        doReturn(List.of(policyA, policyB, policyC))
                .when(policyProviderMock).getApplicablePolicies(any(Project.class));

        assertThat(policyEvaluator.evaluate(List.of(vuln), component, project)).isEmpty();
    }

    @Test
    public void testEvaluateWithMultipleMatchingPolicies() {
        final var project = Project.newBuilder()
                .setUuid(UUID.randomUUID().toString())
                .setName("acme-app")
                .build();
        final var component = Component.newBuilder()
                .setUuid(UUID.randomUUID().toString())
                .setName("acme-lib")
                .build();
        final UUID vulnUuid = UUID.randomUUID();
        final var vuln = Vulnerability.newBuilder()
                .setUuid(vulnUuid.toString())
                .setId("CVE-123")
                .build();

        // Create multiple policies which all match the given evaluation input.
        final var policyA = new VulnerabilityPolicy();
        policyA.setName("policyA");
        policyA.setConditions(List.of("component.name == 'acme-lib'"));
        final var policyB = new VulnerabilityPolicy();
        policyB.setName("policyB");
        policyB.setConditions(List.of("project.name == 'acme-app'"));
        final var policyC = new VulnerabilityPolicy();
        policyC.setName("policyC");
        policyC.setConditions(List.of("vuln.id == 'CVE-123'"));

        doReturn(List.of(policyA, policyB, policyC))
                .when(policyProviderMock).getApplicablePolicies(any(Project.class));

        // Policies are supposed to be evaluated in order, so policyA should be the only match.
        assertThat(policyEvaluator.evaluate(List.of(vuln), component, project))
                .hasEntrySatisfying(vulnUuid, policy -> {
                    assertThat(policy.name()).isEqualTo("policyA");
                });
    }

    @Test
    public void testEvaluateWithAdditionalRequiredFields() {
        final var persistentProject = new org.dependencytrack.model.Project();
        persistentProject.setName("acme-app");
        persistentProject.setVersion("1.0.0");
        qm.persist(persistentProject);

        final var persistentComponent = new org.dependencytrack.model.Component();
        persistentComponent.setProject(persistentProject);
        persistentComponent.setName("acme-lib");
        persistentComponent.setVersion("2.0.0");
        qm.persist(persistentComponent);

        final var persistentVuln = new org.dependencytrack.model.Vulnerability();
        persistentVuln.setVulnId("CVE-123");
        persistentVuln.setSource(org.dependencytrack.model.Vulnerability.Source.NVD);
        persistentVuln.setCvssV3Vector("CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:C/C:L/I:H/A:L");
        qm.persist(persistentVuln);

        final var alias = new VulnerabilityAlias();
        alias.setCveId("CVE-123");
        alias.setGhsaId("GHSA-123");
        qm.synchronizeVulnerabilityAlias(alias);

        final var project = Project.newBuilder()
                .setUuid(persistentProject.getUuid().toString())
                .setName("acme-app")
                .build();
        final var component = Component.newBuilder()
                .setUuid(persistentComponent.getUuid().toString())
                .setName("acme-lib")
                .build();
        final var vuln = Vulnerability.newBuilder()
                .setUuid(persistentVuln.getUuid().toString())
                .setId("CVE-123")
                .build();

        // Access more fields than provided in the evaluation arguments.
        // The evaluator should load those fields from the database.
        final var policy = new VulnerabilityPolicy();
        policy.setName("policy");
        policy.setConditions(List.of("""
                project.name == "acme-app"
                  && project.version == "1.0.0"
                  && component.name == "acme-lib"
                  && component.version == "2.0.0"
                  && vuln.id == "CVE-123"
                  && vuln.cvssv3_vector == "CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:C/C:L/I:H/A:L"
                  && vuln.aliases.exists(alias, alias.id == "GHSA-123")
                """));

        doReturn(List.of(policy))
                .when(policyProviderMock).getApplicablePolicies(any(Project.class));

        assertThat(policyEvaluator.evaluate(List.of(vuln), component, project))
                .containsOnly(Map.entry(persistentVuln.getUuid(), policy));
    }

    private static final class TestCacheManager extends AbstractCacheManager {

        private TestCacheManager() {
            super(30, TimeUnit.SECONDS, 5);
        }

    }

}