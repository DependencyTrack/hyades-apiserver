package org.dependencytrack.policy.vulnerability;

import alpine.server.cache.AbstractCacheManager;
import org.dependencytrack.AbstractPostgresEnabledTest;
import org.dependencytrack.policy.cel.CelPolicyScriptHost;
import org.dependencytrack.proto.policy.v1.Component;
import org.dependencytrack.proto.policy.v1.Project;
import org.dependencytrack.proto.policy.v1.Vulnerability;
import org.junit.Before;
import org.junit.Test;

import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.doReturn;
import static org.mockito.Mockito.mock;

public class CelVulnerabilityPolicyEvaluatorTest extends AbstractPostgresEnabledTest {

    private final AbstractCacheManager cacheManager = new CelVulnerabilityPolicyCacheManager();
    private final CelPolicyScriptHost scriptHost = new CelPolicyScriptHost(cacheManager);
    private final VulnerabilityPolicyProvider policyProviderMock = mock(VulnerabilityPolicyProvider.class);
    private final VulnerabilityPolicyEvaluator policyEvaluator = new CelVulnerabilityPolicyEvaluator(policyProviderMock, scriptHost, cacheManager);

    @Before
    public void setUp() throws Exception {
        super.setUp();

        cacheManager.put("foo", Project.getDefaultInstance());
        cacheManager.put("foo", Component.getDefaultInstance());
        cacheManager.put("foo", Vulnerability.getDefaultInstance());
    }

    @Test
    public void testEvaluateWithNoApplicablePolicies() {
        final var project = Project.newBuilder()
                .setUuid(UUID.randomUUID().toString())
                .setName("acme-app")
                .build();
        final var component = Component.newBuilder()
                .setUuid(UUID.randomUUID().toString())
                .setName("acme-lib")
                .build();
        final UUID vulnUuid = UUID.randomUUID();
        final var vuln = Vulnerability.newBuilder()
                .setUuid(vulnUuid.toString())
                .setId("CVE-123")
                .build();

        doReturn(Collections.emptyList())
                .when(policyProviderMock).getApplicablePolicies(any(Project.class));

        assertThat(policyEvaluator.evaluate(List.of(vuln), component, project)).isEmpty();
    }

    @Test
    public void testEvaluateWithNoMatchingPolicies() {
        final var project = Project.newBuilder()
                .setUuid(UUID.randomUUID().toString())
                .setName("acme-app")
                .build();
        final var component = Component.newBuilder()
                .setUuid(UUID.randomUUID().toString())
                .setName("acme-lib")
                .build();
        final UUID vulnUuid = UUID.randomUUID();
        final var vuln = Vulnerability.newBuilder()
                .setUuid(vulnUuid.toString())
                .setId("CVE-123")
                .build();

        final var policyA = new VulnerabilityPolicy();
        policyA.setName("policyA");
        policyA.setConditions(List.of("component.name == 'foo'"));
        final var policyB = new VulnerabilityPolicy();
        policyB.setName("policyB");
        policyB.setConditions(List.of("project.name == 'bar'"));
        final var policyC = new VulnerabilityPolicy();
        policyC.setName("policyC");
        policyC.setConditions(List.of("vuln.id == 'baz'"));

        doReturn(List.of(policyA, policyB, policyC))
                .when(policyProviderMock).getApplicablePolicies(any(Project.class));

        assertThat(policyEvaluator.evaluate(List.of(vuln), component, project)).isEmpty();
    }

    @Test
    public void testEvaluateWithMultipleMatchingPolicies() {
        final var project = Project.newBuilder()
                .setUuid(UUID.randomUUID().toString())
                .setName("acme-app")
                .build();
        final var component = Component.newBuilder()
                .setUuid(UUID.randomUUID().toString())
                .setName("acme-lib")
                .build();
        final UUID vulnUuid = UUID.randomUUID();
        final var vuln = Vulnerability.newBuilder()
                .setUuid(vulnUuid.toString())
                .setId("CVE-123")
                .build();

        // Create multiple policies which all match the given evaluation input.
        final var policyA = new VulnerabilityPolicy();
        policyA.setName("policyA");
        policyA.setConditions(List.of("component.name == 'acme-lib'"));
        final var policyB = new VulnerabilityPolicy();
        policyB.setName("policyB");
        policyB.setConditions(List.of("project.name == 'acme-app'"));
        final var policyC = new VulnerabilityPolicy();
        policyC.setName("policyC");
        policyC.setConditions(List.of("vuln.id == 'CVE-123'"));

        doReturn(List.of(policyA, policyB, policyC))
                .when(policyProviderMock).getApplicablePolicies(any(Project.class));

        // Policies are supposed to be evaluated in order, so policyA should be the only match.
        assertThat(policyEvaluator.evaluate(List.of(vuln), component, project))
                .hasEntrySatisfying(vulnUuid, policy -> {
                    assertThat(policy.name()).isEqualTo("policyA");
                });
    }

    @Test
    public void testEvaluateWithAdditionalRequiredFields() {
        final var persistentProject = new org.dependencytrack.model.Project();
        persistentProject.setName("acme-app");
        persistentProject.setVersion("1.0.0");
        qm.persist(persistentProject);

        final var persistentComponent = new org.dependencytrack.model.Component();
        persistentComponent.setProject(persistentProject);
        persistentComponent.setName("acme-lib");
        persistentComponent.setVersion("2.0.0");
        qm.persist(persistentComponent);

        final var persistentVuln = new org.dependencytrack.model.Vulnerability();
        persistentVuln.setVulnId("CVE-123");
        persistentVuln.setSource(org.dependencytrack.model.Vulnerability.Source.NVD);
        persistentVuln.setCvssV2Vector("adsfasdfasdf");
        qm.persist(persistentVuln);

        final var project = Project.newBuilder()
                .setUuid(persistentProject.getUuid().toString())
                .setName("acme-app")
                .build();
        final var component = Component.newBuilder()
                .setUuid(persistentComponent.getUuid().toString())
                .setName("acme-lib")
                .build();
        final var vuln = Vulnerability.newBuilder()
                .setUuid(persistentVuln.getUuid().toString())
                .setId("CVE-123")
                .build();

        // Access more fields than provided in the evaluation arguments.
        // The evaluator should load those fields from the database.
        final var policy = new VulnerabilityPolicy();
        policy.setName("policy");
        policy.setConditions(List.of("""
                project.name == "acme-app"
                  // && project.version == "1.0.0"
                  && component.name == "acme-lib"
                  && component.version == "2.0.0"
                  && vuln.id == "CVE-123"
                  // && vuln.cvssv2_vector == "adsfasdfasdf"
                """));

        doReturn(List.of(policy))
                .when(policyProviderMock).getApplicablePolicies(any(Project.class));

        assertThat(policyEvaluator.evaluate(List.of(vuln), component, project))
                .containsOnly(Map.entry(persistentVuln.getUuid(), policy));
    }

}