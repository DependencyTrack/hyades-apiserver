package org.dependencytrack.event.kafka.processor;

import org.apache.kafka.common.serialization.UUIDDeserializer;
import org.apache.kafka.common.serialization.UUIDSerializer;
import org.apache.kafka.streams.TestInputTopic;
import org.apache.kafka.streams.TestOutputTopic;
import org.apache.kafka.streams.Topology;
import org.apache.kafka.streams.TopologyTestDriver;
import org.dependencytrack.PersistenceCapableTest;
import org.dependencytrack.event.kafka.dto.VulnerabilityScanKey;
import org.dependencytrack.event.kafka.dto.VulnerabilityScanResult;
import org.dependencytrack.event.kafka.dto.VulnerabilityScanStatus;
import org.dependencytrack.event.kafka.serialization.JacksonDeserializer;
import org.dependencytrack.event.kafka.serialization.JacksonSerializer;
import org.dependencytrack.event.kafka.serialization.VulnerabilityScanKeyDeserializer;
import org.dependencytrack.event.kafka.serialization.VulnerabilityScanKeySerializer;
import org.dependencytrack.model.Component;
import org.dependencytrack.model.Project;
import org.dependencytrack.model.Vulnerability;
import org.dependencytrack.model.AnalyzerIdentity;
import org.junit.After;
import org.junit.Before;
import org.junit.Test;

import java.util.List;
import java.util.UUID;

import static org.assertj.core.api.Assertions.assertThat;

public class VulnerabilityScanResultProcessorTest extends PersistenceCapableTest {

    private TopologyTestDriver testDriver;
    private TestInputTopic<UUID, VulnerabilityScanResult> inputTopic;
    private TestOutputTopic<VulnerabilityScanKey, VulnerabilityScanResult> outputTopic;

    @Before
    public void setUp() {
        final var topology = new Topology();
        topology.addSource("sourceProcessor",
                new UUIDDeserializer(), new JacksonDeserializer<>(VulnerabilityScanResult.class), "input-topic");
        topology.addProcessor("scanResultProcessor",
                VulnerabilityScanResultProcessor::new, "sourceProcessor");
        topology.addSink("sinkProcessor", "output-topic",
                new VulnerabilityScanKeySerializer(), new JacksonSerializer<>(), "scanResultProcessor");

        testDriver = new TopologyTestDriver(topology);
        inputTopic = testDriver.createInputTopic("input-topic",
                new UUIDSerializer(), new JacksonSerializer<>());
        outputTopic = testDriver.createOutputTopic("output-topic",
                new VulnerabilityScanKeyDeserializer(), new JacksonDeserializer<>(VulnerabilityScanResult.class));
    }

    @After
    public void tearDown() {
        if (testDriver != null) {
            testDriver.close();
        }
    }

    @Test
    public void forwardCompletionEventTest() {
        final var componentUuid = UUID.randomUUID();
        final var scanToken = UUID.randomUUID().toString();
        final var scanKey = new VulnerabilityScanKey(scanToken, componentUuid);
        final var scanResult = new VulnerabilityScanResult(scanKey, AnalyzerIdentity.NONE,
                VulnerabilityScanStatus.COMPLETE, null, null);

        inputTopic.pipeInput(componentUuid, scanResult);

        assertThat(outputTopic.readRecordsToList()).satisfiesExactly(
                record -> {
                    assertThat(record.key()).isEqualTo(scanKey);
                    assertThat(record.value()).isEqualTo(scanResult);
                }
        );
    }

    @Test
    public void dropFailedScanResultTest() {
        final var componentUuid = UUID.randomUUID();
        final var scanToken = UUID.randomUUID().toString();
        final var scanKey = new VulnerabilityScanKey(scanToken, componentUuid);
        final var scanResult = new VulnerabilityScanResult(scanKey, AnalyzerIdentity.INTERNAL_ANALYZER,
                VulnerabilityScanStatus.FAILED, null, "just because");

        inputTopic.pipeInput(componentUuid, scanResult);

        assertThat(outputTopic.getQueueSize()).isZero();
    }

    @Test
    public void dropPendingScanResultTest() {
        final var componentUuid = UUID.randomUUID();
        final var scanToken = UUID.randomUUID().toString();
        final var scanKey = new VulnerabilityScanKey(scanToken, componentUuid);
        final var scanResult = new VulnerabilityScanResult(scanKey, AnalyzerIdentity.INTERNAL_ANALYZER,
                VulnerabilityScanStatus.PENDING, null, null);

        inputTopic.pipeInput(componentUuid, scanResult);

        assertThat(outputTopic.getQueueSize()).isZero();
    }

    @Test
    public void processSuccessfulScanResultWhenComponentDoesNotExistTest() {
        final var componentUuid = UUID.randomUUID();
        final var scanToken = UUID.randomUUID().toString();
        final var scanKey = new VulnerabilityScanKey(scanToken, componentUuid);
        final var vuln = new Vulnerability();
        vuln.setVulnId("INT-001");
        vuln.setSource(Vulnerability.Source.INTERNAL);
        final var scanResult = new VulnerabilityScanResult(scanKey, AnalyzerIdentity.INTERNAL_ANALYZER,
                VulnerabilityScanStatus.SUCCESSFUL, List.of(vuln), null);

        inputTopic.pipeInput(componentUuid, scanResult);

        assertThat(outputTopic.getQueueSize()).isZero();
    }

    @Test
    public void processSuccessfulScanResult() {
        final var project = new Project();
        project.setName("acme-app");
        project.setVersion("1.0.0");
        qm.persist(project);

        final var component = new Component();
        component.setName("acme-lib");
        component.setVersion("1.1.0");
        component.setProject(project);
        qm.persist(component);

        final var componentUuid = component.getUuid();
        final var scanToken = UUID.randomUUID().toString();
        final var scanKey = new VulnerabilityScanKey(scanToken, componentUuid);
        final var vulnA = new Vulnerability();
        vulnA.setVulnId("INT-001");
        vulnA.setSource(Vulnerability.Source.INTERNAL);
        final var vulnB = new Vulnerability();
        vulnB.setVulnId("SONATYPE-002");
        vulnB.setSource(Vulnerability.Source.OSSINDEX);
        final var scanResult = new VulnerabilityScanResult(scanKey, AnalyzerIdentity.INTERNAL_ANALYZER,
                VulnerabilityScanStatus.SUCCESSFUL, List.of(vulnA, vulnB), null);

        inputTopic.pipeInput(componentUuid, scanResult);

        assertThat(outputTopic.getQueueSize()).isZero();

        qm.getPersistenceManager().refresh(component);
        assertThat(component.getVulnerabilities()).satisfiesExactlyInAnyOrder(
                vuln -> {
                    assertThat(vuln.getVulnId()).isEqualTo("INT-001");
                    assertThat(vuln.getSource()).isEqualTo(Vulnerability.Source.INTERNAL.name());
                },
                vuln -> {
                    assertThat(vuln.getVulnId()).isEqualTo("SONATYPE-002");
                    assertThat(vuln.getSource()).isEqualTo(Vulnerability.Source.OSSINDEX.name());
                }
        );
    }

}