package org.dependencytrack.event.kafka.processor;

import com.google.protobuf.Timestamp;
import junitparams.JUnitParamsRunner;
import junitparams.Parameters;
import org.apache.kafka.common.header.Headers;
import org.apache.kafka.common.header.internals.RecordHeaders;
import org.apache.kafka.streams.StreamsBuilder;
import org.apache.kafka.streams.TestInputTopic;
import org.apache.kafka.streams.TestOutputTopic;
import org.apache.kafka.streams.TopologyTestDriver;
import org.apache.kafka.streams.kstream.Consumed;
import org.apache.kafka.streams.kstream.Produced;
import org.apache.kafka.streams.test.TestRecord;
import org.cyclonedx.proto.v1_4.Advisory;
import org.cyclonedx.proto.v1_4.Bom;
import org.cyclonedx.proto.v1_4.Property;
import org.cyclonedx.proto.v1_4.Source;
import org.cyclonedx.proto.v1_4.VulnerabilityRating;
import org.cyclonedx.proto.v1_4.VulnerabilityReference;
import org.dependencytrack.AbstractPostgresEnabledTest;
import org.dependencytrack.TestCacheManager;
import org.dependencytrack.event.kafka.KafkaEventHeaders;
import org.dependencytrack.event.kafka.KafkaTopics;
import org.dependencytrack.event.kafka.serialization.KafkaProtobufDeserializer;
import org.dependencytrack.event.kafka.serialization.KafkaProtobufSerde;
import org.dependencytrack.event.kafka.serialization.KafkaProtobufSerializer;
import org.dependencytrack.model.Analysis;
import org.dependencytrack.model.AnalysisComment;
import org.dependencytrack.model.AnalysisJustification;
import org.dependencytrack.model.AnalysisResponse;
import org.dependencytrack.model.AnalysisState;
import org.dependencytrack.model.AnalyzerIdentity;
import org.dependencytrack.model.Component;
import org.dependencytrack.model.ConfigPropertyConstants;
import org.dependencytrack.model.Finding;
import org.dependencytrack.model.FindingAttribution;
import org.dependencytrack.model.Project;
import org.dependencytrack.model.Severity;
import org.dependencytrack.model.Vulnerability;
import org.dependencytrack.model.VulnerabilityAlias;
import org.dependencytrack.model.VulnerabilityAnalysisLevel;
import org.dependencytrack.model.VulnerabilityPolicy;
import org.dependencytrack.notification.NotificationConstants;
import org.dependencytrack.persistence.CweImporter;
import org.dependencytrack.policy.cel.CelPolicyScriptHost;
import org.dependencytrack.policy.cel.CelPolicyType;
import org.dependencytrack.policy.cel.CelVulnerabilityPolicyEvaluator;
import org.dependencytrack.policy.vulnerability.DatabaseVulnerabilityPolicyProvider;
import org.dependencytrack.policy.vulnerability.VulnerabilityPolicyAnalysis;
import org.dependencytrack.policy.vulnerability.VulnerabilityPolicyRating;
import org.dependencytrack.proto.notification.v1.NewVulnerabilitySubject;
import org.dependencytrack.proto.notification.v1.NewVulnerableDependencySubject;
import org.dependencytrack.proto.notification.v1.Notification;
import org.dependencytrack.proto.notification.v1.VulnerabilityAnalysisDecisionChangeSubject;
import org.dependencytrack.proto.vulnanalysis.v1.ScanKey;
import org.dependencytrack.proto.vulnanalysis.v1.ScanResult;
import org.dependencytrack.proto.vulnanalysis.v1.Scanner;
import org.dependencytrack.proto.vulnanalysis.v1.ScannerResult;
import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;

import java.math.BigDecimal;
import java.sql.Date;
import java.time.Instant;
import java.util.List;
import java.util.UUID;
import java.util.concurrent.TimeUnit;

import static org.assertj.core.api.Assertions.assertThat;
import static org.cyclonedx.proto.v1_4.ScoreMethod.SCORE_METHOD_CVSSV2;
import static org.cyclonedx.proto.v1_4.ScoreMethod.SCORE_METHOD_CVSSV3;
import static org.cyclonedx.proto.v1_4.ScoreMethod.SCORE_METHOD_OWASP;
import static org.dependencytrack.persistence.jdbi.JdbiFactory.jdbi;
import static org.dependencytrack.proto.notification.v1.Group.GROUP_ANALYZER;
import static org.dependencytrack.proto.notification.v1.Group.GROUP_NEW_VULNERABILITY;
import static org.dependencytrack.proto.notification.v1.Group.GROUP_NEW_VULNERABLE_DEPENDENCY;
import static org.dependencytrack.proto.notification.v1.Group.GROUP_PROJECT_AUDIT_CHANGE;
import static org.dependencytrack.proto.notification.v1.Level.LEVEL_ERROR;
import static org.dependencytrack.proto.notification.v1.Level.LEVEL_INFORMATIONAL;
import static org.dependencytrack.proto.notification.v1.Scope.SCOPE_PORTFOLIO;
import static org.dependencytrack.proto.notification.v1.Scope.SCOPE_SYSTEM;
import static org.dependencytrack.proto.vulnanalysis.v1.ScanStatus.SCAN_STATUS_FAILED;
import static org.dependencytrack.proto.vulnanalysis.v1.ScanStatus.SCAN_STATUS_PENDING;
import static org.dependencytrack.proto.vulnanalysis.v1.ScanStatus.SCAN_STATUS_SUCCESSFUL;
import static org.dependencytrack.proto.vulnanalysis.v1.Scanner.SCANNER_INTERNAL;
import static org.dependencytrack.proto.vulnanalysis.v1.Scanner.SCANNER_OSSINDEX;
import static org.dependencytrack.proto.vulnanalysis.v1.Scanner.SCANNER_SNYK;
import static org.dependencytrack.util.KafkaTestUtil.deserializeValue;

@RunWith(JUnitParamsRunner.class)
public class VulnerabilityScanResultProcessorTest extends AbstractPostgresEnabledTest {

    private TopologyTestDriver testDriver;
    private TestInputTopic<ScanKey, ScanResult> inputTopic;
    private TestOutputTopic<ScanKey, ScanResult> outputTopic;

    @Before
    public void setUp() throws Exception {
        super.setUp();

        final var cacheManager = new TestCacheManager(5, TimeUnit.MINUTES, 100);
        final var scriptHost = new CelPolicyScriptHost(cacheManager, CelPolicyType.VULNERABILITY);
        final var policyProvider = new DatabaseVulnerabilityPolicyProvider();
        final var policyEvaluator = new CelVulnerabilityPolicyEvaluator(policyProvider, scriptHost, cacheManager);

        final var streamsBuilder = new StreamsBuilder();
        streamsBuilder
                .stream("input-topic", Consumed
                        .with(new KafkaProtobufSerde<>(ScanKey.parser()), new KafkaProtobufSerde<>(ScanResult.parser())))
                .processValues(() -> new VulnerabilityScanResultProcessor(policyEvaluator))
                .to("output-topic", Produced
                        .with(new KafkaProtobufSerde<>(ScanKey.parser()), new KafkaProtobufSerde<>(ScanResult.parser())));

        testDriver = new TopologyTestDriver(streamsBuilder.build());
        inputTopic = testDriver.createInputTopic("input-topic",
                new KafkaProtobufSerializer<>(), new KafkaProtobufSerializer<>());
        outputTopic = testDriver.createOutputTopic("output-topic",
                new KafkaProtobufDeserializer<>(ScanKey.parser()), new KafkaProtobufDeserializer<>(ScanResult.parser()));

        new CweImporter().processCweDefinitions(); // Required for CWE mapping
    }

    @After
    public void tearDown() {
        if (testDriver != null) {
            testDriver.close();
        }

        super.tearDown();
    }

    @Test
    public void dropFailedScanResultTest() {
        final var project = new Project();
        project.setName("acme-app");
        project.setVersion("1.0.0");
        qm.persist(project);

        final var component = new Component();
        component.setName("acme-lib");
        component.setVersion("1.1.0");
        component.setProject(project);
        qm.persist(component);

        final var scanToken = UUID.randomUUID().toString();
        final var scanKey = ScanKey.newBuilder().setScanToken(scanToken).setComponentUuid(component.getUuid().toString()).build();
        final var scanResult = ScanResult.newBuilder()
                .setKey(scanKey)
                .addScannerResults(ScannerResult.newBuilder()
                        .setScanner(SCANNER_INTERNAL)
                        .setStatus(SCAN_STATUS_FAILED)
                        .setFailureReason("just because"))
                .build();

        inputTopic.pipeInput(scanKey, scanResult);

        assertThat(outputTopic.readValuesToList()).containsOnly(scanResult);

        assertThat(kafkaMockProducer.history()).satisfiesExactly(
                record -> {
                    assertThat(record.topic()).isEqualTo(KafkaTopics.NOTIFICATION_ANALYZER.name());
                    final Notification notification = deserializeValue(KafkaTopics.NOTIFICATION_ANALYZER, record);
                    assertThat(notification.getScope()).isEqualTo(SCOPE_SYSTEM);
                    assertThat(notification.getLevel()).isEqualTo(LEVEL_ERROR);
                    assertThat(notification.getGroup()).isEqualTo(GROUP_ANALYZER);
                    assertThat(notification.getTitle()).isEqualTo(NotificationConstants.Title.ANALYZER_ERROR);
                    assertThat(notification.getContent()).isEqualTo(
                            "Scan of component %s with %s failed (scanKey: %s): just because",
                            component.getUuid(), SCANNER_INTERNAL, scanToken + "/" + component.getUuid());
                }
        );
    }

    @Test
    public void dropPendingScanResultTest() {
        final var project = new Project();
        project.setName("acme-app");
        project.setVersion("1.0.0");
        qm.persist(project);

        final var component = new Component();
        component.setName("acme-lib");
        component.setVersion("1.1.0");
        component.setProject(project);
        qm.persist(component);

        final var scanToken = UUID.randomUUID().toString();
        final var scanKey = ScanKey.newBuilder().setScanToken(scanToken).setComponentUuid(component.getUuid().toString()).build();
        final var scanResult = ScanResult.newBuilder()
                .setKey(scanKey)
                .addScannerResults(ScannerResult.newBuilder()
                        .setScanner(SCANNER_INTERNAL)
                        .setStatus(SCAN_STATUS_PENDING))
                .build();

        inputTopic.pipeInput(scanKey, scanResult);

        assertThat(outputTopic.readValuesToList()).containsOnly(scanResult);

        assertThat(kafkaMockProducer.history()).isEmpty();
    }

    @Test
    public void processSuccessfulScanResultWhenComponentDoesNotExistTest() {
        final var componentUuid = UUID.randomUUID();
        final var scanToken = UUID.randomUUID().toString();
        final var scanKey = ScanKey.newBuilder().setScanToken(scanToken).setComponentUuid(componentUuid.toString()).build();
        final var vuln = new Vulnerability();
        vuln.setVulnId("INT-001");
        vuln.setSource(Vulnerability.Source.INTERNAL);
        final var scanResult = ScanResult.newBuilder()
                .setKey(scanKey)
                .addScannerResults(ScannerResult.newBuilder()
                        .setScanner(SCANNER_INTERNAL)
                        .setStatus(SCAN_STATUS_SUCCESSFUL)
                        .setBom(Bom.newBuilder().addVulnerabilities(createVuln("INT-001", "INTERNAL"))))
                .build();

        inputTopic.pipeInput(scanKey, scanResult);

        assertThat(outputTopic.readValuesToList()).containsOnly(scanResult);

        assertThat(kafkaMockProducer.history()).isEmpty();
    }

    @Test
    public void processSuccessfulScanResult() {
        final var project = new Project();
        project.setName("acme-app");
        project.setVersion("1.0.0");
        qm.persist(project);

        final var component = new Component();
        component.setName("acme-lib");
        component.setVersion("1.1.0");
        component.setProject(project);
        qm.persist(component);

        final var componentUuid = component.getUuid();
        final var scanToken = UUID.randomUUID().toString();
        final var scanKey = ScanKey.newBuilder().setScanToken(scanToken).setComponentUuid(componentUuid.toString()).build();
        final var vulnA = new Vulnerability();
        vulnA.setVulnId("INT-001");
        vulnA.setSource(Vulnerability.Source.INTERNAL);
        qm.persist(vulnA);
        final var vulnB = new Vulnerability();
        vulnB.setVulnId("SONATYPE-002");
        vulnB.setSource(Vulnerability.Source.OSSINDEX);
        final var vulnC = new Vulnerability();
        vulnC.setVulnId("INT-002");
        vulnC.setSource(Vulnerability.Source.INTERNAL);
        final var scanResult = ScanResult.newBuilder()
                .setKey(scanKey)
                .addScannerResults(ScannerResult.newBuilder()
                        .setScanner(SCANNER_INTERNAL)
                        .setStatus(SCAN_STATUS_SUCCESSFUL)
                        .setBom(Bom.newBuilder().addAllVulnerabilities(List.of(
                                createVuln(vulnA.getVulnId(), "INTERNAL"),
                                createVuln(vulnB.getVulnId(), "OSSINDEX"),
                                createVuln(vulnC.getVulnId(), "INTERNAL")
                        ))))
                .build();
        final Headers headers = new RecordHeaders();
        headers.add(KafkaEventHeaders.VULN_ANALYSIS_LEVEL, VulnerabilityAnalysisLevel.BOM_UPLOAD_ANALYSIS.name().getBytes());
        headers.add(KafkaEventHeaders.IS_NEW_COMPONENT, "true".getBytes());

        inputTopic.pipeInput(new TestRecord<>(scanKey, scanResult, headers));

        assertThat(outputTopic.readValuesToList()).containsOnly(scanResult);

        qm.getPersistenceManager().refresh(component);
        assertThat(component.getVulnerabilities()).satisfiesExactlyInAnyOrder(
                vuln -> {
                    assertThat(vuln.getVulnId()).isEqualTo("INT-001");
                    assertThat(vuln.getSource()).isEqualTo(Vulnerability.Source.INTERNAL.name());
                },
                vuln -> {
                    assertThat(vuln.getVulnId()).isEqualTo("SONATYPE-002");
                    assertThat(vuln.getSource()).isEqualTo(Vulnerability.Source.OSSINDEX.name());
                }
                // INT-002 is discarded because it is internal but doesn't exist in the database.
        );

        final List<Finding> findings = qm.getFindings(project, false);
        assertThat(findings).satisfiesExactlyInAnyOrder(
                finding -> {
                    assertThat(finding.getVulnerability().get("vulnId")).isEqualTo("INT-001");
                    assertThat(finding.getAttribution().get("analyzerIdentity")).isEqualTo(AnalyzerIdentity.INTERNAL_ANALYZER.name());
                },
                finding -> {
                    assertThat(finding.getVulnerability().get("vulnId")).isEqualTo("SONATYPE-002");
                    assertThat(finding.getAttribution().get("analyzerIdentity")).isEqualTo(AnalyzerIdentity.INTERNAL_ANALYZER.name());
                }
                // INT-002 is discarded because it is internal but doesn't exist in the database.
        );

        assertThat(kafkaMockProducer.history()).satisfiesExactly(
                record -> {
                    assertThat(record.topic()).isEqualTo(KafkaTopics.NOTIFICATION_NEW_VULNERABLE_DEPENDENCY.name());
                    final Notification notification = deserializeValue(KafkaTopics.NOTIFICATION_NEW_VULNERABLE_DEPENDENCY, record);
                    assertThat(notification.getScope()).isEqualTo(SCOPE_PORTFOLIO);
                    assertThat(notification.getLevel()).isEqualTo(LEVEL_INFORMATIONAL);
                    assertThat(notification.getGroup()).isEqualTo(GROUP_NEW_VULNERABLE_DEPENDENCY);
                    assertThat(notification.getSubject().is(NewVulnerableDependencySubject.class)).isTrue();
                    final var subject = notification.getSubject().unpack(NewVulnerableDependencySubject.class);
                    assertThat(subject.getComponent().getName()).isEqualTo("acme-lib");
                    assertThat(subject.getComponent().getVersion()).isEqualTo("1.1.0");
                    assertThat(subject.getProject().getName()).isEqualTo("acme-app");
                    assertThat(subject.getProject().getVersion()).isEqualTo("1.0.0");
                    assertThat(subject.getVulnerabilitiesCount()).isEqualTo(2);
                },
                record -> {
                    assertThat(record.topic()).isEqualTo(KafkaTopics.NOTIFICATION_NEW_VULNERABILITY.name());
                    final Notification notification = deserializeValue(KafkaTopics.NOTIFICATION_NEW_VULNERABILITY, record);
                    assertThat(notification.getScope()).isEqualTo(SCOPE_PORTFOLIO);
                    assertThat(notification.getLevel()).isEqualTo(LEVEL_INFORMATIONAL);
                    assertThat(notification.getGroup()).isEqualTo(GROUP_NEW_VULNERABILITY);
                    assertThat(notification.getSubject().is(NewVulnerabilitySubject.class)).isTrue();
                    final var subject = notification.getSubject().unpack(NewVulnerabilitySubject.class);
                    assertThat(subject.getVulnerabilityAnalysisLevel()).isEqualTo("BOM_UPLOAD_ANALYSIS");
                },
                record -> {
                    assertThat(record.topic()).isEqualTo(KafkaTopics.NOTIFICATION_NEW_VULNERABILITY.name());
                    final Notification notification = deserializeValue(KafkaTopics.NOTIFICATION_NEW_VULNERABILITY, record);
                    assertThat(notification.getScope()).isEqualTo(SCOPE_PORTFOLIO);
                    assertThat(notification.getLevel()).isEqualTo(LEVEL_INFORMATIONAL);
                    assertThat(notification.getGroup()).isEqualTo(GROUP_NEW_VULNERABILITY);
                    assertThat(notification.getSubject().is(NewVulnerabilitySubject.class)).isTrue();
                    final var subject = notification.getSubject().unpack(NewVulnerabilitySubject.class);
                    assertThat(subject.getVulnerabilityAnalysisLevel()).isEqualTo("BOM_UPLOAD_ANALYSIS");
                }
                // INT-002 is discarded because it is internal but doesn't exist in the database.
        );
    }

    @Test
    public void processSuccessfulScanResultWithExistingFindingTest() {
        final var project = new Project();
        project.setName("acme-app");
        project.setVersion("1.0.0");
        qm.persist(project);

        final var component = new Component();
        component.setName("acme-lib");
        component.setVersion("1.1.0");
        component.setProject(project);
        qm.persist(component);

        final var vulnerability = new Vulnerability();
        vulnerability.setVulnId("CVE-001");
        vulnerability.setSource(Vulnerability.Source.NVD);
        qm.persist(vulnerability);
        qm.addVulnerability(vulnerability, component, AnalyzerIdentity.OSSINDEX_ANALYZER);

        final var scanToken = UUID.randomUUID().toString();
        final var scanKey = ScanKey.newBuilder().setScanToken(scanToken).setComponentUuid(component.getUuid().toString()).build();
        final var scanResult = ScanResult.newBuilder()
                .setKey(scanKey)
                .addScannerResults(ScannerResult.newBuilder()
                        .setScanner(SCANNER_INTERNAL)
                        .setStatus(SCAN_STATUS_SUCCESSFUL)
                        .setBom(Bom.newBuilder().addVulnerabilities(createVuln("CVE-001", "NVD"))))
                .build();

        inputTopic.pipeInput(scanKey, scanResult);

        qm.getPersistenceManager().refreshAll(component, vulnerability);
        assertThat(component.getVulnerabilities()).satisfiesExactly(
                vuln -> {
                    assertThat(vuln.getVulnId()).isEqualTo("CVE-001");
                    assertThat(vuln.getSource()).isEqualTo(Vulnerability.Source.NVD.name());
                }
        );

        // Attribution should still refer to the first scanner that identified the vulnerability.
        final FindingAttribution attribution = qm.getFindingAttribution(vulnerability, component);
        assertThat(attribution).isNotNull();
        assertThat(attribution.getAnalyzerIdentity()).isEqualTo(AnalyzerIdentity.OSSINDEX_ANALYZER);

        // Because the vulnerability was reported already, no notification must be sent.
        assertThat(kafkaMockProducer.history()).isEmpty();
    }

    private Object[] canUpdateExistingVulnerabilityTestParams() {
        return new Object[]{
                // Results from the internal scanner must never override any existing data.
                new Object[]{"INT-001", "INTERNAL", SCANNER_INTERNAL, null, null, false},
                new Object[]{"CVE-001", "NVD", SCANNER_INTERNAL, ConfigPropertyConstants.VULNERABILITY_SOURCE_NVD_ENABLED, "true", false},
                new Object[]{"CVE-001", "NVD", SCANNER_INTERNAL, ConfigPropertyConstants.VULNERABILITY_SOURCE_NVD_ENABLED, "false", false},
                new Object[]{"CVE-001", "NVD", SCANNER_INTERNAL, ConfigPropertyConstants.VULNERABILITY_SOURCE_NVD_ENABLED, null, false},
                new Object[]{"GHSA-001", "GITHUB", SCANNER_INTERNAL, ConfigPropertyConstants.VULNERABILITY_SOURCE_GITHUB_ADVISORIES_ENABLED, "true", false},
                new Object[]{"GHSA-001", "GITHUB", SCANNER_INTERNAL, ConfigPropertyConstants.VULNERABILITY_SOURCE_GITHUB_ADVISORIES_ENABLED, "false", false},
                new Object[]{"GHSA-001", "GITHUB", SCANNER_INTERNAL, ConfigPropertyConstants.VULNERABILITY_SOURCE_GITHUB_ADVISORIES_ENABLED, null, false},
                new Object[]{"OSV-001", "OSV", SCANNER_INTERNAL, ConfigPropertyConstants.VULNERABILITY_SOURCE_GOOGLE_OSV_ENABLED, "Go;Maven", false},
                new Object[]{"OSV-001", "OSV", SCANNER_INTERNAL, ConfigPropertyConstants.VULNERABILITY_SOURCE_GOOGLE_OSV_ENABLED, "", false},
                new Object[]{"OSV-001", "OSV", SCANNER_INTERNAL, ConfigPropertyConstants.VULNERABILITY_SOURCE_GOOGLE_OSV_ENABLED, null, false},
                new Object[]{"sonatype-001", "OSSINDEX", SCANNER_INTERNAL, null, null, false},
                new Object[]{"snyk-001", "SNYK", SCANNER_INTERNAL, null, null, false},
                new Object[]{"001", "VULNDB", SCANNER_INTERNAL, null, null, false},
                // Scanners must be allowed to override existing data if they themselves are the authoritative source,
                // or mirroring of the actual authoritative source is not enabled.
                new Object[]{"CVE-001", "NVD", SCANNER_OSSINDEX, ConfigPropertyConstants.VULNERABILITY_SOURCE_NVD_ENABLED, "true", false},
                new Object[]{"CVE-001", "NVD", SCANNER_OSSINDEX, ConfigPropertyConstants.VULNERABILITY_SOURCE_NVD_ENABLED, "false", true},
                new Object[]{"CVE-001", "NVD", SCANNER_OSSINDEX, ConfigPropertyConstants.VULNERABILITY_SOURCE_NVD_ENABLED, null, true},
                new Object[]{"GHSA-001", "GITHUB", SCANNER_OSSINDEX, ConfigPropertyConstants.VULNERABILITY_SOURCE_GITHUB_ADVISORIES_ENABLED, "true", false},
                new Object[]{"GHSA-001", "GITHUB", SCANNER_OSSINDEX, ConfigPropertyConstants.VULNERABILITY_SOURCE_GITHUB_ADVISORIES_ENABLED, "false", true},
                new Object[]{"GHSA-001", "GITHUB", SCANNER_OSSINDEX, ConfigPropertyConstants.VULNERABILITY_SOURCE_GITHUB_ADVISORIES_ENABLED, null, true},
                new Object[]{"OSV-001", "OSV", SCANNER_OSSINDEX, ConfigPropertyConstants.VULNERABILITY_SOURCE_GOOGLE_OSV_ENABLED, "Go;Maven", false},
                new Object[]{"OSV-001", "OSV", SCANNER_OSSINDEX, ConfigPropertyConstants.VULNERABILITY_SOURCE_GOOGLE_OSV_ENABLED, "", true},
                new Object[]{"OSV-001", "OSV", SCANNER_OSSINDEX, ConfigPropertyConstants.VULNERABILITY_SOURCE_GOOGLE_OSV_ENABLED, null, true},
                new Object[]{"sonatype-001", "OSSINDEX", SCANNER_OSSINDEX, null, null, true},
                new Object[]{"SNYK-001", "SNYK", SCANNER_OSSINDEX, null, null, false},
                new Object[]{"sonatype-001", "OSSINDEX", SCANNER_SNYK, null, null, false},
                new Object[]{"SNYK-001", "SNYK", SCANNER_SNYK, null, null, true},
                // Updating of internal vulnerabilities must always be forbidden.
                new Object[]{"INT-001", "INTERNAL", SCANNER_OSSINDEX, null, null, false},
                new Object[]{"INT-001", "INTERNAL", SCANNER_SNYK, null, null, false},
        };
    }

    @Test
    @Parameters(method = "canUpdateExistingVulnerabilityTestParams")
    public void canUpdateExistingVulnerabilityTest(final String vulnId, final String vulnSource, final Scanner scanner,
                                                   final ConfigPropertyConstants mirrorSourceConfigProperty,
                                                   final String mirrorSourceConfigPropertyValue, final boolean expectModified) {
        if (mirrorSourceConfigProperty != null && mirrorSourceConfigPropertyValue != null) {
            qm.createConfigProperty(
                    mirrorSourceConfigProperty.getGroupName(),
                    mirrorSourceConfigProperty.getPropertyName(),
                    mirrorSourceConfigPropertyValue,
                    mirrorSourceConfigProperty.getPropertyType(),
                    null
            );
        }

        final var project = new Project();
        project.setName("acme-app");
        project.setVersion("1.0.0");
        qm.persist(project);

        final var component = new Component();
        component.setName("acme-lib");
        component.setVersion("1.1.0");
        component.setProject(project);
        qm.persist(component);

        final var vulnerability = new Vulnerability();
        vulnerability.setVulnId(vulnId);
        vulnerability.setSource(vulnSource);
        vulnerability.setDescription("original description");
        qm.persist(vulnerability);

        final var scanToken = UUID.randomUUID().toString();
        final var scanKey = ScanKey.newBuilder().setScanToken(scanToken).setComponentUuid(component.getUuid().toString()).build();
        final var scanResult = ScanResult.newBuilder()
                .setKey(scanKey)
                .addScannerResults(ScannerResult.newBuilder()
                        .setScanner(scanner)
                        .setStatus(SCAN_STATUS_SUCCESSFUL)
                        .setBom(Bom.newBuilder().addVulnerabilities(
                                createVuln(vulnId, vulnSource).toBuilder().setDescription("modified description")
                                        .build())))
                .build();

        inputTopic.pipeInput(scanKey, scanResult);

        qm.getPersistenceManager().refreshAll(component, vulnerability);
        assertThat(component.getVulnerabilities()).satisfiesExactly(
                vuln -> {
                    assertThat(vuln.getVulnId()).isEqualTo(vulnId);
                    assertThat(vuln.getSource()).isEqualTo(vulnSource);
                    if (expectModified) {
                        assertThat(vuln.getDescription()).isEqualTo("modified description");
                    } else {
                        assertThat(vuln.getDescription()).isEqualTo("original description");
                    }
                }
        );
    }

    @Test
    public void updateExistingVulnerabilityTest() {
        final var project = new Project();
        project.setName("acme-app");
        project.setVersion("1.0.0");
        qm.persist(project);

        final var component = new Component();
        component.setName("acme-lib");
        component.setVersion("1.1.0");
        component.setProject(project);
        qm.persist(component);

        final var vulnerability = new Vulnerability();
        vulnerability.setVulnId("CVE-001");
        vulnerability.setSource(Vulnerability.Source.NVD);
        vulnerability.setTitle("original title");
        vulnerability.setSubTitle("original subTitle");
        vulnerability.setDescription("original description");
        vulnerability.setDetail("original detail");
        vulnerability.setRecommendation("original recommendation");
        vulnerability.setReferences("original references");
        vulnerability.setCreated(Date.from(Instant.ofEpochSecond(1672527600))); // Sat Dec 31 2022 23:00:00 GMT+0000
        vulnerability.setPublished(Date.from(Instant.ofEpochSecond(1672614000))); // Sun Jan 01 2023 23:00:00 GMT+0000
        vulnerability.setUpdated(Date.from(Instant.ofEpochSecond(1672700400))); // Mon Jan 02 2023 23:00:00 GMT+0000
        vulnerability.setCwes(List.of(666, 777));
        vulnerability.setSeverity(Severity.LOW);
        vulnerability.setCvssV2BaseScore(BigDecimal.valueOf(2.2));
        vulnerability.setCvssV2ExploitabilitySubScore(BigDecimal.valueOf(2.2));
        vulnerability.setCvssV2ImpactSubScore(BigDecimal.valueOf(2.3));
        vulnerability.setCvssV2Vector("original cvssV2Vector");
        vulnerability.setCvssV3BaseScore(BigDecimal.valueOf(3.1));
        vulnerability.setCvssV3ExploitabilitySubScore(BigDecimal.valueOf(3.2));
        vulnerability.setCvssV3ImpactSubScore(BigDecimal.valueOf(3.3));
        vulnerability.setCvssV3Vector("original cvssv3Vector");
        vulnerability.setOwaspRRLikelihoodScore(BigDecimal.valueOf(4.1));
        vulnerability.setOwaspRRTechnicalImpactScore(BigDecimal.valueOf(4.2));
        vulnerability.setOwaspRRBusinessImpactScore(BigDecimal.valueOf(4.3));
        vulnerability.setOwaspRRVector("original owaspRrVector");
        vulnerability.setVulnerableVersions("original vulnerableVersions");
        vulnerability.setPatchedVersions("original patchedVersions");
        vulnerability.setEpssScore(BigDecimal.valueOf(5.1));
        vulnerability.setEpssPercentile(BigDecimal.valueOf(5.2));
        qm.persist(vulnerability);

        final var scanToken = UUID.randomUUID().toString();
        final var scanKey = ScanKey.newBuilder().setScanToken(scanToken).setComponentUuid(component.getUuid().toString()).build();
        final var scanResult = ScanResult.newBuilder()
                .setKey(scanKey)
                .addScannerResults(ScannerResult.newBuilder()
                        .setScanner(SCANNER_OSSINDEX)
                        .setStatus(SCAN_STATUS_SUCCESSFUL)
                        .setBom(Bom.newBuilder().addVulnerabilities(
                                createVuln("CVE-001", "NVD").toBuilder()
                                        .setDescription("modified description")
                                        .setDetail("modified detail")
                                        .setRecommendation("modified recommendation")
                                        .setCreated(Timestamp.newBuilder()
                                                .setSeconds(1673305200)) // Mon Jan 09 2023 23:00:00 GMT+0000
                                        .setPublished(Timestamp.newBuilder()
                                                .setSeconds(1673391600)) // Tue Jan 10 2023 23:00:00 GMT+0000
                                        .setUpdated(Timestamp.newBuilder()
                                                .setSeconds(1673478000)) // Wed Jan 11 2023 23:00:00 GMT+0000
                                        .addCwes(999)
                                        .addAdvisories(Advisory.newBuilder().setUrl("modified reference").build())
                                        .addRatings(VulnerabilityRating.newBuilder()
                                                .setSource(Source.newBuilder().setName("NVD").build())
                                                .setMethod(SCORE_METHOD_CVSSV2)
                                                .setScore(9.3)
                                                .setVector("(AV:N/AC:M/Au:N/C:C/I:C/A:C)"))
                                        .addRatings(VulnerabilityRating.newBuilder()
                                                .setSource(Source.newBuilder().setName("NVD").build())
                                                .setMethod(SCORE_METHOD_CVSSV3)
                                                .setScore(10.0)
                                                .setVector("CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H"))
                                        .addRatings(VulnerabilityRating.newBuilder()
                                                .setSource(Source.newBuilder().setName("OSSINDEX").build())
                                                .setMethod(SCORE_METHOD_OWASP)
                                                .setScore(6.6)
                                                .setVector("SL:1/M:4/O:4/S:9/ED:7/EE:3/A:4/ID:3/LC:9/LI:1/LAV:5/LAC:1/FD:3/RD:4/NC:7/PV:9"))
                                        .addProperties(Property.newBuilder()
                                                .setName("dependency-track:vuln:title")
                                                .setValue("modified title").build())
                                        .build())))
                .build();

        inputTopic.pipeInput(scanKey, scanResult);

        qm.getPersistenceManager().refreshAll(component, vulnerability);
        assertThat(component.getVulnerabilities()).hasSize(1);

        assertThat(vulnerability.getVulnId()).isEqualTo("CVE-001");
        assertThat(vulnerability.getSource()).isEqualTo("NVD");
        assertThat(vulnerability.getDescription()).isEqualTo("modified description");
        assertThat(vulnerability.getDetail()).isEqualTo("modified detail");
        assertThat(vulnerability.getTitle()).isEqualTo("modified title");
        assertThat(vulnerability.getSubTitle()).isNull();
        assertThat(vulnerability.getRecommendation()).isEqualTo("modified recommendation");
        assertThat(vulnerability.getReferences()).isEqualTo("* [modified reference](modified reference)\n");
        assertThat(vulnerability.getCreated()).isEqualTo(Instant.ofEpochSecond(1673305200));
        assertThat(vulnerability.getPublished()).isEqualTo(Instant.ofEpochSecond(1673391600));
        assertThat(vulnerability.getUpdated()).isEqualTo(Instant.ofEpochSecond(1673478000));
        assertThat(vulnerability.getCwes()).containsOnly(999);
        assertThat(vulnerability.getSeverity()).isEqualTo(Severity.CRITICAL);
        assertThat(vulnerability.getCvssV2BaseScore()).isEqualTo("9.3");
        assertThat(vulnerability.getCvssV2ExploitabilitySubScore()).isEqualTo("8.6");
        assertThat(vulnerability.getCvssV2ImpactSubScore()).isEqualTo("10.0");
        assertThat(vulnerability.getCvssV2Vector()).isEqualTo("(AV:N/AC:M/Au:N/C:C/I:C/A:C)");
        assertThat(vulnerability.getCvssV3BaseScore()).isEqualTo("10.0");
        assertThat(vulnerability.getCvssV3ExploitabilitySubScore()).isEqualTo("3.9");
        assertThat(vulnerability.getCvssV3ImpactSubScore()).isEqualTo("6.0");
        assertThat(vulnerability.getCvssV3Vector()).isEqualTo("CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H");
        assertThat(vulnerability.getOwaspRRLikelihoodScore()).isEqualTo("4.375");
        assertThat(vulnerability.getOwaspRRTechnicalImpactScore()).isEqualTo("4.0");
        assertThat(vulnerability.getOwaspRRBusinessImpactScore()).isEqualTo("5.75");
        assertThat(vulnerability.getOwaspRRVector()).isEqualTo("SL:1/M:4/O:4/S:9/ED:7/EE:3/A:4/ID:3/LC:9/LI:1/LAV:5/LAC:1/FD:3/RD:4/NC:7/PV:9");
        assertThat(vulnerability.getVulnerableVersions()).isNull();
        assertThat(vulnerability.getPatchedVersions()).isNull();
        assertThat(vulnerability.getEpssScore()).isEqualByComparingTo("5.1");
        assertThat(vulnerability.getEpssPercentile()).isEqualByComparingTo("5.2");
    }

    @Test
    public void analysisThroughPolicyNewAnalysisTest() {
        final var project = new Project();
        project.setName("acme-app");
        project.setVersion("1.0.0");
        qm.persist(project);

        final var component = new Component();
        component.setName("acme-lib");
        component.setVersion("1.1.0");
        component.setProject(project);
        qm.persist(component);

        // Create a vulnerability that was not previously reported for the component.
        final var newVuln = new Vulnerability();
        newVuln.setVulnId("CVE-100");
        newVuln.setSource(Vulnerability.Source.NVD);
        newVuln.setSeverity(Severity.CRITICAL);
        qm.persist(newVuln);

        // Create a policy that marks any finding as NOT_AFFECTED, and downgrades the severity to LOW.
        final var policyAnalysis = new VulnerabilityPolicyAnalysis();
        policyAnalysis.setState(VulnerabilityPolicyAnalysis.State.NOT_AFFECTED);
        policyAnalysis.setJustification(VulnerabilityPolicyAnalysis.Justification.CODE_NOT_REACHABLE);
        policyAnalysis.setVendorResponse(VulnerabilityPolicyAnalysis.Response.WILL_NOT_FIX);
        policyAnalysis.setDetails("Because I say so.");
        final var policyRating = new VulnerabilityPolicyRating();
        policyRating.setMethod(VulnerabilityPolicyRating.Method.CVSSV3);
        policyRating.setSeverity(VulnerabilityPolicyRating.Severity.LOW);
        policyRating.setVector("CVSS:3.0/AV:P/AC:H/PR:H/UI:R/S:U/C:N/I:N/A:L");
        policyRating.setScore(1.6);
        final var policy = new VulnerabilityPolicy();
        policy.setName("Foo");
        policy.setAuthor("Jane Doe");
        policy.setConditions(new String[]{"has(component.name)", "project.version != \"\""});
        policy.setAnalysis(policyAnalysis);
        policy.setRatings(List.of(policyRating));
        qm.createVulnerabilityPolicy(policy, null);

        final var componentUuid = component.getUuid();
        final var scanToken = UUID.randomUUID().toString();
        final var scanKey = ScanKey.newBuilder().setScanToken(scanToken).setComponentUuid(componentUuid.toString()).build();
        final var scanResult = ScanResult.newBuilder()
                .setKey(scanKey)
                .addScannerResults(ScannerResult.newBuilder()
                        .setScanner(SCANNER_INTERNAL)
                        .setStatus(SCAN_STATUS_SUCCESSFUL)
                        .setBom(Bom.newBuilder().addAllVulnerabilities(List.of(
                                createVuln(newVuln.getVulnId(), newVuln.getSource())
                        ))))
                .build();
        inputTopic.pipeInput(new TestRecord<>(scanKey, scanResult));
        assertThat(outputTopic.readValuesToList()).containsOnly(scanResult);

        qm.getPersistenceManager().evictAll();
        assertThat(component.getVulnerabilities()).satisfiesExactly(
                v -> {
                    assertThat(v.getVulnId()).isEqualTo("CVE-100");
                    assertThat(qm.getAnalysis(component, v)).satisfies(analysis -> {
                        assertThat(analysis.getAnalysisState()).isEqualTo(AnalysisState.NOT_AFFECTED);
                        assertThat(analysis.getAnalysisJustification()).isEqualTo(AnalysisJustification.CODE_NOT_REACHABLE);
                        assertThat(analysis.getAnalysisResponse()).isEqualTo(AnalysisResponse.WILL_NOT_FIX);
                        assertThat(analysis.getAnalysisDetails()).isEqualTo("Because I say so.");
                        assertThat(analysis.isSuppressed()).isFalse();
                        assertThat(analysis.getSeverity()).isEqualTo(Severity.LOW);
                        assertThat(analysis.getCvssV2Vector()).isNull();
                        assertThat(analysis.getCvssV2Score()).isNull();
                        assertThat(analysis.getCvssV3Vector()).isEqualTo("CVSS:3.0/AV:P/AC:H/PR:H/UI:R/S:U/C:N/I:N/A:L");
                        assertThat(analysis.getCvssV3Score()).isEqualByComparingTo("1.6");
                        assertThat(analysis.getOwaspVector()).isNull();
                        assertThat(analysis.getOwaspScore()).isNull();

                        assertThat(analysis.getAnalysisComments()).extracting(AnalysisComment::getCommenter).containsOnly("[Policy{Name=Foo, Author=Jane Doe}]");
                        assertThat(analysis.getAnalysisComments()).extracting(AnalysisComment::getComment).containsExactly(
                                "Matched on condition(s):\n- has(component.name)\n- project.version != \"\"",
                                "Analysis: NOT_SET → NOT_AFFECTED",
                                "Justification: NOT_SET → CODE_NOT_REACHABLE",
                                "Vendor Response: NOT_SET → WILL_NOT_FIX",
                                "Details: Because I say so.",
                                "Severity: CRITICAL → LOW",
                                "CVSSv3 Vector: (None) → CVSS:3.0/AV:P/AC:H/PR:H/UI:R/S:U/C:N/I:N/A:L",
                                "CVSSv3 Score: (None) → 1.6"
                        );
                    });
                });

        // TODO: There should be PROJECT_AUDIT_CHANGE notifications.
        assertThat(kafkaMockProducer.history()).satisfiesExactly(
                record -> {
                    assertThat(record.topic()).isEqualTo(KafkaTopics.NOTIFICATION_NEW_VULNERABILITY.name());
                    final Notification notification = deserializeValue(KafkaTopics.NOTIFICATION_NEW_VULNERABILITY, record);
                    assertThat(notification.getScope()).isEqualTo(SCOPE_PORTFOLIO);
                    assertThat(notification.getLevel()).isEqualTo(LEVEL_INFORMATIONAL);
                    assertThat(notification.getGroup()).isEqualTo(GROUP_NEW_VULNERABILITY);
                    assertThat(notification.getSubject().is(NewVulnerabilitySubject.class)).isTrue();
                    final var subject = notification.getSubject().unpack(NewVulnerabilitySubject.class);
                    assertThat(subject.getVulnerability().getVulnId()).isEqualTo("CVE-100");
                    assertThat(subject.getVulnerability().getSource()).isEqualTo("NVD");
                    assertThat(subject.getVulnerability().getSeverity()).isEqualTo("LOW");
                    assertThat(subject.getVulnerability().getCvssV3()).isEqualTo(1.6);
                }
        );
    }

    @Test
    public void analysisThroughPolicyNewAnalysisSuppressionTest() {
        final var project = new Project();
        project.setName("acme-app");
        project.setVersion("1.0.0");
        qm.persist(project);

        final var component = new Component();
        component.setName("acme-lib");
        component.setVersion("1.1.0");
        component.setProject(project);
        qm.persist(component);

        // Create a vulnerability that was not previously reported for the component.
        final var newVuln = new Vulnerability();
        newVuln.setVulnId("CVE-100");
        newVuln.setSource(Vulnerability.Source.NVD);
        newVuln.setSeverity(Severity.CRITICAL);
        qm.persist(newVuln);

        // Create a policy that marks any finding as FALSE_POSITIVE, and suppresses it.
        final var policyAnalysis = new VulnerabilityPolicyAnalysis();
        policyAnalysis.setState(VulnerabilityPolicyAnalysis.State.FALSE_POSITIVE);
        policyAnalysis.setSuppress(true);
        final var policy = new VulnerabilityPolicy();
        policy.setName("Foo");
        policy.setAuthor("Jane Doe");
        policy.setConditions(new String[]{"has(component.name)", "project.version != \"\""});
        policy.setAnalysis(policyAnalysis);
        qm.createVulnerabilityPolicy(policy, null);

        final var componentUuid = component.getUuid();
        final var scanToken = UUID.randomUUID().toString();
        final var scanKey = ScanKey.newBuilder().setScanToken(scanToken).setComponentUuid(componentUuid.toString()).build();
        final var scanResult = ScanResult.newBuilder()
                .setKey(scanKey)
                .addScannerResults(ScannerResult.newBuilder()
                        .setScanner(SCANNER_INTERNAL)
                        .setStatus(SCAN_STATUS_SUCCESSFUL)
                        .setBom(Bom.newBuilder().addAllVulnerabilities(List.of(
                                createVuln(newVuln.getVulnId(), newVuln.getSource())
                        ))))
                .build();
        inputTopic.pipeInput(new TestRecord<>(scanKey, scanResult));
        assertThat(outputTopic.readValuesToList()).containsOnly(scanResult);

        qm.getPersistenceManager().evictAll();
        assertThat(component.getVulnerabilities()).satisfiesExactly(
                v -> {
                    assertThat(v.getVulnId()).isEqualTo("CVE-100");
                    assertThat(qm.getAnalysis(component, v)).satisfies(analysis -> {
                        assertThat(analysis.getAnalysisState()).isEqualTo(AnalysisState.FALSE_POSITIVE);
                        assertThat(analysis.getAnalysisJustification()).isNull();
                        assertThat(analysis.getAnalysisResponse()).isNull();
                        assertThat(analysis.getAnalysisDetails()).isNull();
                        assertThat(analysis.isSuppressed()).isTrue();
                        assertThat(analysis.getSeverity()).isNull();
                        assertThat(analysis.getCvssV2Vector()).isNull();
                        assertThat(analysis.getCvssV2Score()).isNull();
                        assertThat(analysis.getCvssV3Vector()).isNull();
                        assertThat(analysis.getCvssV3Score()).isNull();
                        assertThat(analysis.getOwaspVector()).isNull();
                        assertThat(analysis.getOwaspScore()).isNull();

                        assertThat(analysis.getAnalysisComments()).extracting(AnalysisComment::getCommenter).containsOnly("[Policy{Name=Foo, Author=Jane Doe}]");
                        assertThat(analysis.getAnalysisComments()).extracting(AnalysisComment::getComment).containsExactly(
                                "Matched on condition(s):\n- has(component.name)\n- project.version != \"\"",
                                "Analysis: NOT_SET → FALSE_POSITIVE",
                                "Suppressed"
                        );
                    });
                });

        // The vulnerability was suppressed, so no notifications to be expected.
        // TODO: There should be PROJECT_AUDIT_CHANGE notifications.
        assertThat(kafkaMockProducer.history()).isEmpty();
    }

    @Test
    public void analysisThroughPolicyExistingDifferentAnalysisTest() {
        final var project = new Project();
        project.setName("acme-app");
        project.setVersion("1.0.0");
        qm.persist(project);

        final var component = new Component();
        component.setName("acme-lib");
        component.setVersion("1.1.0");
        component.setProject(project);
        qm.persist(component);

        // Create an existing vulnerability, for which the analysis is entirely different
        // over what's defined in the policy.
        final var vuln = new Vulnerability();
        vuln.setVulnId("CVE-100");
        vuln.setSource(Vulnerability.Source.NVD);
        vuln.setSeverity(Severity.CRITICAL);
        qm.persist(vuln);
        qm.addVulnerability(vuln, component, AnalyzerIdentity.INTERNAL_ANALYZER);
        final Analysis vulnAnalysis = qm.makeAnalysis(component, vuln, AnalysisState.FALSE_POSITIVE,
                AnalysisJustification.NOT_SET, AnalysisResponse.CAN_NOT_FIX, "oldDetails", true);
        vulnAnalysis.setSeverity(Severity.INFO);
        vulnAnalysis.setCvssV2Vector("oldCvssV2Vector");
        vulnAnalysis.setCvssV2Score(BigDecimal.ZERO);
        vulnAnalysis.setCvssV3Vector("oldCvssV3Vector");
        vulnAnalysis.setCvssV3Score(BigDecimal.ZERO);
        vulnAnalysis.setOwaspVector("oldOwaspVector");
        vulnAnalysis.setOwaspScore(BigDecimal.ZERO);
        qm.persist(vulnAnalysis);

        // Create a policy that marks any finding as NOT_AFFECTED, and downgrades the severity to LOW.
        final var policyAnalysis = new VulnerabilityPolicyAnalysis();
        policyAnalysis.setState(VulnerabilityPolicyAnalysis.State.NOT_AFFECTED);
        policyAnalysis.setJustification(VulnerabilityPolicyAnalysis.Justification.CODE_NOT_REACHABLE);
        policyAnalysis.setVendorResponse(VulnerabilityPolicyAnalysis.Response.WILL_NOT_FIX);
        policyAnalysis.setDetails("Because I say so.");
        final var policyRating = new VulnerabilityPolicyRating();
        policyRating.setMethod(VulnerabilityPolicyRating.Method.CVSSV3);
        policyRating.setSeverity(VulnerabilityPolicyRating.Severity.LOW);
        policyRating.setVector("CVSS:3.0/AV:P/AC:H/PR:H/UI:R/S:U/C:N/I:N/A:L");
        policyRating.setScore(1.6);
        final var policy = new VulnerabilityPolicy();
        policy.setName("Foo");
        policy.setAuthor("Jane Doe");
        policy.setConditions(new String[]{"has(component.name)", "project.version != \"\""});
        policy.setAnalysis(policyAnalysis);
        policy.setRatings(List.of(policyRating));
        qm.createVulnerabilityPolicy(policy, null);

        final var componentUuid = component.getUuid();
        final var scanToken = UUID.randomUUID().toString();
        final var scanKey = ScanKey.newBuilder().setScanToken(scanToken).setComponentUuid(componentUuid.toString()).build();
        final var scanResult = ScanResult.newBuilder()
                .setKey(scanKey)
                .addScannerResults(ScannerResult.newBuilder()
                        .setScanner(SCANNER_INTERNAL)
                        .setStatus(SCAN_STATUS_SUCCESSFUL)
                        .setBom(Bom.newBuilder().addAllVulnerabilities(List.of(
                                createVuln(vuln.getVulnId(), vuln.getSource())
                        ))))
                .build();
        inputTopic.pipeInput(new TestRecord<>(scanKey, scanResult));
        assertThat(outputTopic.readValuesToList()).containsOnly(scanResult);

        qm.getPersistenceManager().evictAll();
        assertThat(component.getVulnerabilities()).satisfiesExactly(
                v -> {
                    assertThat(v.getVulnId()).isEqualTo("CVE-100");
                    assertThat(qm.getAnalysis(component, v)).satisfies(analysis -> {
                        assertThat(analysis.getAnalysisState()).isEqualTo(AnalysisState.NOT_AFFECTED);
                        assertThat(analysis.getAnalysisJustification()).isEqualTo(AnalysisJustification.CODE_NOT_REACHABLE);
                        assertThat(analysis.getAnalysisResponse()).isEqualTo(AnalysisResponse.WILL_NOT_FIX);
                        assertThat(analysis.getAnalysisDetails()).isEqualTo("Because I say so.");
                        assertThat(analysis.isSuppressed()).isFalse();
                        assertThat(analysis.getSeverity()).isEqualTo(Severity.LOW);
                        assertThat(analysis.getCvssV2Vector()).isNull();
                        assertThat(analysis.getCvssV2Score()).isNull();
                        assertThat(analysis.getCvssV3Vector()).isEqualTo("CVSS:3.0/AV:P/AC:H/PR:H/UI:R/S:U/C:N/I:N/A:L");
                        assertThat(analysis.getCvssV3Score()).isEqualByComparingTo("1.6");
                        assertThat(analysis.getOwaspVector()).isNull();
                        assertThat(analysis.getOwaspScore()).isNull();

                        assertThat(analysis.getAnalysisComments()).extracting(AnalysisComment::getCommenter).containsOnly("[Policy{Name=Foo, Author=Jane Doe}]");
                        assertThat(analysis.getAnalysisComments()).extracting(AnalysisComment::getComment).containsExactly(
                                "Matched on condition(s):\n- has(component.name)\n- project.version != \"\"",
                                "Analysis: FALSE_POSITIVE → NOT_AFFECTED",
                                "Justification: NOT_SET → CODE_NOT_REACHABLE",
                                "Vendor Response: CAN_NOT_FIX → WILL_NOT_FIX",
                                "Details: Because I say so.",
                                "Unsuppressed",
                                "Severity: INFO → LOW",
                                "CVSSv2 Vector: oldCvssV2Vector → (None)",
                                "CVSSv2 Score: 0.0 → (None)",
                                "CVSSv3 Vector: oldCvssV3Vector → CVSS:3.0/AV:P/AC:H/PR:H/UI:R/S:U/C:N/I:N/A:L",
                                "CVSSv3 Score: 0.0 → 1.6",
                                "OWASP Vector: oldOwaspVector → (None)",
                                "OWASP Score: 0.0 → (None)"
                        );
                    });
                });

        // The vulnerability already existed, so no notifications to be expected.
        // There should be PROJECT_AUDIT_CHANGE notification.
        assertThat(kafkaMockProducer.history()).satisfiesExactly(
                record -> {
                    assertThat(record.topic()).isEqualTo(KafkaTopics.NOTIFICATION_PROJECT_AUDIT_CHANGE.name());
                    final Notification notification = deserializeValue(KafkaTopics.NOTIFICATION_PROJECT_AUDIT_CHANGE, record);
                    assertThat(notification.getScope()).isEqualTo(SCOPE_PORTFOLIO);
                    assertThat(notification.getLevel()).isEqualTo(LEVEL_INFORMATIONAL);
                    assertThat(notification.getGroup()).isEqualTo(GROUP_PROJECT_AUDIT_CHANGE);
                    assertThat(notification.getSubject().is(VulnerabilityAnalysisDecisionChangeSubject.class)).isTrue();
                    final var subject = notification.getSubject().unpack(VulnerabilityAnalysisDecisionChangeSubject.class);
                    assertThat(subject.getAnalysis().getState()).isEqualTo("NOT_AFFECTED");
                }
        );
    }

    @Test
    public void analysisThroughPolicyExistingEqualAnalysisTest() {
        final var project = new Project();
        project.setName("acme-app");
        project.setVersion("1.0.0");
        qm.persist(project);

        final var component = new Component();
        component.setName("acme-lib");
        component.setVersion("1.1.0");
        component.setProject(project);
        qm.persist(component);

        // Create an existing vulnerability, for which the analysis is completely
        // identical to what's defined in the policy.
        final var vuln = new Vulnerability();
        vuln.setVulnId("CVE-100");
        vuln.setSource(Vulnerability.Source.NVD);
        vuln.setSeverity(Severity.CRITICAL);
        qm.persist(vuln);
        qm.addVulnerability(vuln, component, AnalyzerIdentity.INTERNAL_ANALYZER);
        final Analysis vulnAnalysis = qm.makeAnalysis(component, vuln, AnalysisState.NOT_AFFECTED,
                AnalysisJustification.CODE_NOT_REACHABLE, AnalysisResponse.WILL_NOT_FIX, "Because I say so.", false);
        vulnAnalysis.setSeverity(Severity.LOW);
        vulnAnalysis.setCvssV3Vector("CVSS:3.0/AV:P/AC:H/PR:H/UI:R/S:U/C:N/I:N/A:L");
        vulnAnalysis.setCvssV3Score(BigDecimal.valueOf(1.6));
        qm.persist(vulnAnalysis);

        // Create a policy that marks any finding as NOT_AFFECTED, and downgrades the severity to LOW.
        final var policyAnalysis = new VulnerabilityPolicyAnalysis();
        policyAnalysis.setState(VulnerabilityPolicyAnalysis.State.NOT_AFFECTED);
        policyAnalysis.setJustification(VulnerabilityPolicyAnalysis.Justification.CODE_NOT_REACHABLE);
        policyAnalysis.setVendorResponse(VulnerabilityPolicyAnalysis.Response.WILL_NOT_FIX);
        policyAnalysis.setDetails("Because I say so.");
        final var policyRating = new VulnerabilityPolicyRating();
        policyRating.setMethod(VulnerabilityPolicyRating.Method.CVSSV3);
        policyRating.setSeverity(VulnerabilityPolicyRating.Severity.LOW);
        policyRating.setVector("CVSS:3.0/AV:P/AC:H/PR:H/UI:R/S:U/C:N/I:N/A:L");
        policyRating.setScore(1.6);
        final var policy = new VulnerabilityPolicy();
        policy.setName("Foo");
        policy.setConditions(new String[]{"has(component.name)", "project.version != \"\""});
        policy.setAnalysis(policyAnalysis);
        policy.setRatings(List.of(policyRating));
        qm.createVulnerabilityPolicy(policy, null);

        final var componentUuid = component.getUuid();
        final var scanToken = UUID.randomUUID().toString();
        final var scanKey = ScanKey.newBuilder().setScanToken(scanToken).setComponentUuid(componentUuid.toString()).build();
        final var scanResult = ScanResult.newBuilder()
                .setKey(scanKey)
                .addScannerResults(ScannerResult.newBuilder()
                        .setScanner(SCANNER_INTERNAL)
                        .setStatus(SCAN_STATUS_SUCCESSFUL)
                        .setBom(Bom.newBuilder().addAllVulnerabilities(List.of(
                                createVuln(vuln.getVulnId(), vuln.getSource())
                        ))))
                .build();
        inputTopic.pipeInput(new TestRecord<>(scanKey, scanResult));
        assertThat(outputTopic.readValuesToList()).containsOnly(scanResult);

        qm.getPersistenceManager().evictAll();
        assertThat(component.getVulnerabilities()).satisfiesExactly(
                v -> {
                    assertThat(v.getVulnId()).isEqualTo("CVE-100");
                    assertThat(qm.getAnalysis(component, v)).satisfies(analysis -> {
                        assertThat(analysis.getAnalysisState()).isEqualTo(AnalysisState.NOT_AFFECTED);
                        assertThat(analysis.getAnalysisJustification()).isEqualTo(AnalysisJustification.CODE_NOT_REACHABLE);
                        assertThat(analysis.getAnalysisResponse()).isEqualTo(AnalysisResponse.WILL_NOT_FIX);
                        assertThat(analysis.getAnalysisDetails()).isEqualTo("Because I say so.");
                        assertThat(analysis.isSuppressed()).isFalse();
                        assertThat(analysis.getSeverity()).isEqualTo(Severity.LOW);
                        assertThat(analysis.getCvssV2Vector()).isNull();
                        assertThat(analysis.getCvssV2Score()).isNull();
                        assertThat(analysis.getCvssV3Vector()).isEqualTo("CVSS:3.0/AV:P/AC:H/PR:H/UI:R/S:U/C:N/I:N/A:L");
                        assertThat(analysis.getCvssV3Score()).isEqualByComparingTo("1.6");
                        assertThat(analysis.getOwaspVector()).isNull();
                        assertThat(analysis.getOwaspScore()).isNull();

                        // As no changes were made, no analysis comments should've been created.
                        assertThat(analysis.getAnalysisComments()).isEmpty();
                    });
                });

        // The vulnerability already existed, so no notifications to be expected.
        assertThat(kafkaMockProducer.history()).isEmpty();
    }

    @Test
    public void analysisThroughPolicyWithAliasesTest() {
        final var project = new Project();
        project.setName("acme-app");
        project.setVersion("1.0.0");
        qm.persist(project);

        final var component = new Component();
        component.setName("acme-lib");
        component.setVersion("1.1.0");
        component.setProject(project);
        qm.persist(component);

        // Create a vulnerability for which no aliases are currently known.
        // Aliases will be reported by the ScanResult.
        final var vulnA = new Vulnerability();
        vulnA.setVulnId("CVE-100");
        vulnA.setSource(Vulnerability.Source.NVD);
        qm.persist(vulnA);

        // Create a vulnerability for which an alias is already known.
        // The same alias will be reported by the ScanResult.
        final var vulnB = new Vulnerability();
        vulnB.setVulnId("CVE-200");
        vulnB.setSource(Vulnerability.Source.NVD);
        qm.persist(vulnB);
        final var vulnAliasB = new VulnerabilityAlias();
        vulnAliasB.setCveId("CVE-200");
        vulnAliasB.setGhsaId("GHSA-200");
        qm.synchronizeVulnerabilityAlias(vulnAliasB);

        // Create a policy that suppresses any finding with the alias GHSA-100 or GHSA-200.
        final var policyAnalysis = new VulnerabilityPolicyAnalysis();
        policyAnalysis.setState(VulnerabilityPolicyAnalysis.State.FALSE_POSITIVE);
        policyAnalysis.setSuppress(true);
        final var policy = new VulnerabilityPolicy();
        policy.setName("Foo");
        policy.setConditions(new String[]{"vuln.aliases.exists(alias, alias.id == \"GHSA-100\" || alias.id == \"GHSA-200\")"});
        policy.setAnalysis(policyAnalysis);
        qm.createVulnerabilityPolicy(policy, null);

        // Report three vulnerabilities for the component:
        // - CVE-100 with alias GHSA-100 (vuln already in DB, alias is new)
        // - CVE-200 with alias GHSA-200 (vuln and alias already in DB)
        // - CVE-300 without alias (vuln already in DB)
        final var componentUuid = component.getUuid();
        final var scanToken = UUID.randomUUID().toString();
        final var scanKey = ScanKey.newBuilder().setScanToken(scanToken).setComponentUuid(componentUuid.toString()).build();
        final var scanResult = ScanResult.newBuilder()
                .setKey(scanKey)
                .addScannerResults(ScannerResult.newBuilder()
                        .setScanner(SCANNER_INTERNAL)
                        .setStatus(SCAN_STATUS_SUCCESSFUL)
                        .setBom(Bom.newBuilder().addAllVulnerabilities(List.of(
                                org.cyclonedx.proto.v1_4.Vulnerability.newBuilder()
                                        .setId("CVE-100")
                                        .setSource(Source.newBuilder().setName("NVD"))
                                        .addReferences(VulnerabilityReference.newBuilder()
                                                .setId("GHSA-100")
                                                .setSource(Source.newBuilder().setName("GITHUB")))
                                        .build(),
                                org.cyclonedx.proto.v1_4.Vulnerability.newBuilder()
                                        .setId("CVE-200")
                                        .setSource(Source.newBuilder().setName("NVD"))
                                        .addReferences(VulnerabilityReference.newBuilder()
                                                .setId("GHSA-200")
                                                .setSource(Source.newBuilder().setName("GITHUB")))
                                        .build(),
                                org.cyclonedx.proto.v1_4.Vulnerability.newBuilder()
                                        .setId("CVE-300")
                                        .setSource(Source.newBuilder().setName("NVD"))
                                        .build()
                        ))))
                .build();
        inputTopic.pipeInput(new TestRecord<>(scanKey, scanResult));
        assertThat(outputTopic.readValuesToList()).containsOnly(scanResult);

        qm.getPersistenceManager().evictAll();
        assertThat(component.getVulnerabilities()).satisfiesExactlyInAnyOrder(
                v -> {
                    assertThat(v.getVulnId()).isEqualTo("CVE-100");
                    assertThat(qm.getAnalysis(component, v)).satisfies(analysis -> {
                        assertThat(analysis.getAnalysisState()).isEqualTo(AnalysisState.FALSE_POSITIVE);
                        assertThat(analysis.isSuppressed()).isTrue();
                    });
                },
                v -> {
                    assertThat(v.getVulnId()).isEqualTo("CVE-200");
                    assertThat(qm.getAnalysis(component, v)).satisfies(analysis -> {
                        assertThat(analysis.getAnalysisState()).isEqualTo(AnalysisState.FALSE_POSITIVE);
                        assertThat(analysis.isSuppressed()).isTrue();
                    });
                },
                v -> {
                    assertThat(v.getVulnId()).isEqualTo("CVE-300");
                    assertThat(qm.getAnalysis(component, v)).isNull();
                }
        );
    }

    @Test
    public void analysisThroughPolicyResetOnNoMatchTest() {
        final var project = new Project();
        project.setName("acme-app");
        project.setVersion("1.0.0");
        qm.persist(project);

        final var component = new Component();
        component.setName("acme-lib");
        component.setVersion("1.1.0");
        component.setProject(project);
        qm.persist(component);

        final var policyAnalysis = new VulnerabilityPolicyAnalysis();
        policyAnalysis.setState(VulnerabilityPolicyAnalysis.State.FALSE_POSITIVE);
        policyAnalysis.setJustification(VulnerabilityPolicyAnalysis.Justification.CODE_NOT_REACHABLE);
        policyAnalysis.setVendorResponse(VulnerabilityPolicyAnalysis.Response.WILL_NOT_FIX);
        policyAnalysis.setSuppress(true);
        final var policy = new VulnerabilityPolicy();
        policy.setName("Foo");
        policy.setConditions(new String[]{"component.name == \"some-other-name\""});
        policy.setAnalysis(policyAnalysis);
        qm.createVulnerabilityPolicy(policy, null);

        // Create vulnerability with existing analysis that was previously applied by the above policy,
        // but is no longer current.
        final var vulnA = new Vulnerability();
        vulnA.setVulnId("CVE-100");
        vulnA.setSource(Vulnerability.Source.NVD);
        vulnA.setSeverity(Severity.CRITICAL);
        qm.persist(vulnA);
        qm.addVulnerability(vulnA, component, AnalyzerIdentity.INTERNAL_ANALYZER);
        final var analysisA = new Analysis();
        analysisA.setComponent(component);
        analysisA.setVulnerability(vulnA);
        analysisA.setAnalysisState(AnalysisState.NOT_AFFECTED);
        analysisA.setAnalysisJustification(AnalysisJustification.CODE_NOT_REACHABLE);
        analysisA.setAnalysisResponse(AnalysisResponse.WILL_NOT_FIX);
        analysisA.setAnalysisDetails("Because I say so.");
        analysisA.setSeverity(Severity.MEDIUM);
        analysisA.setCvssV2Vector("oldCvssV2Vector");
        analysisA.setCvssV2Score(BigDecimal.valueOf(1.1));
        analysisA.setCvssV3Vector("oldCvssV3Vector");
        analysisA.setCvssV3Score(BigDecimal.valueOf(2.2));
        analysisA.setOwaspVector("oldOwaspVector");
        analysisA.setOwaspScore(BigDecimal.valueOf(3.3));
        analysisA.setSuppressed(true);
        qm.getPersistenceManager().makePersistent(analysisA);
        jdbi(qm).useHandle(jdbiHandle -> jdbiHandle.createUpdate("""
                        UPDATE
                          "ANALYSIS"
                        SET
                          "VULNERABILITY_POLICY_ID" = (SELECT "ID" FROM "VULNERABILITY_POLICY" WHERE "NAME" = :vulnPolicyName)
                        WHERE
                          "ID" = :analysisId
                        """)
                .bind("vulnPolicyName", policy.getName())
                .bind("analysisId", analysisA.getId())
                .execute());

        // Create another vulnerability with existing analysis that was manually applied.
        final var vulnB = new Vulnerability();
        vulnB.setVulnId("CVE-200");
        vulnB.setSource(Vulnerability.Source.NVD);
        vulnB.setSeverity(Severity.HIGH);
        qm.persist(vulnB);
        qm.addVulnerability(vulnB, component, AnalyzerIdentity.INTERNAL_ANALYZER);
        final var analysisB = new Analysis();
        analysisB.setComponent(component);
        analysisB.setVulnerability(vulnB);
        analysisB.setAnalysisState(AnalysisState.NOT_AFFECTED);
        qm.getPersistenceManager().makePersistent(analysisB);

        // Report both CVE-100 and CVE-200 again.
        final var componentUuid = component.getUuid();
        final var scanToken = UUID.randomUUID().toString();
        final var scanKey = ScanKey.newBuilder().setScanToken(scanToken).setComponentUuid(componentUuid.toString()).build();
        final var scanResult = ScanResult.newBuilder()
                .setKey(scanKey)
                .addScannerResults(ScannerResult.newBuilder()
                        .setScanner(SCANNER_INTERNAL)
                        .setStatus(SCAN_STATUS_SUCCESSFUL)
                        .setBom(Bom.newBuilder().addAllVulnerabilities(List.of(
                                createVuln(vulnA.getVulnId(), vulnA.getSource()),
                                createVuln(vulnB.getVulnId(), vulnB.getSource())
                        ))))
                .build();
        inputTopic.pipeInput(new TestRecord<>(scanKey, scanResult));
        assertThat(outputTopic.readValuesToList()).containsOnly(scanResult);

        qm.getPersistenceManager().evictAll();
        assertThat(component.getVulnerabilities()).satisfiesExactly(
                v -> {
                    // The analysis that was previously applied via policy must have been reverted.
                    assertThat(v.getVulnId()).isEqualTo("CVE-100");
                    assertThat(qm.getAnalysis(component, v)).satisfies(a -> {
                        assertThat(a.getAnalysisState()).isEqualTo(AnalysisState.NOT_SET);
                        assertThat(a.getVulnerabilityPolicy()).isNull();
                        assertThat(a.getAnalysisComments()).extracting(AnalysisComment::getCommenter).containsOnly("[Policy{None}]");
                        assertThat(a.getAnalysisComments()).extracting(AnalysisComment::getComment).containsExactlyInAnyOrder(
                                "No longer covered by any policy",
                                "Analysis: NOT_AFFECTED → NOT_SET",
                                "Justification: CODE_NOT_REACHABLE → NOT_SET",
                                "Vendor Response: WILL_NOT_FIX → NOT_SET",
                                "Details: (None)",
                                "Severity: MEDIUM → UNASSIGNED",
                                "CVSSv2 Vector: oldCvssV2Vector → (None)",
                                "CVSSv2 Score: 1.1 → (None)",
                                "CVSSv3 Vector: oldCvssV3Vector → (None)",
                                "CVSSv3 Score: 2.2 → (None)",
                                "OWASP Vector: oldOwaspVector → (None)",
                                "OWASP Score: 3.3 → (None)",
                                "Unsuppressed"
                        );
                    });
                },
                v -> {
                    // The manually applied analysis must not be touched!
                    assertThat(v.getVulnId()).isEqualTo("CVE-200");
                    assertThat(qm.getAnalysis(component, v)).satisfies(a -> {
                        assertThat(a.getAnalysisState()).isEqualTo(AnalysisState.NOT_AFFECTED);
                        assertThat(a.getAnalysisJustification()).isNull();
                        assertThat(a.getAnalysisResponse()).isNull();
                        assertThat(a.getAnalysisDetails()).isNull();
                        assertThat(a.getSeverity()).isNull();
                        assertThat(a.getCvssV2Vector()).isNull();
                        assertThat(a.getCvssV2Score()).isNull();
                        assertThat(a.getCvssV3Vector()).isNull();
                        assertThat(a.getCvssV3Score()).isNull();
                        assertThat(a.getVulnerabilityPolicy()).isNull();
                        assertThat(a.getAnalysisComments()).isEmpty();
                    });
                });
    }

    @Test
    public void analysisThroughPolicyWithPoliciesNotYetValidOrNotValidAnymoreTest() {
        final var project = new Project();
        project.setName("acme-app");
        project.setVersion("1.0.0");
        qm.persist(project);

        final var component = new Component();
        component.setName("acme-lib");
        component.setVersion("1.1.0");
        component.setProject(project);
        qm.persist(component);

        final var notYetValidPolicyAnalysis = new VulnerabilityPolicyAnalysis();
        notYetValidPolicyAnalysis.setState(VulnerabilityPolicyAnalysis.State.FALSE_POSITIVE);
        notYetValidPolicyAnalysis.setSuppress(true);
        final var notYetValidPolicy = new VulnerabilityPolicy();
        notYetValidPolicy.setName("NotYetValid");
        notYetValidPolicy.setValidFrom(Date.from(Instant.now().plusSeconds(180)));
        notYetValidPolicy.setConditions(new String[]{"true"});
        notYetValidPolicy.setAnalysis(notYetValidPolicyAnalysis);
        qm.createVulnerabilityPolicy(notYetValidPolicy, null);

        final var notValidAnymorePolicyAnalysis = new VulnerabilityPolicyAnalysis();
        notValidAnymorePolicyAnalysis.setState(VulnerabilityPolicyAnalysis.State.FALSE_POSITIVE);
        notValidAnymorePolicyAnalysis.setSuppress(true);
        final var notValidAnymorePolicy = new VulnerabilityPolicy();
        notValidAnymorePolicy.setName("NotValidAnymore");
        notValidAnymorePolicy.setValidUntil(Date.from(Instant.now().minusSeconds(180)));
        notValidAnymorePolicy.setConditions(new String[]{"true"});
        notValidAnymorePolicy.setAnalysis(notValidAnymorePolicyAnalysis);
        qm.createVulnerabilityPolicy(notValidAnymorePolicy, null);

        final var vuln = new Vulnerability();
        vuln.setVulnId("CVE-100");
        vuln.setSource(Vulnerability.Source.NVD);
        vuln.setSeverity(Severity.CRITICAL);
        qm.persist(vuln);

        final var componentUuid = component.getUuid();
        final var scanToken = UUID.randomUUID().toString();
        final var scanKey = ScanKey.newBuilder().setScanToken(scanToken).setComponentUuid(componentUuid.toString()).build();
        final var scanResult = ScanResult.newBuilder()
                .setKey(scanKey)
                .addScannerResults(ScannerResult.newBuilder()
                        .setScanner(SCANNER_INTERNAL)
                        .setStatus(SCAN_STATUS_SUCCESSFUL)
                        .setBom(Bom.newBuilder().addAllVulnerabilities(List.of(
                                createVuln(vuln.getVulnId(), vuln.getSource())
                        ))))
                .build();
        inputTopic.pipeInput(new TestRecord<>(scanKey, scanResult));
        assertThat(outputTopic.readValuesToList()).containsOnly(scanResult);

        qm.getPersistenceManager().evictAll();
        assertThat(qm.getAnalysis(component, vuln)).isNull();
    }

    private org.cyclonedx.proto.v1_4.Vulnerability createVuln(final String id, final String source) {
        return org.cyclonedx.proto.v1_4.Vulnerability.newBuilder()
                .setId(id)
                .setSource(Source.newBuilder().setName(source).build()).build();
    }
}