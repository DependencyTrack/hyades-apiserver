package org.dependencytrack.persistence;

import alpine.persistence.PaginatedResult;
import org.apache.commons.lang3.function.TriConsumer;
import org.dependencytrack.AbstractPostgresEnabledTest;
import org.dependencytrack.model.Analysis;
import org.dependencytrack.model.AnalysisComment;
import org.dependencytrack.model.AnalysisJustification;
import org.dependencytrack.model.AnalysisResponse;
import org.dependencytrack.model.AnalysisState;
import org.dependencytrack.model.Component;
import org.dependencytrack.model.Project;
import org.dependencytrack.model.Vulnerability;
import org.dependencytrack.model.VulnerabilityPolicy;
import org.dependencytrack.policy.vulnerability.VulnerabilityPolicyAnalysis;
import org.dependencytrack.policy.vulnerability.VulnerabilityPolicyRating;
import org.junit.Test;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.time.Instant;
import java.util.Date;
import java.util.List;

import static org.assertj.core.api.Assertions.assertThat;
import static org.dependencytrack.persistence.jdbi.JdbiFactory.jdbi;
import static org.junit.Assert.assertNotNull;

public class VulnerabilityPolicyQueryManagerTest extends AbstractPostgresEnabledTest {

    private static VulnerabilityPolicy getVulnerabilityPolicyInstance() throws ParseException {
        SimpleDateFormat formatter = new SimpleDateFormat("dd-MMM-yyyy");
        String validFromInString = "7-Jun-2020";
        Date validFrom = formatter.parse(validFromInString);

        String validUntilInString = "7-Jun-2023";
        Date validUntil = formatter.parse(validUntilInString);

        VulnerabilityPolicy vulnPolicy = new VulnerabilityPolicy();
        vulnPolicy.setCreated(new Date());
        vulnPolicy.setConditions(new String[]{"vuln.id == \"CVE-123\" || vuln.aliases.exists(alias, alias.id == \"CVE-123\")",
                "component.name == \"foo\" && project.name == \"bar\" && \"internal\" in project.tags && !component.is_dependency_of(v1.Component{group: \"org.springframework.boot\"}"});
        vulnPolicy.setName("name");
        vulnPolicy.setValidFrom(validFrom);
        vulnPolicy.setValidUntil(validUntil);
        VulnerabilityPolicyAnalysis vulnerabilityPolicyAnalysis = new VulnerabilityPolicyAnalysis();
        vulnerabilityPolicyAnalysis.setState(VulnerabilityPolicyAnalysis.State.NOT_AFFECTED);
        vulnerabilityPolicyAnalysis.setJustification(VulnerabilityPolicyAnalysis.Justification.CODE_NOT_REACHABLE);
        vulnerabilityPolicyAnalysis.setDetails("something");
        vulnerabilityPolicyAnalysis.setSuppress(true);
        vulnPolicy.setAnalysis(vulnerabilityPolicyAnalysis);
        VulnerabilityPolicyRating rating = new VulnerabilityPolicyRating();
        rating.setSeverity(VulnerabilityPolicyRating.Severity.HIGH);
        rating.setMethod(VulnerabilityPolicyRating.Method.CVSSV3);
        rating.setScore(6.3);
        rating.setVector("CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:L");
        vulnPolicy.setRatings(List.of(rating));
        return vulnPolicy;
    }

    @Test
    public void testVulnerabilityPolicyIsCreated() throws Exception {

        VulnerabilityPolicy vulnPolicy = getVulnerabilityPolicyInstance();

        int count = qm.createVulnerabilityPolicy(vulnPolicy, null);

        assertThat(count).isEqualTo(1);
        List<VulnerabilityPolicy> vulnerabilityPolicies = qm.getAllVulnerabilityPolicies();
        assertNotNull(vulnerabilityPolicies);
        assertThat(vulnerabilityPolicies).hasSize(1);
        assertThat(vulnerabilityPolicies).satisfiesExactlyInAnyOrder(
                vulnerabilityPolicy -> {
                    assertThat(vulnerabilityPolicy).isNotNull();
                    assertThat(vulnerabilityPolicy.getCreated()).isNotNull();
                    assertThat(vulnerabilityPolicy.getConditions()).isEqualTo(vulnPolicy.getConditions());
                    assertThat(vulnerabilityPolicy.getAnalysis()).isNotNull();
                    assertThat(vulnerabilityPolicy.getAnalysis().getState().name()).isEqualTo(AnalysisState.NOT_AFFECTED.name());
                    assertThat(vulnerabilityPolicy.getAnalysis().isSuppress()).isTrue();
                    assertThat(vulnerabilityPolicy.getAnalysis().getJustification().name()).isEqualTo(AnalysisJustification.CODE_NOT_REACHABLE.name());
                    assertThat(vulnerabilityPolicy.getAnalysis().getDetails()).isEqualTo("something");
                    assertThat(vulnerabilityPolicy.getRatings()).isNotNull();
                    assertThat(vulnerabilityPolicy.getRatings()).hasSize(1);
                    assertThat(vulnerabilityPolicy.getRatings()).satisfiesExactlyInAnyOrder(
                            rating1 -> {
                                assertThat(rating1.getScore()).isEqualTo(6.3);
                                assertThat(rating1.getMethod()).isEqualTo(VulnerabilityPolicyRating.Method.CVSSV3);
                                assertThat(rating1.getSeverity()).isEqualTo(VulnerabilityPolicyRating.Severity.HIGH);
                                assertThat(rating1.getVector()).isEqualTo("CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:L");
                            });
                });
    }

    @Test
    public void testVulnerabilityPolicyIsCreatedWithoutRating() throws Exception {

        VulnerabilityPolicy vulnPolicy = getVulnerabilityPolicyInstance();
        vulnPolicy.setRatings(null);

        int count = qm.createVulnerabilityPolicy(vulnPolicy, null);

        assertThat(count).isEqualTo(1);
        List<VulnerabilityPolicy> vulnerabilityPolicies = qm.getAllVulnerabilityPolicies();
        assertNotNull(vulnerabilityPolicies);
        assertThat(vulnerabilityPolicies).hasSize(1);
        assertThat(vulnerabilityPolicies).satisfiesExactlyInAnyOrder(
                vulnerabilityPolicy -> {
                    assertThat(vulnerabilityPolicy).isNotNull();
                    assertThat(vulnerabilityPolicy.getCreated()).isNotNull();
                    assertThat(vulnerabilityPolicy.getConditions()).isEqualTo(vulnPolicy.getConditions());
                    assertThat(vulnerabilityPolicy.getAnalysis()).isNotNull();
                    assertThat(vulnerabilityPolicy.getAnalysis().getState().name()).isEqualTo(AnalysisState.NOT_AFFECTED.name());
                    assertThat(vulnerabilityPolicy.getAnalysis().isSuppress()).isTrue();
                    assertThat(vulnerabilityPolicy.getAnalysis().getJustification().name()).isEqualTo(AnalysisJustification.CODE_NOT_REACHABLE.name());
                    assertThat(vulnerabilityPolicy.getAnalysis().getDetails()).isEqualTo("something");
                    assertThat(vulnerabilityPolicy.getRatings()).isNull();
                });
    }

    @Test
    public void testVulnerabilityPolicyIsDeleted() throws Exception {
        VulnerabilityPolicy vulnPolicy = getVulnerabilityPolicyInstance();
        int count = qm.createVulnerabilityPolicy(vulnPolicy, null);
        assertThat(count).isEqualTo(1);
        qm.deleteVulnerabilityPolicyByName(vulnPolicy.getName(), null);
        List<VulnerabilityPolicy> policies = qm.getAllVulnerabilityPolicies();
        assertThat(policies).isEmpty();
    }

    @Test
    public void testVulnerabilityPolicyIsUnassignedAndDeleted() throws Exception {
        final var project = new Project();
        project.setName("acme-app");
        project.setVersion("1.0.0");
        qm.persist(project);

        final var component = new Component();
        component.setProject(project);
        component.setName("acme-lib");
        component.setVersion("2.0.0");
        qm.persist(component);

        final var vuln = new Vulnerability();
        vuln.setVulnId("CVE-100");
        vuln.setSource(Vulnerability.Source.NVD);
        qm.persist(vuln);

        final var analysis = new Analysis();
        analysis.setComponent(component);
        analysis.setVulnerability(vuln);
        analysis.setAnalysisState(AnalysisState.NOT_AFFECTED);
        analysis.setAnalysisJustification(AnalysisJustification.CODE_NOT_REACHABLE);
        analysis.setAnalysisResponse(AnalysisResponse.WILL_NOT_FIX);
        analysis.setAnalysisDetails("Foo");
        analysis.setSuppressed(true);
        qm.persist(analysis);

        final VulnerabilityPolicy vulnPolicy = getVulnerabilityPolicyInstance();
        assertThat(qm.createVulnerabilityPolicy(vulnPolicy, null)).isEqualTo(1);

        int count = jdbi(qm).withHandle(jdbiHandle -> jdbiHandle.createUpdate("""
                        UPDATE
                          "ANALYSIS"
                        SET
                          "VULNERABILITY_POLICY_ID" = (SELECT "ID" FROM "VULNERABILITY_POLICY" WHERE "NAME" = :vulnPolicyName)
                        WHERE
                          "ID" = :analysisId
                        """)
                .bind("vulnPolicyName", vulnPolicy.getName())
                .bind("analysisId", analysis.getId())
                .execute());
        assertThat(count).isEqualTo(1);

        assertThat(qm.deleteVulnerabilityPolicyByName(vulnPolicy.getName(), null)).isEqualTo(1);

        qm.getPersistenceManager().refresh(analysis);
        assertThat(analysis.getAnalysisState()).isEqualTo(AnalysisState.NOT_SET);
        assertThat(analysis.getAnalysisJustification()).isNull();
        assertThat(analysis.getAnalysisResponse()).isNull();
        assertThat(analysis.getAnalysisDetails()).isNull();
        assertThat(analysis.getVulnerabilityPolicy()).isNull();
        assertThat(analysis.getAnalysisComments()).extracting(AnalysisComment::getCommenter).containsOnly("[Policy{Name=name}]");
        assertThat(analysis.getAnalysisComments()).extracting(AnalysisComment::getComment).containsExactlyInAnyOrder(
                "Policy removed",
                "Analysis: NOT_AFFECTED → NOT_SET",
                "Justification: CODE_NOT_REACHABLE → NOT_SET",
                "Vendor Response: WILL_NOT_FIX → NOT_SET",
                "Details: (None)",
                "Unsuppressed"
        );
    }

    @Test
    public void testVulnerabilityPolicyIsUpdated() throws Exception {

        VulnerabilityPolicy vulnPolicy = getVulnerabilityPolicyInstance();

        int count = qm.createVulnerabilityPolicy(vulnPolicy, null);
        assertThat(count).isEqualTo(1);

        String[] updatedConditions = new String[]{"foo=something", "bar=baz", "c=woah"};
        vulnPolicy.setConditions(updatedConditions);
        qm.updateVulnerablePolicyByName(vulnPolicy, null);

        VulnerabilityPolicy vulnerabilityPolicy = qm.getVulnerabilityPolicyByName(vulnPolicy.getName());
        assertNotNull(vulnerabilityPolicy);
        assertThat(vulnerabilityPolicy.getCreated()).isNotNull();
        assertThat(vulnerabilityPolicy.getConditions()).isEqualTo(updatedConditions);
        assertThat(vulnerabilityPolicy.getAnalysis()).isNotNull();
        assertThat(vulnerabilityPolicy.getAnalysis().getState().name()).isEqualTo(AnalysisState.NOT_AFFECTED.name());
        assertThat(vulnerabilityPolicy.getAnalysis().isSuppress()).isTrue();
        assertThat(vulnerabilityPolicy.getAnalysis().getJustification().name()).isEqualTo(AnalysisJustification.CODE_NOT_REACHABLE.name());
        assertThat(vulnerabilityPolicy.getAnalysis().getDetails()).isEqualTo("something");
        assertThat(vulnerabilityPolicy.getRatings()).isNotNull();
        assertThat(vulnerabilityPolicy.getRatings()).hasSize(1);
        assertThat(vulnerabilityPolicy.getRatings()).satisfiesExactlyInAnyOrder(
                rating1 -> {
                    assertThat(rating1.getScore()).isEqualTo(6.3);
                    assertThat(rating1.getMethod()).isEqualTo(VulnerabilityPolicyRating.Method.CVSSV3);
                    assertThat(rating1.getSeverity()).isEqualTo(VulnerabilityPolicyRating.Severity.HIGH);
                    assertThat(rating1.getVector()).isEqualTo("CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:L");
                });

    }

    @Test
    public void testVulnerabilitiesFetchedWithNoFilter() throws Exception {
        VulnerabilityPolicy vulnPolicy = getVulnerabilityPolicyInstance();

        int count = qm.createVulnerabilityPolicy(vulnPolicy, null);

        assertThat(count).isEqualTo(1);
        PaginatedResult result = qm.getAllVulnerabilityPolicies(null, null, null);
        assertNotNull(result);
        assertThat(result.getObjects()).hasSize(1);
    }

    @Test
    public void testVulnerabilitiesFetchedWithNameFilter() throws Exception {
        VulnerabilityPolicy vulnPolicy = getVulnerabilityPolicyInstance();

        int count = qm.createVulnerabilityPolicy(vulnPolicy, null);

        assertThat(count).isEqualTo(1);
        PaginatedResult result = qm.getAllVulnerabilityPolicies("name", null, null);
        assertNotNull(result);
        assertThat(result.getObjects()).hasSize(1);
    }

    @Test
    public void testNoVulnerabilitiesFetchedWithNameNotMatching() throws Exception {
        VulnerabilityPolicy vulnPolicy = getVulnerabilityPolicyInstance();

        int count = qm.createVulnerabilityPolicy(vulnPolicy, null);

        assertThat(count).isEqualTo(1);
        PaginatedResult result = qm.getAllVulnerabilityPolicies("othername", null, null);
        assertNotNull(result);
        assertThat(result.getObjects()).hasSize(0);
    }

    @Test
    public void testVulnerabilitiesFetchedWithDateFilter() throws Exception {
        VulnerabilityPolicy vulnPolicy = getVulnerabilityPolicyInstance();

        int count = qm.createVulnerabilityPolicy(vulnPolicy, null);

        assertThat(count).isEqualTo(1);
        SimpleDateFormat formatter = new SimpleDateFormat("dd-MMM-yyyy");
        String validFromInString = "5-Jun-2020";
        Date validFrom = formatter.parse(validFromInString);
        PaginatedResult result = qm.getAllVulnerabilityPolicies(null, validFrom, null);
        assertNotNull(result);
        assertThat(result.getObjects()).hasSize(1);
    }

    @Test
    public void testNoVulnerabilitiesFetchedWithNameAndDateFilterNotMatching() throws Exception {
        VulnerabilityPolicy vulnPolicy = getVulnerabilityPolicyInstance();

        int count = qm.createVulnerabilityPolicy(vulnPolicy, null);

        assertThat(count).isEqualTo(1);

        PaginatedResult result = qm.getAllVulnerabilityPolicies("name", new Date(), null);
        assertNotNull(result);
        assertThat(result.getObjects()).hasSize(0);
    }

    @Test
    public void testVulnerabilitiesFetchedWithNameAndDateUntilFilter() throws Exception {
        VulnerabilityPolicy vulnPolicy = getVulnerabilityPolicyInstance();

        int count = qm.createVulnerabilityPolicy(vulnPolicy, null);

        assertThat(count).isEqualTo(1);
        SimpleDateFormat formatter = new SimpleDateFormat("dd-MMM-yyyy");
        String validUntilInString = "9-Jun-2023";
        Date validUntil = formatter.parse(validUntilInString);
        PaginatedResult result = qm.getAllVulnerabilityPolicies("name", null, validUntil);
        assertNotNull(result);
        assertThat(result.getObjects()).hasSize(1);
    }

    @Test
    public void testGetAllValidVulnerabilityPolicies() {
        final TriConsumer<String, Date, Date> createPolicy = (name, validFrom, validUntil) -> {
            final var analysis = new VulnerabilityPolicyAnalysis();
            analysis.setState(VulnerabilityPolicyAnalysis.State.FALSE_POSITIVE);
            final var policy = new VulnerabilityPolicy();
            policy.setName(name);
            policy.setValidFrom(validFrom);
            policy.setValidUntil(validUntil);
            policy.setConditions(new String[]{"true"});
            policy.setAnalysis(analysis);
            qm.createVulnerabilityPolicy(policy, null);
        };

        // Without validFrom and validUntil
        createPolicy.accept("Foo-001", null, null);

        // validFrom in the future
        createPolicy.accept("Foo-002", Date.from(Instant.now().plusSeconds(180)), null);

        // validFrom in the past
        createPolicy.accept("Foo-003", Date.from(Instant.now().minusSeconds(180)), null);

        // validUntil in the future
        createPolicy.accept("Foo-004", null, Date.from(Instant.now().plusSeconds(180)));

        // validUntil in the past
        createPolicy.accept("Foo-005", null, Date.from(Instant.now().minusSeconds(180)));

        final List<VulnerabilityPolicy> validPolicies = qm.getAllValidVulnerabilityPolicies();
        assertThat(validPolicies).extracting(VulnerabilityPolicy::getName).containsExactly(
                "Foo-001",
                // Foo-002 is not yet valid
                "Foo-003",
                "Foo-004"
                // Foo-005 is expired
        );
    }

}
