package org.dependencytrack.persistence.jdbi;

import alpine.persistence.PaginatedResult;
import org.apache.commons.lang3.function.TriConsumer;
import org.dependencytrack.PersistenceCapableTest;
import org.dependencytrack.model.Analysis;
import org.dependencytrack.model.AnalysisComment;
import org.dependencytrack.model.AnalysisJustification;
import org.dependencytrack.model.AnalysisResponse;
import org.dependencytrack.model.AnalysisState;
import org.dependencytrack.model.Component;
import org.dependencytrack.model.Project;
import org.dependencytrack.model.Vulnerability;
import org.dependencytrack.policy.vulnerability.VulnerabilityPolicy;
import org.dependencytrack.policy.vulnerability.VulnerabilityPolicyAnalysis;
import org.dependencytrack.policy.vulnerability.VulnerabilityPolicyRating;
import org.jdbi.v3.core.Handle;
import org.junit.After;
import org.junit.Before;
import org.junit.Test;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.time.Instant;
import java.time.ZoneOffset;
import java.time.ZonedDateTime;
import java.util.Date;
import java.util.List;

import static org.assertj.core.api.Assertions.assertThat;
import static org.dependencytrack.persistence.jdbi.JdbiFactory.jdbi;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertNull;

public class VulnerabilityPolicyDaoTest extends PersistenceCapableTest {

    private Handle jdbiHandle;
    private VulnerabilityPolicyDao vulnPolicyDao;

    @Before
    public void before() throws Exception {
        super.before();

        jdbiHandle = jdbi(qm).open();
        vulnPolicyDao = jdbiHandle.attach(VulnerabilityPolicyDao.class);
    }

    @After
    public void after() {
        if (jdbiHandle != null) {
            jdbiHandle.close();
        }

        super.after();
    }

    private static VulnerabilityPolicy getVulnerabilityPolicyInstance() throws ParseException {
        SimpleDateFormat formatter = new SimpleDateFormat("dd-MMM-yyyy");
        String validFromInString = "7-Jun-2020";
        Date validFrom = formatter.parse(validFromInString);

        String validUntilInString = "7-Jun-2023";
        Date validUntil = formatter.parse(validUntilInString);

        VulnerabilityPolicy vulnPolicy = new VulnerabilityPolicy();
        vulnPolicy.setConditions(List.of("vuln.id == \"CVE-123\" || vuln.aliases.exists(alias, alias.id == \"CVE-123\")",
                "component.name == \"foo\" && project.name == \"bar\" && \"internal\" in project.tags && !component.is_dependency_of(v1.Component{group: \"org.springframework.boot\"}"));
        vulnPolicy.setName("name");
        vulnPolicy.setValidFrom(ZonedDateTime.ofInstant(validFrom.toInstant(), ZoneOffset.UTC));
        vulnPolicy.setValidUntil(ZonedDateTime.ofInstant(validUntil.toInstant(), ZoneOffset.UTC));
        VulnerabilityPolicyAnalysis vulnerabilityPolicyAnalysis = new VulnerabilityPolicyAnalysis();
        vulnerabilityPolicyAnalysis.setState(VulnerabilityPolicyAnalysis.State.NOT_AFFECTED);
        vulnerabilityPolicyAnalysis.setJustification(VulnerabilityPolicyAnalysis.Justification.CODE_NOT_REACHABLE);
        vulnerabilityPolicyAnalysis.setDetails("something");
        vulnerabilityPolicyAnalysis.setSuppress(true);
        vulnPolicy.setAnalysis(vulnerabilityPolicyAnalysis);
        VulnerabilityPolicyRating rating = new VulnerabilityPolicyRating();
        rating.setSeverity(VulnerabilityPolicyRating.Severity.HIGH);
        rating.setMethod(VulnerabilityPolicyRating.Method.CVSSV3);
        rating.setScore(6.3);
        rating.setVector("CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:L");
        vulnPolicy.setRatings(List.of(rating));
        return vulnPolicy;
    }

    @Test
    public void testVulnerabilityPolicyIsCreated() throws Exception {

        VulnerabilityPolicy vulnPolicy = getVulnerabilityPolicyInstance();

        final VulnerabilityPolicy createdPolicy = vulnPolicyDao.create(vulnPolicy);

        assertThat(createdPolicy).isNotNull();

        List<VulnerabilityPolicy> vulnerabilityPolicies = vulnPolicyDao.getAll();

        assertNotNull(vulnerabilityPolicies);
        assertThat(vulnerabilityPolicies).hasSize(1);
        assertThat(vulnerabilityPolicies).satisfiesExactlyInAnyOrder(
                vulnerabilityPolicy -> {
                    assertThat(vulnerabilityPolicy).isNotNull();
                    assertThat(vulnerabilityPolicy.getCreated()).isNotNull();
                    assertThat(vulnerabilityPolicy.getConditions()).isEqualTo(vulnPolicy.getConditions());
                    assertThat(vulnerabilityPolicy.getAnalysis()).isNotNull();
                    assertThat(vulnerabilityPolicy.getAnalysis().getState().name()).isEqualTo(AnalysisState.NOT_AFFECTED.name());
                    assertThat(vulnerabilityPolicy.getAnalysis().isSuppress()).isTrue();
                    assertThat(vulnerabilityPolicy.getAnalysis().getJustification().name()).isEqualTo(AnalysisJustification.CODE_NOT_REACHABLE.name());
                    assertThat(vulnerabilityPolicy.getAnalysis().getDetails()).isEqualTo("something");
                    assertThat(vulnerabilityPolicy.getRatings()).isNotNull();
                    assertThat(vulnerabilityPolicy.getRatings()).hasSize(1);
                    assertThat(vulnerabilityPolicy.getRatings()).satisfiesExactlyInAnyOrder(
                            rating1 -> {
                                assertThat(rating1.getScore()).isEqualTo(6.3);
                                assertThat(rating1.getMethod()).isEqualTo(VulnerabilityPolicyRating.Method.CVSSV3);
                                assertThat(rating1.getSeverity()).isEqualTo(VulnerabilityPolicyRating.Severity.HIGH);
                                assertThat(rating1.getVector()).isEqualTo("CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:L");
                            });
                });
    }

    @Test
    public void testGetAllValid() {
        final TriConsumer<String, ZonedDateTime, ZonedDateTime> createPolicy = (name, validFrom, validUntil) -> {
            final var analysis = new VulnerabilityPolicyAnalysis();
            analysis.setState(VulnerabilityPolicyAnalysis.State.FALSE_POSITIVE);
            final var policy = new org.dependencytrack.policy.vulnerability.VulnerabilityPolicy();
            policy.setName(name);
            policy.setValidFrom(validFrom);
            policy.setValidUntil(validUntil);
            policy.setConditions(List.of("true"));
            policy.setAnalysis(analysis);
            vulnPolicyDao.create(policy);
        };

        // Without validFrom and validUntil
        createPolicy.accept("Foo-001", null, null);

        // validFrom in the future
        createPolicy.accept("Foo-002", ZonedDateTime.ofInstant(Instant.now().plusSeconds(180), ZoneOffset.UTC), null);

        // validFrom in the past
        createPolicy.accept("Foo-003", ZonedDateTime.ofInstant(Instant.now().minusSeconds(180), ZoneOffset.UTC), null);

        // validUntil in the future
        createPolicy.accept("Foo-004", null, ZonedDateTime.ofInstant(Instant.now().plusSeconds(180), ZoneOffset.UTC));

        // validUntil in the past
        createPolicy.accept("Foo-005", null, ZonedDateTime.ofInstant(Instant.now().minusSeconds(180), ZoneOffset.UTC));

        final List<VulnerabilityPolicy> validPolicies = vulnPolicyDao.getAllValid();
        assertThat(validPolicies).extracting(VulnerabilityPolicy::getName).containsExactly(
                "Foo-001",
                // Foo-002 is not yet valid
                "Foo-003",
                "Foo-004"
                // Foo-005 is expired
        );
    }

    @Test
    public void testGetPageWithNameLikeWithNoFilter() throws Exception {
        VulnerabilityPolicy vulnPolicy = jdbi(qm).withExtension(VulnerabilityPolicyDao.class,
                dao -> dao.create(getVulnerabilityPolicyInstance()));
        assertThat(vulnPolicy).isNotNull();
        PaginatedResult result = vulnPolicyDao.getPageWithNameLike(null, null, null);
        assertNotNull(result);
        assertThat(result.getObjects()).hasSize(1);
    }

    @Test
    public void testGetPageWithNameLikeWitFilter() throws Exception {
        VulnerabilityPolicy vulnPolicy = jdbi(qm).withExtension(VulnerabilityPolicyDao.class,
                dao -> dao.create(getVulnerabilityPolicyInstance()));
        assertThat(vulnPolicy).isNotNull();
        PaginatedResult result = vulnPolicyDao.getPageWithNameLike(null, null, "am");
        assertNotNull(result);
        assertThat(result.getObjects()).hasSize(1);
    }

    @Test
    public void testGetPageWithNameLikeWithNameNotMatching() throws Exception {
        VulnerabilityPolicy vulnPolicy = jdbi(qm).withExtension(VulnerabilityPolicyDao.class,
                dao -> dao.create(getVulnerabilityPolicyInstance()));
        assertThat(vulnPolicy).isNotNull();
        PaginatedResult result = vulnPolicyDao.getPageWithNameLike(null, null, "othername");
        assertNotNull(result);
        assertThat(result.getObjects()).hasSize(0);
    }

    @Test
    public void testGetByName() throws Exception {

        VulnerabilityPolicy vulnPolicy = getVulnerabilityPolicyInstance();

        VulnerabilityPolicy vulnerabilityPolicy = vulnPolicyDao.create(vulnPolicy);

        assertNotNull(vulnerabilityPolicy);
        assertThat(vulnerabilityPolicy).isNotNull();
        assertThat(vulnerabilityPolicy.getCreated()).isNotNull();
        assertThat(vulnerabilityPolicy.getUpdated()).isNull();
        assertThat(vulnerabilityPolicy.getConditions()).isEqualTo(vulnPolicy.getConditions());
        assertThat(vulnerabilityPolicy.getAnalysis()).isNotNull();
        assertThat(vulnerabilityPolicy.getAnalysis().getState().name()).isEqualTo(AnalysisState.NOT_AFFECTED.name());
        assertThat(vulnerabilityPolicy.getAnalysis().isSuppress()).isTrue();
        assertThat(vulnerabilityPolicy.getAnalysis().getJustification().name()).isEqualTo(AnalysisJustification.CODE_NOT_REACHABLE.name());
        assertThat(vulnerabilityPolicy.getAnalysis().getDetails()).isEqualTo("something");
        assertThat(vulnerabilityPolicy.getRatings()).isNotNull();
        assertThat(vulnerabilityPolicy.getRatings()).hasSize(1);
        assertThat(vulnerabilityPolicy.getRatings()).satisfiesExactlyInAnyOrder(
                rating1 -> {
                    assertThat(rating1.getScore()).isEqualTo(6.3);
                    assertThat(rating1.getMethod()).isEqualTo(VulnerabilityPolicyRating.Method.CVSSV3);
                    assertThat(rating1.getSeverity()).isEqualTo(VulnerabilityPolicyRating.Severity.HIGH);
                    assertThat(rating1.getVector()).isEqualTo("CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:L");
                });

    }

    @Test
    public void testDeleteByName() throws Exception {

        VulnerabilityPolicy vulnPolicy = getVulnerabilityPolicyInstance();

        VulnerabilityPolicy vulnerabilityPolicy = vulnPolicyDao.create(vulnPolicy);

        assertNotNull(vulnerabilityPolicy);

        final int result = vulnPolicyDao.deleteByName("name");

        assertThat(result).isEqualTo(1);
    }

    @Test
    public void testUpdate() throws Exception {

        VulnerabilityPolicy vulnPolicy = getVulnerabilityPolicyInstance();

        VulnerabilityPolicy createdPolicy = vulnPolicyDao.create(vulnPolicy);

        assertNotNull(createdPolicy);
        createdPolicy.setAuthor("Jon Doe");

        VulnerabilityPolicy updatedPolicy = vulnPolicyDao.update(createdPolicy);

        assertThat(updatedPolicy).isNotNull();
        assertThat(updatedPolicy.getCreated()).isNotNull();
        assertThat(updatedPolicy.getUpdated()).isNotNull();
        assertThat(updatedPolicy.getAuthor()).isEqualTo("Jon Doe");
        assertThat(updatedPolicy.getConditions()).isEqualTo(vulnPolicy.getConditions());
        assertThat(updatedPolicy.getAnalysis()).isNotNull();
        assertThat(updatedPolicy.getAnalysis().getState().name()).isEqualTo(AnalysisState.NOT_AFFECTED.name());
        assertThat(updatedPolicy.getAnalysis().isSuppress()).isTrue();
        assertThat(updatedPolicy.getAnalysis().getJustification().name()).isEqualTo(AnalysisJustification.CODE_NOT_REACHABLE.name());
        assertThat(updatedPolicy.getAnalysis().getDetails()).isEqualTo("something");
        assertThat(updatedPolicy.getRatings()).isNotNull();
        assertThat(updatedPolicy.getRatings()).hasSize(1);
        assertThat(updatedPolicy.getRatings()).satisfiesExactlyInAnyOrder(
                rating1 -> {
                    assertThat(rating1.getScore()).isEqualTo(6.3);
                    assertThat(rating1.getMethod()).isEqualTo(VulnerabilityPolicyRating.Method.CVSSV3);
                    assertThat(rating1.getSeverity()).isEqualTo(VulnerabilityPolicyRating.Severity.HIGH);
                    assertThat(rating1.getVector()).isEqualTo("CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:L");
                });

    }

    @Test
    public void testVulnerabilityPolicyIsNotUpdatedWhenNothingChanged() throws Exception {
        VulnerabilityPolicy vulnPolicy = getVulnerabilityPolicyInstance();

        VulnerabilityPolicy createdPolicy = vulnPolicyDao.create(vulnPolicy);

        assertNotNull(createdPolicy);

        VulnerabilityPolicy updatedPolicy = vulnPolicyDao.update(createdPolicy);

        assertNull(updatedPolicy);
    }

    @Test
    public void testVulnerabilityPolicyIsDeleted() throws Exception {
        VulnerabilityPolicy vulnPolicy = vulnPolicyDao.create(getVulnerabilityPolicyInstance());
        assertThat(vulnPolicy).isNotNull();
        vulnPolicyDao.deleteByName(vulnPolicy.getName());
        List<VulnerabilityPolicy> policies = vulnPolicyDao.getAll();
        assertThat(policies).isEmpty();
    }

    @Test
    public void testVulnerabilityPolicyIsUnassignedAndDeleted() throws Exception {
        final var project = new Project();
        project.setName("acme-app");
        project.setVersion("1.0.0");
        qm.persist(project);

        final var component = new Component();
        component.setProject(project);
        component.setName("acme-lib");
        component.setVersion("2.0.0");
        qm.persist(component);

        final var vuln = new Vulnerability();
        vuln.setVulnId("CVE-100");
        vuln.setSource(Vulnerability.Source.NVD);
        qm.persist(vuln);

        final var analysis = new Analysis();
        analysis.setComponent(component);
        analysis.setVulnerability(vuln);
        analysis.setAnalysisState(AnalysisState.NOT_AFFECTED);
        analysis.setAnalysisJustification(AnalysisJustification.CODE_NOT_REACHABLE);
        analysis.setAnalysisResponse(AnalysisResponse.WILL_NOT_FIX);
        analysis.setAnalysisDetails("Foo");
        analysis.setSuppressed(true);
        qm.persist(analysis);

        final VulnerabilityPolicy vulnPolicy = vulnPolicyDao.create(getVulnerabilityPolicyInstance());
        assertThat(vulnPolicy).isNotNull();

        int count = jdbiHandle.createUpdate("""
                        UPDATE
                          "ANALYSIS"
                        SET
                          "VULNERABILITY_POLICY_ID" = (SELECT "ID" FROM "VULNERABILITY_POLICY" WHERE "NAME" = :vulnPolicyName)
                        WHERE
                          "ID" = :analysisId
                        """)
                .bind("vulnPolicyName", vulnPolicy.getName())
                .bind("analysisId", analysis.getId())
                .execute();
        assertThat(count).isEqualTo(1);

        vulnPolicyDao.unassignAndDeleteByName(vulnPolicy.getName());

        qm.getPersistenceManager().refresh(analysis);
        assertThat(analysis.getAnalysisState()).isEqualTo(AnalysisState.NOT_SET);
        assertThat(analysis.getAnalysisJustification()).isNull();
        assertThat(analysis.getAnalysisResponse()).isNull();
        assertThat(analysis.getAnalysisDetails()).isNull();
        assertThat(analysis.getVulnerabilityPolicy()).isNull();
        assertThat(analysis.getAnalysisComments()).extracting(AnalysisComment::getCommenter).containsOnly("[Policy{Name=name}]");
        assertThat(analysis.getAnalysisComments()).extracting(AnalysisComment::getComment).containsExactlyInAnyOrder(
                "Policy removed",
                "Analysis: NOT_AFFECTED → NOT_SET",
                "Justification: CODE_NOT_REACHABLE → NOT_SET",
                "Vendor Response: WILL_NOT_FIX → NOT_SET",
                "Details: (None)",
                "Unsuppressed"
        );
    }

}
