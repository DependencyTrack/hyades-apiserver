/*
 * This file is part of Dependency-Track.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 * Copyright (c) OWASP Foundation. All Rights Reserved.
 */
package org.dependencytrack.persistence.jdbi;

import alpine.persistence.PaginatedResult;
import org.dependencytrack.model.Analysis;
import org.dependencytrack.persistence.jdbi.mapping.AnalysisRowMapper;
import org.dependencytrack.persistence.jdbi.mapping.PaginatedVulnerabilityPolicyRowReducer;
import org.dependencytrack.policy.vulnerability.VulnerabilityPolicy;
import org.dependencytrack.util.AnalysisCommentFormatter.AnalysisCommentField;
import org.jdbi.v3.sqlobject.SqlObject;
import org.jdbi.v3.sqlobject.config.RegisterBeanMapper;
import org.jdbi.v3.sqlobject.customizer.Bind;
import org.jdbi.v3.sqlobject.customizer.BindBean;
import org.jdbi.v3.sqlobject.statement.GetGeneratedKeys;
import org.jdbi.v3.sqlobject.statement.SqlQuery;
import org.jdbi.v3.sqlobject.statement.SqlUpdate;
import org.jdbi.v3.sqlobject.statement.UseRowReducer;

import java.util.ArrayList;
import java.util.List;
import java.util.Optional;

import static org.dependencytrack.util.AnalysisCommentFormatter.formatComment;

@RegisterBeanMapper(VulnerabilityPolicy.class)
public interface VulnerabilityPolicyDao extends SqlObject {

    @SqlQuery("""  
            SELECT * FROM "VULNERABILITY_POLICY"
            """)
    List<VulnerabilityPolicy> getAll();

    @SqlQuery("""
            SELECT
              *
            FROM
              "VULNERABILITY_POLICY"
            WHERE
              ("VALID_FROM" IS NULL OR "VALID_FROM" <= NOW())
              AND ("VALID_UNTIL" IS NULL OR "VALID_UNTIL" >= NOW())
              AND ("OPERATION_MODE" != 'DISABLED')
            """)
    List<VulnerabilityPolicy> getAllEnabledAndValid();

    @SqlQuery(/* language=InjectedFreeMarker */ """
            <#-- @ftlvariable name="apiFilterParameter" type="String" -->
            <#-- @ftlvariable name="apiOrderByClause" type="String" -->
            <#-- @ftlvariable name="apiOffsetLimitClause" type="String" -->
            SELECT
              "ID"            AS "id",
              "ANALYSIS",
              "AUTHOR"        AS "author",
              "CONDITIONS",
              "CREATED"       AS "created",
              "NAME"          AS "name",
              "RATINGS",
              "UPDATED"       AS "updated",
              "VALID_FROM"    AS "validFrom",
              "VALID_UNTIL"   AS "validUntil",
              "OPERATION_MODE" AS "operationMode",
              COUNT(*) OVER() AS "totalCount"
            FROM
              "VULNERABILITY_POLICY"
            <#if apiFilterParameter??>
            WHERE
              "NAME" LIKE ('%' || ${apiFilterParameter} || '%')
            </#if>
            ${apiOrderByClause!}
            ${apiOffsetLimitClause!}
            """)
    @AllowApiOrdering(alwaysBy = "id", by = {
            @AllowApiOrdering.Column(name = "id"),
            @AllowApiOrdering.Column(name = "author"),
            @AllowApiOrdering.Column(name = "created"),
            @AllowApiOrdering.Column(name = "name"),
            @AllowApiOrdering.Column(name = "updated"),
            @AllowApiOrdering.Column(name = "validFrom"),
            @AllowApiOrdering.Column(name = "validUntil"),
            @AllowApiOrdering.Column(name = "operationMode")
    })
    @UseRowReducer(PaginatedVulnerabilityPolicyRowReducer.class)
    PaginatedResult getPage();

    @SqlQuery("""  
            SELECT * FROM "VULNERABILITY_POLICY" WHERE "NAME" = ?
            """)
    VulnerabilityPolicy getByName(@Bind String name);

    @SqlUpdate("""
            INSERT INTO "VULNERABILITY_POLICY"
              ("ANALYSIS", "AUTHOR", "CONDITIONS", "CREATED", "DESCRIPTION", "NAME", "RATINGS", "VALID_FROM", "VALID_UNTIL", "OPERATION_MODE")
            VALUES
              ((:analysis)::JSONB, :author, :conditions, NOW(), :description, :name, (:ratings)::JSONB, :validFrom, :validUntil, :operationMode)
            RETURNING *
            """)
    @GetGeneratedKeys("*")
    VulnerabilityPolicy create(@BindBean VulnerabilityPolicy vulnerabilityPolicy);

    @SqlUpdate("""
            DELETE FROM "VULNERABILITY_POLICY" WHERE "NAME" = ?
            """)
    int deleteByName(@Bind String name);

    @SqlUpdate("""
            UPDATE "VULNERABILITY_POLICY"
            SET
              "ANALYSIS"    = (:analysis)::JSONB,
              "AUTHOR"      = :author,
              "CONDITIONS"  = :conditions,
              "DESCRIPTION" = :description,
              "RATINGS"     = (:ratings)::JSONB,
              "UPDATED"     = NOW(),
              "VALID_FROM"  = :validFrom,
              "VALID_UNTIL" = :validUntil,
              "OPERATION_MODE" = :operationMode
            WHERE
              "NAME" = :name AND (
                -- Using IS DISTINCT FROM instead of != for nullable columns
                -- because != does not handle NULL.
                "ANALYSIS"       != (:analysis)::JSONB
                OR "AUTHOR"      IS DISTINCT FROM :author
                OR "CONDITIONS"  != (:conditions)::TEXT[]
                OR "DESCRIPTION" IS DISTINCT FROM :description
                OR "RATINGS"     IS DISTINCT FROM (:ratings)::JSONB
                OR "VALID_FROM"  IS DISTINCT FROM :validFrom
                OR "VALID_UNTIL" IS DISTINCT FROM :validUntil
                OR "OPERATION_MODE" IS DISTINCT FROM :operationMode
              )
            RETURNING *
            """)
    @GetGeneratedKeys("*")
    VulnerabilityPolicy update(@BindBean VulnerabilityPolicy vulnerabilityPolicy);

    default List<Analysis> unassignFromAnalysesByName(final String name) {
        // NB: Can't use interface method here due to https://github.com/jdbi/jdbi/issues/1807.
        return getHandle().createUpdate("""
                        WITH "CTE_VULN_POLICY" AS (
                          SELECT
                            "ID"
                          FROM
                            "VULNERABILITY_POLICY"
                          WHERE
                            "NAME" = :name
                        )
                        UPDATE
                          "ANALYSIS" AS "NEW"
                        SET
                          "STATE"                   = 'NOT_SET', -- Must be non-null
                          "JUSTIFICATION"           = NULL,
                          "RESPONSE"                = NULL,
                          "DETAILS"                 = NULL,
                          "SUPPRESSED"              = FALSE,
                          "SEVERITY"                = NULL,
                          "CVSSV2VECTOR"            = NULL,
                          "CVSSV2SCORE"             = NULL,
                          "CVSSV3VECTOR"            = NULL,
                          "CVSSV3SCORE"             = NULL,
                          "OWASPVECTOR"             = NULL,
                          "OWASPSCORE"              = NULL,
                          "VULNERABILITY_POLICY_ID" = NULL
                        FROM
                          "ANALYSIS" AS "OLD" -- Self-join to get access to pre-update values
                        WHERE
                          "NEW"."ID" = "OLD"."ID"
                          AND "NEW"."VULNERABILITY_POLICY_ID" IS NOT NULL
                          AND "NEW"."VULNERABILITY_POLICY_ID" = (SELECT "ID" FROM "CTE_VULN_POLICY")
                        RETURNING
                          "OLD"."ID",
                          "OLD"."STATE",
                          "OLD"."JUSTIFICATION",
                          "OLD"."RESPONSE",
                          "OLD"."DETAILS",
                          "OLD"."SUPPRESSED",
                          "OLD"."SEVERITY",
                          "OLD"."CVSSV2VECTOR",
                          "OLD"."CVSSV2SCORE",
                          "OLD"."CVSSV3VECTOR",
                          "OLD"."CVSSV3SCORE",
                          "OLD"."OWASPVECTOR",
                          "OLD"."OWASPSCORE"
                        """)
                .bind("name", name)
                .executeAndReturnGeneratedKeys()
                .map(new AnalysisRowMapper())
                .list();
    }

    /**
     * Un-assign a given {@link VulnerabilityPolicy} from any associated {@link Analysis}
     * records, reset the analyses' states, and populate the audit trail accordingly.
     *
     * @param name Name of the {@link VulnerabilityPolicy} to un-assign
     */
    default void unassignAndDeleteByName(String name) {
        final List<Analysis> unassignedAnalyses = unassignFromAnalysesByName(name);
        deleteByName(name);

        final var analysisIds = new ArrayList<Long>();
        final var comments = new ArrayList<String>();
        for (final Analysis analysis : unassignedAnalyses) {
            analysisIds.add(analysis.getId());
            comments.add("Policy removed");

            Optional.ofNullable(analysis.getAnalysisState()).ifPresent(oldState -> {
                analysisIds.add(analysis.getId());
                comments.add(formatComment(AnalysisCommentField.STATE, oldState, null));
            });
            Optional.ofNullable(analysis.getAnalysisJustification()).ifPresent(oldJustification -> {
                analysisIds.add(analysis.getId());
                comments.add(formatComment(AnalysisCommentField.JUSTIFICATION, oldJustification, null));
            });
            Optional.ofNullable(analysis.getAnalysisResponse()).ifPresent(oldResponse -> {
                analysisIds.add(analysis.getId());
                comments.add(formatComment(AnalysisCommentField.RESPONSE, oldResponse, null));
            });
            Optional.ofNullable(analysis.getAnalysisDetails()).ifPresent(oldDetails -> {
                analysisIds.add(analysis.getId());
                comments.add(formatComment(AnalysisCommentField.DETAILS, oldDetails, null));
            });
            // SUPPRESSED is not nullable; Can only be changed if it was previously true
            Optional.of(analysis.isSuppressed()).filter(Boolean.TRUE::equals).ifPresent(oldSuppressed -> {
                analysisIds.add(analysis.getId());
                comments.add(formatComment(AnalysisCommentField.SUPPRESSED, oldSuppressed, false));
            });
            Optional.ofNullable(analysis.getSeverity()).ifPresent(oldSeverity -> {
                analysisIds.add(analysis.getId());
                comments.add(formatComment(AnalysisCommentField.SEVERITY, oldSeverity, null));
            });
            Optional.ofNullable(analysis.getCvssV2Vector()).ifPresent(oldVector -> {
                analysisIds.add(analysis.getId());
                comments.add(formatComment(AnalysisCommentField.CVSSV2_VECTOR, oldVector, null));
            });
            Optional.ofNullable(analysis.getCvssV2Score()).ifPresent(oldScore -> {
                analysisIds.add(analysis.getId());
                comments.add(formatComment(AnalysisCommentField.CVSSV2_SCORE, oldScore, null));
            });
            Optional.ofNullable(analysis.getCvssV3Vector()).ifPresent(oldVector -> {
                analysisIds.add(analysis.getId());
                comments.add(formatComment(AnalysisCommentField.CVSSV3_VECTOR, oldVector, null));
            });
            Optional.ofNullable(analysis.getCvssV3Score()).ifPresent(oldScore -> {
                analysisIds.add(analysis.getId());
                comments.add(formatComment(AnalysisCommentField.CVSSV3_SCORE, oldScore, null));
            });
            Optional.ofNullable(analysis.getOwaspVector()).ifPresent(oldVector -> {
                analysisIds.add(analysis.getId());
                comments.add(formatComment(AnalysisCommentField.OWASP_VECTOR, oldVector, null));
            });
            Optional.ofNullable(analysis.getOwaspScore()).ifPresent(oldScore -> {
                analysisIds.add(analysis.getId());
                comments.add(formatComment(AnalysisCommentField.OWASP_SCORE, oldScore, null));
            });
        }

        final var commenter = "[Policy{Name=%s}]".formatted(name);
        final var analysisDao = getHandle().attach(AnalysisDao.class);
        analysisDao.createComments(analysisIds, commenter, comments);
    }

}
