package org.dependencytrack.persistence.jdbi.mapping;

import com.fasterxml.jackson.core.type.TypeReference;
import org.dependencytrack.model.VulnerabilityAlias;
import org.dependencytrack.parser.common.resolver.CweResolver;
import org.dependencytrack.proto.notification.v1.Vulnerability;
import org.jdbi.v3.core.mapper.RowMapper;
import org.jdbi.v3.core.statement.StatementContext;

import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.Collections;
import java.util.List;
import java.util.Objects;

import static org.dependencytrack.persistence.jdbi.mapping.RowMapperUtil.deserializeJson;
import static org.dependencytrack.persistence.jdbi.mapping.RowMapperUtil.maybeSet;
import static org.dependencytrack.persistence.jdbi.mapping.RowMapperUtil.stringArray;

public class NotificationVulnerabilityRowMapper implements RowMapper<Vulnerability> {

    private static final TypeReference<List<VulnerabilityAlias>> VULNERABILITY_ALIASES_TYPE_REF = new TypeReference<>() {
    };

    @Override
    public Vulnerability map(final ResultSet rs, final StatementContext ctx) throws SQLException {
        final Vulnerability.Builder builder = Vulnerability.newBuilder();
        maybeSet(rs, "vulnUuid", ResultSet::getString, builder::setUuid);
        maybeSet(rs, "vulnId", ResultSet::getString, builder::setVulnId);
        maybeSet(rs, "vulnSource", ResultSet::getString, builder::setSource);
        maybeSet(rs, "vulnTitle", ResultSet::getString, builder::setTitle);
        maybeSet(rs, "vulnSubTitle", ResultSet::getString, builder::setSubTitle);
        maybeSet(rs, "vulnDescription", ResultSet::getString, builder::setDescription);
        maybeSet(rs, "vulnRecommendation", ResultSet::getString, builder::setRecommendation);
        maybeSet(rs, "vulnCvssV2BaseScore", RowMapperUtil::nullableDouble, builder::setCvssV2);
        maybeSet(rs, "vulnCvssV3BaseScore", RowMapperUtil::nullableDouble, builder::setCvssV3);
        maybeSet(rs, "vulnOwaspRrBusinessImpactScore", RowMapperUtil::nullableDouble, builder::setOwaspRrBusinessImpact);
        maybeSet(rs, "vulnOwaspRrLikelihoodScore", RowMapperUtil::nullableDouble, builder::setOwaspRrLikelihood);
        maybeSet(rs, "vulnOwaspRrTechnicalImpactScore", RowMapperUtil::nullableDouble, builder::setOwaspRrTechnicalImpact);
        maybeSet(rs, "vulnSeverity", ResultSet::getString, builder::setSeverity);
        maybeSet(rs, "vulnCwes", NotificationVulnerabilityRowMapper::maybeConvertCwes, builder::addAllCwes);
        maybeSet(rs, "vulnAliasesJson", (ignored, columnName) ->
                maybeConvertAliases(rs, columnName, builder.getVulnId(), builder.getSource()), builder::addAllAliases);
        return builder.build();
    }

    private static List<Vulnerability.Cwe> maybeConvertCwes(final ResultSet rs, final String columnName) throws SQLException {
        return stringArray(rs, columnName).stream()
                .map(CweResolver.getInstance()::lookup)
                .filter(Objects::nonNull)
                .map(cwe -> Vulnerability.Cwe.newBuilder()
                        .setCweId(cwe.getCweId())
                        .setName(cwe.getName())
                        .build())
                .toList();
    }

    private static List<Vulnerability.Alias> maybeConvertAliases(final ResultSet rs, final String columnName,
                                                                 final String selfId, final String selfSource) throws SQLException {
        final List<VulnerabilityAlias> aliases = deserializeJson(rs, columnName, VULNERABILITY_ALIASES_TYPE_REF);
        if (aliases == null) {
            return Collections.emptyList();
        }

        return aliases.stream()
                .flatMap(alias -> alias.getAllBySource().entrySet().stream()
                        // Don't include the vulnerability itself as alias again.
                        .filter(aliasEntry -> !selfId.equals(aliasEntry.getValue()) || !selfSource.equals(aliasEntry.getKey().name()))
                        .map(aliasEntry -> Vulnerability.Alias.newBuilder()
                                .setSource(aliasEntry.getKey().name())
                                .setId(aliasEntry.getValue())
                                .build()))
                .distinct()
                .toList();
    }

}
