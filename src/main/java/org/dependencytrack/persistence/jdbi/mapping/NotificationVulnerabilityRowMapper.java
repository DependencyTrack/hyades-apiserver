package org.dependencytrack.persistence.jdbi.mapping;

import com.fasterxml.jackson.core.JacksonException;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.apache.commons.lang3.StringUtils;
import org.dependencytrack.model.VulnerabilityAlias;
import org.dependencytrack.parser.common.resolver.CweResolver;
import org.dependencytrack.proto.notification.v1.Vulnerability;
import org.jdbi.v3.core.mapper.RowMapper;
import org.jdbi.v3.core.statement.StatementContext;

import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.Objects;
import java.util.Optional;

import static org.apache.commons.lang3.StringUtils.isBlank;
import static org.apache.commons.lang3.StringUtils.trimToEmpty;

public class NotificationVulnerabilityRowMapper implements RowMapper<Vulnerability> {

    private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper();
    private static final TypeReference<List<VulnerabilityAlias>> VULNERABILITY_ALIASES_TYPE_REF = new TypeReference<>() {
    };

    @Override
    public Vulnerability map(final ResultSet rs, final StatementContext ctx) throws SQLException {
        final String vulnId = trimToEmpty(rs.getString("vulnId"));
        final String vulnSource = trimToEmpty(rs.getString("vulnSource"));
        return Vulnerability.newBuilder()
                .setUuid(trimToEmpty(rs.getString("vulnUuid")))
                .setVulnId(vulnId)
                .setSource(vulnSource)
                .setTitle(trimToEmpty(rs.getString("vulnTitle")))
                .setSubTitle(trimToEmpty(rs.getString("vulnSubTitle")))
                .setDescription(trimToEmpty(rs.getString("vulnDescription")))
                .setRecommendation(trimToEmpty(rs.getString("vulnRecommendation")))
                .setCvssV2(rs.getDouble("vulnCvssV2BaseScore"))
                .setCvssV3(rs.getDouble("vulnCvssV3BaseScore"))
                .setOwaspRrBusinessImpact(rs.getDouble("vulnOwaspRrBusinessImpactScore"))
                .setOwaspRrLikelihood(rs.getDouble("vulnOwaspRrLikelihoodScore"))
                .setOwaspRrTechnicalImpact(rs.getDouble("vulnOwaspRrTechnicalImpactScore"))
                .setSeverity(trimToEmpty(rs.getString("vulnSeverity")))
                .addAllCwes(Optional.ofNullable(rs.getString("vulnCwes")).stream()
                        .flatMap(cwes -> Arrays.stream(cwes.split(",")))
                        .map(StringUtils::trimToNull)
                        .filter(Objects::nonNull)
                        .map(CweResolver.getInstance()::lookup)
                        .filter(Objects::nonNull)
                        .map(cwe -> Vulnerability.Cwe.newBuilder()
                                .setCweId(cwe.getCweId())
                                .setName(cwe.getName())
                                .build())
                        .toList())
                .addAllAliases(maybeDeserializeAliases(rs.getString("vulnAliasesJson"), vulnId, vulnSource))
                .build();
    }

    private static List<Vulnerability.Alias> maybeDeserializeAliases(final String aliasesJson, final String selfId, final String selfSource) {
        if (isBlank(aliasesJson)) {
            return Collections.emptyList();
        }

        final List<VulnerabilityAlias> aliases;
        try {
            aliases = OBJECT_MAPPER.readValue(aliasesJson, VULNERABILITY_ALIASES_TYPE_REF);
        } catch (JacksonException e) {
            throw new RuntimeException("Failed to deserialize aliases from JSON: %s".formatted(aliasesJson), e);
        }

        return aliases.stream()
                .flatMap(alias -> alias.getAllBySource().entrySet().stream()
                        // Don't include the vulnerability itself as alias again.
                        .filter(aliasEntry -> !selfId.equals(aliasEntry.getValue()) || !selfSource.equals(aliasEntry.getKey().name()))
                        .map(aliasEntry -> Vulnerability.Alias.newBuilder()
                                .setSource(aliasEntry.getKey().name())
                                .setId(aliasEntry.getValue())
                                .build()))
                .distinct()
                .toList();
    }

}
