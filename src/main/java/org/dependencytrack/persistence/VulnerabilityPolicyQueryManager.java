package org.dependencytrack.persistence;

import alpine.common.logging.Logger;
import alpine.persistence.OrderDirection;
import alpine.persistence.PaginatedResult;
import alpine.resources.AlpineRequest;
import alpine.server.util.DbUtil;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.datatype.jsonorg.JsonOrgModule;
import org.apache.commons.collections4.multimap.ArrayListValuedHashMap;
import org.apache.commons.lang3.tuple.Pair;
import org.dependencytrack.model.VulnerabilityPolicy;
import org.dependencytrack.persistence.jdbi.mapping.RowMapperUtil;
import org.dependencytrack.policy.vulnerability.VulnerabilityPolicyAnalysis;
import org.dependencytrack.util.AnalysisCommentFormatter.AnalysisCommentField;
import org.json.JSONObject;

import javax.jdo.PersistenceManager;
import java.sql.Array;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Date;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;

import static org.dependencytrack.util.AnalysisCommentFormatter.formatComment;

public class VulnerabilityPolicyQueryManager extends QueryManager implements IQueryManager {
    private static final Logger LOGGER = Logger.getLogger(VulnerabilityPolicyQueryManager.class);

    private static final ObjectMapper MAPPER = new ObjectMapper().registerModule(new JsonOrgModule());

    VulnerabilityPolicyQueryManager(final PersistenceManager pm) {
        super(pm);
    }

    VulnerabilityPolicyQueryManager(final PersistenceManager pm, final AlpineRequest request) {
        super(pm, request);
    }

    @Override
    public int createVulnerabilityPolicy(VulnerabilityPolicy vulnerabilityPolicy, Connection connection) {
        String createQuery = """
                INSERT INTO "VULNERABILITY_POLICY"(
                	"ANALYSIS", "AUTHOR", "CONDITIONS", "CREATED", "DESCRIPTION", "NAME", "RATINGS", "VALID_FROM", "VALID_UNTIL")
                	VALUES (?::JSON, ?, ?, ?, ?, ?, ?::JSON, ?, ?);
                """;
        PreparedStatement preparedStatement = null;
        Connection localConnection = null;
        Array conditions = null;
        try {
            String analysis = vulnerabilityPolicy.getAnalysis() != null
                    ? MAPPER.writeValueAsString(vulnerabilityPolicy.getAnalysis())
                    : null;
            String ratings = vulnerabilityPolicy.getRatings() != null
                    ? MAPPER.writeValueAsString(vulnerabilityPolicy.getRatings())
                    : null;
            if (connection == null) {
                localConnection = (Connection) pm.getDataStoreConnection();
                preparedStatement = localConnection.prepareStatement(createQuery);
                conditions = localConnection.createArrayOf("text", vulnerabilityPolicy.getConditions());
            } else {
                preparedStatement = connection.prepareStatement(createQuery);
                conditions = connection.createArrayOf("text", vulnerabilityPolicy.getConditions());
            }
            preparedStatement.setObject(1, analysis);
            preparedStatement.setString(2, vulnerabilityPolicy.getAuthor());
            preparedStatement.setArray(3, conditions);
            preparedStatement.setTimestamp(4, vulnerabilityPolicy.getCreated() != null ? new java.sql.Timestamp(vulnerabilityPolicy.getCreated().getTime()) : null);
            preparedStatement.setString(5, vulnerabilityPolicy.getDescription());
            preparedStatement.setString(6, vulnerabilityPolicy.getName());
            preparedStatement.setObject(7, ratings);
            preparedStatement.setTimestamp(8, vulnerabilityPolicy.getValidFrom() != null ? new java.sql.Timestamp(vulnerabilityPolicy.getValidFrom().getTime()) : null);
            preparedStatement.setTimestamp(9, vulnerabilityPolicy.getValidUntil() != null ? new java.sql.Timestamp(vulnerabilityPolicy.getValidUntil().getTime()) : null);

            return preparedStatement.executeUpdate();
        } catch (Exception ex) {
            LOGGER.error("Error in creating vulnerability policy", ex);
            throw new RuntimeException(ex);
        } finally {
            DbUtil.close(preparedStatement);
            if (localConnection != null) {
                DbUtil.close(localConnection);
            }
        }
    }

    @Override
    public List<VulnerabilityPolicy> getAllVulnerabilityPolicies() {
        String selectQuery = """
                SELECT "ID", "ANALYSIS", "AUTHOR", "CONDITIONS", "CREATED", "DESCRIPTION", "NAME", "RATINGS", "UPDATED", "VALID_FROM", "VALID_UNTIL"
                	FROM "VULNERABILITY_POLICY";
                """;

        Connection connection = null;
        PreparedStatement preparedStatement = null;
        ArrayList vulnerabilityPolicies = new ArrayList<VulnerabilityPolicy>();
        try {
            connection = (Connection) pm.getDataStoreConnection();
            preparedStatement = connection.prepareStatement(selectQuery);
            ResultSet rs = preparedStatement.executeQuery();
            while (rs.next()) {
                VulnerabilityPolicy vulnerabilityPolicy = mapVulnerabilityPolicyResultSet(rs);
                vulnerabilityPolicies.add(vulnerabilityPolicy);
            }
        } catch (Exception ex) {
            LOGGER.error("Error in getting all vulnerability policies", ex);
            throw new RuntimeException(ex);
        } finally {
            DbUtil.close(preparedStatement);
            DbUtil.close(connection);
        }
        return vulnerabilityPolicies;
    }


    public PaginatedResult getAllVulnerabilityPolicies(String name, Date validFrom, Date validUntil) {

        String selectQuery = """
                SELECT "ID", "ANALYSIS", "AUTHOR", "CONDITIONS", "CREATED", "DESCRIPTION", "NAME", "RATINGS", "UPDATED", "VALID_FROM", "VALID_UNTIL", COUNT(*) OVER() AS "totalCount"
                FROM "VULNERABILITY_POLICY"
                """;
        Pair<ArrayList, Map<String, Object>> queryFilterAndParamsPair = buildQueryFilterParams(name, validFrom, validUntil);
        selectQuery += String.join(" ", queryFilterAndParamsPair.getLeft());
        selectQuery += buildOrderBySubQuery();
        selectQuery = addPaginationToQuery(selectQuery);

        Map<String, Object> queryParams = queryFilterAndParamsPair.getRight();

        Connection connection = null;
        PreparedStatement preparedStatement = null;
        ResultSet rs = null;
        int totalCount = 0;
        ArrayList vulnerabilityPolicies = new ArrayList<VulnerabilityPolicy>();
        try {
            connection = (Connection) pm.getDataStoreConnection();
            preparedStatement = connection.prepareStatement(selectQuery);

            if (!queryParams.isEmpty()) {
                int position = 0;
                for (var entry : queryParams.entrySet()) {
                    if ("NAME".equalsIgnoreCase(entry.getKey())) {
                        preparedStatement.setString(++position, (String) entry.getValue());
                    } else if ("VALID_FROM".equalsIgnoreCase(entry.getKey()) || "VALID_UNTIL".equalsIgnoreCase(entry.getKey())) {
                        preparedStatement.setTimestamp(++position, new java.sql.Timestamp(((Date) entry.getValue()).getTime()));
                    }
                }
            }

            rs = preparedStatement.executeQuery();
            while (rs.next()) {
                VulnerabilityPolicy vulnerabilityPolicy = mapVulnerabilityPolicyResultSet(rs);
                totalCount = rs.getInt("totalCount");
                vulnerabilityPolicies.add(vulnerabilityPolicy);
            }
        } catch (Exception ex) {
            LOGGER.error("Error in fetching paginated vulnerability policies", ex);
            throw new RuntimeException(ex);
        } finally {
            DbUtil.close(preparedStatement);
            DbUtil.close(connection);
        }
        return (new PaginatedResult()).objects(vulnerabilityPolicies).total(totalCount);
    }

    @Override
    public VulnerabilityPolicy getVulnerabilityPolicyByName(String name) {
        String selectQuery = """
                SELECT "ID", "ANALYSIS", "AUTHOR", "CONDITIONS", "CREATED", "DESCRIPTION", "NAME", "RATINGS", "UPDATED", "VALID_FROM", "VALID_UNTIL"
                	FROM "VULNERABILITY_POLICY" WHERE "NAME" = ?;
                """;

        Connection connection = null;
        PreparedStatement preparedStatement = null;
        VulnerabilityPolicy vulnerabilityPolicy = new VulnerabilityPolicy();
        try {
            connection = (Connection) pm.getDataStoreConnection();
            preparedStatement = connection.prepareStatement(selectQuery);
            preparedStatement.setString(1, name);
            ResultSet rs = preparedStatement.executeQuery();
            while (rs.next()) {
                vulnerabilityPolicy = mapVulnerabilityPolicyResultSet(rs);
            }
        } catch (Exception ex) {
            LOGGER.error("Error in getting vulnerability policy by name", ex);
            throw new RuntimeException(ex);
        } finally {
            DbUtil.close(preparedStatement);
            DbUtil.close(connection);
        }
        return vulnerabilityPolicy;
    }

    @Override
    public int deleteVulnerabilityPolicyByName(String vulnerabilityPolicyName, Connection connection) {
        unassignVulnerabilityPolicyByName(vulnerabilityPolicyName, connection);

        Connection localConnection = null;
        //Name is unique
        String deleteQuery = """
                DELETE FROM "VULNERABILITY_POLICY" WHERE "NAME" = ?;
                """;
        PreparedStatement preparedStatement = null;
        try {
            if (connection == null) {
                localConnection = (Connection) pm.getDataStoreConnection();
                preparedStatement = localConnection.prepareStatement(deleteQuery);
            } else {
                preparedStatement = connection.prepareStatement(deleteQuery);
            }
            preparedStatement.setString(1, vulnerabilityPolicyName);
            return preparedStatement.executeUpdate();
        } catch (Exception ex) {
            LOGGER.error("Error in deleting vulnerability policy", ex);
            throw new RuntimeException(ex);
        } finally {
            DbUtil.close(preparedStatement);
            if (localConnection != null) {
                DbUtil.close(localConnection);
            }
        }
    }

    /**
     * Un-assign a given {@link VulnerabilityPolicy} from any associated {@link org.dependencytrack.model.Analysis}
     * records, reset the analyses' states, and populate the audit trail accordingly.
     *
     * @param policyName Name of the {@link VulnerabilityPolicy} to un-assign
     * @param connection The {@link Connection} to use
     */
    private void unassignVulnerabilityPolicyByName(final String policyName, Connection connection) {
        final boolean isLocalConnection = connection == null;
        connection = isLocalConnection
                ? (Connection) pm.getDataStoreConnection()
                : connection;
        try {
            final var analysisComments = new ArrayListValuedHashMap<Long, String>();
            try (final var ps = connection.prepareStatement("""
                    WITH "CTE_VULN_POLICY" AS (
                      SELECT
                        "ID"
                      FROM
                        "VULNERABILITY_POLICY"
                      WHERE
                        "NAME" = ?
                    )
                    UPDATE
                      "ANALYSIS" AS "NEW"
                    SET
                      "STATE"                   = 'NOT_SET', -- Must be non-null
                      "JUSTIFICATION"           = NULL,
                      "RESPONSE"                = NULL,
                      "DETAILS"                 = NULL,
                      "SUPPRESSED"              = FALSE,
                      "SEVERITY"                = NULL,
                      "CVSSV2VECTOR"            = NULL,
                      "CVSSV2SCORE"             = NULL,
                      "CVSSV3VECTOR"            = NULL,
                      "CVSSV3SCORE"             = NULL,
                      "OWASPVECTOR"             = NULL,
                      "OWASPSCORE"              = NULL,
                      "VULNERABILITY_POLICY_ID" = NULL
                    FROM
                      "ANALYSIS" AS "OLD" -- Self-join to get access to pre-update values
                    WHERE
                      "NEW"."ID" = "OLD"."ID"
                      AND "NEW"."VULNERABILITY_POLICY_ID" IS NOT NULL
                      AND "NEW"."VULNERABILITY_POLICY_ID" = (SELECT "ID" FROM "CTE_VULN_POLICY")
                    RETURNING
                      "OLD"."ID",
                      "OLD"."STATE",
                      "OLD"."JUSTIFICATION",
                      "OLD"."RESPONSE",
                      "OLD"."DETAILS",
                      "OLD"."SUPPRESSED",
                      "OLD"."SEVERITY",
                      "OLD"."CVSSV2VECTOR",
                      "OLD"."CVSSV2SCORE",
                      "OLD"."CVSSV3VECTOR",
                      "OLD"."CVSSV3SCORE",
                      "OLD"."OWASPVECTOR",
                      "OLD"."OWASPSCORE"
                    """, PreparedStatement.RETURN_GENERATED_KEYS)) {
                ps.setString(1, policyName);
                final int updatedRows = ps.executeUpdate();
                if (updatedRows == 0) {
                    return;
                }

                try (final ResultSet rs = ps.getGeneratedKeys()) {
                    while (rs.next()) {
                        final long analysisId = rs.getLong(1);
                        analysisComments.put(analysisId, "Policy removed");
                        Optional.ofNullable(rs.getString("STATE"))
                                .ifPresent(oldState -> analysisComments.put(analysisId, formatComment(AnalysisCommentField.STATE, oldState, null)));
                        Optional.ofNullable(rs.getString("JUSTIFICATION"))
                                .ifPresent(oldJustification -> analysisComments.put(analysisId, formatComment(AnalysisCommentField.JUSTIFICATION, oldJustification, null)));
                        Optional.ofNullable(rs.getString("RESPONSE"))
                                .ifPresent(oldResponse -> analysisComments.put(analysisId, formatComment(AnalysisCommentField.RESPONSE, oldResponse, null)));
                        Optional.ofNullable(rs.getString("DETAILS"))
                                .ifPresent(oldDetails -> analysisComments.put(analysisId, formatComment(AnalysisCommentField.DETAILS, oldDetails, null)));
                        Optional.of(rs.getBoolean("SUPPRESSED"))
                                .filter(Boolean.TRUE::equals) // SUPPRESSED is not nullable; Can only be changed if it was previously true
                                .ifPresent(oldSuppressed -> analysisComments.put(analysisId, formatComment(AnalysisCommentField.SUPPRESSED, oldSuppressed, false)));
                        Optional.ofNullable(rs.getString("SEVERITY"))
                                .ifPresent(oldSeverity -> analysisComments.put(analysisId, formatComment(AnalysisCommentField.SEVERITY, oldSeverity, null)));
                        Optional.ofNullable(rs.getString("CVSSV2VECTOR"))
                                .ifPresent(oldVector -> analysisComments.put(analysisId, formatComment(AnalysisCommentField.CVSSV2_VECTOR, oldVector, null)));
                        Optional.ofNullable(RowMapperUtil.nullableDouble(rs, "CVSSV2SCORE"))
                                .ifPresent(oldScore -> analysisComments.put(analysisId, formatComment(AnalysisCommentField.CVSSV2_SCORE, oldScore, null)));
                        Optional.ofNullable(rs.getString("CVSSV3VECTOR"))
                                .ifPresent(oldVector -> analysisComments.put(analysisId, formatComment(AnalysisCommentField.CVSSV3_VECTOR, oldVector, null)));
                        Optional.ofNullable(RowMapperUtil.nullableDouble(rs, "CVSSV3SCORE"))
                                .ifPresent(oldScore -> analysisComments.put(analysisId, formatComment(AnalysisCommentField.CVSSV3_SCORE, oldScore, null)));
                        Optional.ofNullable(rs.getString("OWASPVECTOR"))
                                .ifPresent(oldVector -> analysisComments.put(analysisId, formatComment(AnalysisCommentField.OWASP_VECTOR, oldVector, null)));
                        Optional.ofNullable(RowMapperUtil.nullableDouble(rs, "OWASPSCORE"))
                                .ifPresent(oldScore -> analysisComments.put(analysisId, formatComment(AnalysisCommentField.OWASP_SCORE, oldScore, null)));
                    }
                }
            }

            try (final var ps = connection.prepareStatement("""
                    INSERT INTO "ANALYSISCOMMENT"
                      ("ANALYSIS_ID", "TIMESTAMP", "COMMENTER", "COMMENT")
                    VALUES
                      (?, NOW(), ?, ?)
                    """)) {
                // There may be a point at which doing this in a single batch is not feasible anymore.
                for (final Map.Entry<Long, String> entry : analysisComments.entries()) {
                    ps.setLong(1, entry.getKey());
                    ps.setString(2, "[Policy{Name=%s}]".formatted(policyName));
                    ps.setString(3, entry.getValue());
                    ps.addBatch();
                }

                ps.executeBatch();
            }
        } catch (Exception e) {
            throw new RuntimeException("Failed to un-assign vulnerability policy %s from analyses".formatted(policyName), e);
        } finally {
            if (isLocalConnection) {
                DbUtil.close(connection);
            }
        }
    }

    public int updateVulnerabilityPolicyByName(VulnerabilityPolicy vulnerabilityPolicy, Connection connection) {
        String createQuery = """
                UPDATE "VULNERABILITY_POLICY"
                	SET "ANALYSIS"=?::JSON, "AUTHOR"=?, "CONDITIONS"=?, "DESCRIPTION"=?, "RATINGS"=?::JSON, "UPDATED"=?, "VALID_FROM"=?, "VALID_UNTIL"=?
                	WHERE "NAME" = ?;
                                """;
        PreparedStatement preparedStatement = null;
        Connection localConnection = null;
        Array conditions = null;
        try {
            String analysis = vulnerabilityPolicy.getAnalysis() != null
                    ? MAPPER.writeValueAsString(vulnerabilityPolicy.getAnalysis())
                    : null;
            String ratings = vulnerabilityPolicy.getRatings() != null
                    ? MAPPER.writeValueAsString(vulnerabilityPolicy.getRatings())
                    : null;
            if (connection == null) {
                localConnection = (Connection) pm.getDataStoreConnection();
                preparedStatement = localConnection.prepareStatement(createQuery);
                conditions = localConnection.createArrayOf("text", vulnerabilityPolicy.getConditions());
            } else {
                preparedStatement = connection.prepareStatement(createQuery);
                conditions = connection.createArrayOf("text", vulnerabilityPolicy.getConditions());
            }
            preparedStatement.setObject(1, analysis);
            preparedStatement.setString(2, vulnerabilityPolicy.getAuthor());
            preparedStatement.setArray(3, conditions);
            preparedStatement.setString(4, vulnerabilityPolicy.getDescription());
            preparedStatement.setObject(5, ratings);
            preparedStatement.setTimestamp(6, vulnerabilityPolicy.getUpdated() != null ? new java.sql.Timestamp(vulnerabilityPolicy.getUpdated().getTime()) : null);
            preparedStatement.setTimestamp(7, vulnerabilityPolicy.getValidFrom() != null ? new java.sql.Timestamp(vulnerabilityPolicy.getValidFrom().getTime()) : null);
            preparedStatement.setTimestamp(8, vulnerabilityPolicy.getValidUntil() != null ? new java.sql.Timestamp(vulnerabilityPolicy.getValidUntil().getTime()) : null);
            preparedStatement.setString(9, vulnerabilityPolicy.getName());

            return preparedStatement.executeUpdate();
        } catch (Exception ex) {
            LOGGER.error("Error in creating vulnerability policy", ex);
            throw new RuntimeException(ex);
        } finally {
            DbUtil.close(preparedStatement);
            if (localConnection != null) {
                DbUtil.close(localConnection);
            }
        }
    }

    private String buildOrderBySubQuery() {
        String orderBySubQuery = null;
        if (orderBy == null) {
            orderBySubQuery =
                    """
                                ORDER BY "NAME" 
                            """;
        } else {
            orderBySubQuery =
                    "ORDER BY " + "\"" + mapFieldName(orderBy) + "\"";
        }
        if (orderDirection == OrderDirection.ASCENDING) {
            orderBySubQuery += " ASC ";
        } else if (orderDirection == OrderDirection.DESCENDING) {
            orderBySubQuery += " DESC ";
        }
        orderBySubQuery += """
                , "ID"
                """;
        return orderBySubQuery;
    }

    private static String mapFieldName(String fieldName) {
        if (fieldName == null) {
            return null;
        }
        return switch (fieldName.toUpperCase()) {
            case "NAME", "AUTHOR", "CREATED", "UPDATED" -> fieldName.toUpperCase();
            case "VALIDFROM" -> "VALID_FROM";
            case "VALIDUNTIL" -> "VALID_UNTIL";
            default -> throw new IllegalArgumentException("Ordering not supported");
        };
    }

    private String addPaginationToQuery(final String query) {
        if (pagination != null && pagination.isPaginated()) {
            return query +
                    """
                                OFFSET %d
                                LIMIT %d;
                            """.formatted(pagination.getOffset(), pagination.getLimit());
        }
        return query;
    }

    private static VulnerabilityPolicy mapVulnerabilityPolicyResultSet(ResultSet rs) throws SQLException, JsonProcessingException {
        VulnerabilityPolicy vulnerabilityPolicy = new VulnerabilityPolicy();
        vulnerabilityPolicy.setId(rs.getLong("ID"));
        JSONObject analysisJson = new JSONObject(rs.getString("ANALYSIS"));
        vulnerabilityPolicy.setAnalysis(MAPPER.convertValue(analysisJson, VulnerabilityPolicyAnalysis.class));
        vulnerabilityPolicy.setAuthor(rs.getString("AUTHOR"));
        Array conditions = rs.getArray("CONDITIONS");
        vulnerabilityPolicy.setConditions((String[]) conditions.getArray());
        vulnerabilityPolicy.setCreated(rs.getTimestamp("CREATED"));
        vulnerabilityPolicy.setDescription(rs.getString("DESCRIPTION"));
        vulnerabilityPolicy.setName(rs.getString("NAME"));
        String ratings = rs.getString("RATINGS");
        vulnerabilityPolicy.setRatings(ratings != null ? (MAPPER.readValue(ratings, new TypeReference<>() {
        })) : null);
        vulnerabilityPolicy.setUpdated(rs.getTimestamp("UPDATED"));
        vulnerabilityPolicy.setValidFrom(rs.getTimestamp("VALID_FROM"));
        vulnerabilityPolicy.setValidUntil(rs.getTimestamp("VALID_UNTIL"));
        return vulnerabilityPolicy;
    }

    private static Pair<ArrayList, Map<String, Object>> buildQueryFilterParams(String name, Date validFrom, Date validUntil) {
        ArrayList<String> queryFilterElements = new ArrayList<>();
        Map<String, Object> queryParams = new LinkedHashMap<>();

        if (name != null || validFrom != null || validUntil != null) {
            queryFilterElements.add("WHERE ");
            if (name != null) {
                queryFilterElements.add("\"NAME\" = ? ");
                queryParams.put("NAME", name);
            }
            if (validFrom != null) {
                if (queryParams.isEmpty()) {
                    queryFilterElements.add(" \"VALID_FROM\" >= ? ");
                } else {
                    queryFilterElements.add(" AND \"VALID_FROM\" >= ? ");
                }
                queryParams.put("VALID_FROM", validFrom);
            }
            if (validUntil != null) {
                if (queryParams.isEmpty()) {
                    queryFilterElements.add(" \"VALID_UNTIL\" <= ? ");
                } else {
                    queryFilterElements.add(" AND \"VALID_UNTIL\" <= ? ");
                }
                queryParams.put("VALID_UNTIL", validUntil);
            }
        }
        return Pair.of(queryFilterElements, queryParams);
    }
}
