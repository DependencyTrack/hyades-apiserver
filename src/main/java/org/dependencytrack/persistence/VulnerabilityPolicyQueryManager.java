package org.dependencytrack.persistence;

import alpine.common.logging.Logger;
import alpine.resources.AlpineRequest;
import alpine.server.util.DbUtil;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.datatype.jsonorg.JsonOrgModule;
import org.dependencytrack.model.VulnerabilityPolicy;
import org.dependencytrack.policy.vulnerability.VulnerabilityPolicyAnalysis;
import org.json.JSONArray;
import org.json.JSONObject;

import javax.jdo.PersistenceManager;
import java.sql.Array;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.util.ArrayList;
import java.util.List;

public class VulnerabilityPolicyQueryManager extends QueryManager implements IQueryManager {
    private static final Logger LOGGER = Logger.getLogger(VulnerabilityPolicyQueryManager.class);

    private static final ObjectMapper MAPPER = new ObjectMapper().registerModule(new JsonOrgModule());

    VulnerabilityPolicyQueryManager(final PersistenceManager pm) {
        super(pm);
    }

    VulnerabilityPolicyQueryManager(final PersistenceManager pm, final AlpineRequest request) {
        super(pm, request);
    }

    public int createVulnerabilityPolicy(VulnerabilityPolicy vulnerabilityPolicy) {
        String createQuery = """
                INSERT INTO "VULNERABILITY_POLICY"(
                	"ANALYSIS", "AUTHOR", "CONDITIONS", "CREATED", "DESCRIPTION", "NAME", "RATINGS", "VALID_FROM", "VALID_UNTIL")
                	VALUES (?::JSON, ?, ?, ?, ?, ?, ?::JSON, ?, ?);
                """;
        Connection connection = null;
        PreparedStatement preparedStatement = null;
        try {
            String analysis = MAPPER.writeValueAsString(vulnerabilityPolicy.getAnalysis());
            String ratings = MAPPER.writeValueAsString(vulnerabilityPolicy.getRatings());
            connection = (Connection) pm.getDataStoreConnection();
            preparedStatement = connection.prepareStatement(createQuery);
            Array conditions = connection.createArrayOf("text", vulnerabilityPolicy.getConditions());
            preparedStatement.setObject(1, analysis);
            preparedStatement.setString(2, vulnerabilityPolicy.getAuthor());
            preparedStatement.setArray(3, conditions);
            preparedStatement.setTimestamp(4, vulnerabilityPolicy.getCreated() != null ? new java.sql.Timestamp(vulnerabilityPolicy.getCreated().getTime()) : null);
            preparedStatement.setString(5, vulnerabilityPolicy.getDescription());
            preparedStatement.setString(6, vulnerabilityPolicy.getName());
            preparedStatement.setObject(7, ratings);
            preparedStatement.setTimestamp(8, vulnerabilityPolicy.getValidFrom() != null ? new java.sql.Timestamp(vulnerabilityPolicy.getValidFrom().getTime()) : null);
            preparedStatement.setTimestamp(9, vulnerabilityPolicy.getValidUntil() != null ? new java.sql.Timestamp(vulnerabilityPolicy.getValidUntil().getTime()) : null);

            return preparedStatement.executeUpdate();
        } catch (Exception ex) {
            LOGGER.error("Error in creating vulnerability policy", ex);
            throw new RuntimeException(ex);
        } finally {
            DbUtil.close(preparedStatement);
            DbUtil.close(connection);
        }
    }

    public List<VulnerabilityPolicy> getAllVulnerabilityPolicies() {
        String selectQuery = """
                SELECT "ID", "ANALYSIS", "AUTHOR", "CONDITIONS", "CREATED", "DESCRIPTION", "NAME", "RATINGS", "UPDATED", "VALID_FROM", "VALID_UNTIL"
                	FROM "VULNERABILITY_POLICY";
                """;

        Connection connection = null;
        PreparedStatement preparedStatement = null;
        ArrayList vulnerabilityPolicies = new ArrayList<VulnerabilityPolicy>();
        try {
            connection = (Connection) pm.getDataStoreConnection();
            preparedStatement = connection.prepareStatement(selectQuery);
            ResultSet rs = preparedStatement.executeQuery();
            while (rs.next()) {
                VulnerabilityPolicy vulnerabilityPolicy = new VulnerabilityPolicy();
                vulnerabilityPolicy.setId(rs.getLong("ID"));
                JSONObject analysisJson = new JSONObject(rs.getString("ANALYSIS"));
                vulnerabilityPolicy.setAnalysis(MAPPER.convertValue(analysisJson, VulnerabilityPolicyAnalysis.class));
                vulnerabilityPolicy.setAuthor(rs.getString("AUTHOR"));
                Array conditions = rs.getArray("CONDITIONS");
                vulnerabilityPolicy.setConditions((String[]) conditions.getArray());
                vulnerabilityPolicy.setCreated(rs.getTimestamp("CREATED"));
                vulnerabilityPolicy.setDescription(rs.getString("DESCRIPTION"));
                vulnerabilityPolicy.setName(rs.getString("NAME"));
                JSONArray ratingsJson = new JSONArray(rs.getString("RATINGS"));
                vulnerabilityPolicy.setRatings(MAPPER.convertValue(ratingsJson, new TypeReference<>() {
                }));
                vulnerabilityPolicy.setUpdated(rs.getTimestamp("UPDATED"));
                vulnerabilityPolicy.setValidFrom(rs.getTimestamp("VALID_FROM"));
                vulnerabilityPolicy.setValidUntil(rs.getTimestamp("VALID_UNTIL"));
                vulnerabilityPolicies.add(vulnerabilityPolicy);
            }
        } catch (Exception ex) {
            LOGGER.error("error in executing workflow state cte query to update states", ex);
            throw new RuntimeException(ex);
        } finally {
            DbUtil.close(preparedStatement);
            DbUtil.close(connection);
        }
        return vulnerabilityPolicies;
    }

    public VulnerabilityPolicy getVulnerabilityPolicyByName(String name) {
        String selectQuery = """
                SELECT "ID", "ANALYSIS", "AUTHOR", "CONDITIONS", "CREATED", "DESCRIPTION", "NAME", "RATINGS", "UPDATED", "VALID_FROM", "VALID_UNTIL"
                	FROM "VULNERABILITY_POLICY" WHERE "NAME" = ?;
                """;

        Connection connection = null;
        PreparedStatement preparedStatement = null;
        VulnerabilityPolicy vulnerabilityPolicy = new VulnerabilityPolicy();
        try {
            connection = (Connection) pm.getDataStoreConnection();
            preparedStatement = connection.prepareStatement(selectQuery);
            preparedStatement.setString(1, name);
            ResultSet rs = preparedStatement.executeQuery();
            while (rs.next()) {
                vulnerabilityPolicy.setId(rs.getLong("ID"));
                JSONObject analysisJson = new JSONObject(rs.getString("ANALYSIS"));
                vulnerabilityPolicy.setAnalysis(MAPPER.convertValue(analysisJson, VulnerabilityPolicyAnalysis.class));
                vulnerabilityPolicy.setAuthor(rs.getString("AUTHOR"));
                Array conditions = rs.getArray("CONDITIONS");
                vulnerabilityPolicy.setConditions((String[]) conditions.getArray());
                vulnerabilityPolicy.setCreated(rs.getTimestamp("CREATED"));
                vulnerabilityPolicy.setDescription(rs.getString("DESCRIPTION"));
                vulnerabilityPolicy.setName(rs.getString("NAME"));
                JSONArray ratingsJson = new JSONArray(rs.getString("RATINGS"));
                vulnerabilityPolicy.setRatings(MAPPER.convertValue(ratingsJson, new TypeReference<>() {
                }));
                vulnerabilityPolicy.setUpdated(rs.getTimestamp("UPDATED"));
                vulnerabilityPolicy.setValidFrom(rs.getTimestamp("VALID_FROM"));
                vulnerabilityPolicy.setValidUntil(rs.getTimestamp("VALID_UNTIL"));
            }
        } catch (Exception ex) {
            LOGGER.error("error in executing workflow state cte query to update states", ex);
            throw new RuntimeException(ex);
        } finally {
            DbUtil.close(preparedStatement);
            DbUtil.close(connection);
        }
        return vulnerabilityPolicy;
    }

    public int deleteVulnerabilityPolicyByName(String vulnerabilityPolicyName) {
        //Name is unique
        String deleteQuery = """
                DELETE FROM "VULNERABILITY_POLICY" WHERE "NAME" = ?;
                """;
        Connection connection = null;
        PreparedStatement preparedStatement = null;
        try {
            connection = (Connection) pm.getDataStoreConnection();
            preparedStatement = connection.prepareStatement(deleteQuery);
            preparedStatement.setString(1, vulnerabilityPolicyName);
            return preparedStatement.executeUpdate();
        } catch (Exception ex) {
            LOGGER.error("Error in creating vulnerability policy", ex);
            throw new RuntimeException(ex);
        } finally {
            DbUtil.close(preparedStatement);
            DbUtil.close(connection);
        }
    }

    public int updateVulnerabilityPolicyByName(VulnerabilityPolicy vulnerabilityPolicy) {
        String createQuery = """
                UPDATE "VULNERABILITY_POLICY"
                	SET "ANALYSIS"=?::JSON, "AUTHOR"=?, "CONDITIONS"=?, "DESCRIPTION"=?, "RATINGS"=?::JSON, "UPDATED"=?, "VALID_FROM"=?, "VALID_UNTIL"=?
                	WHERE "NAME" = ?;
                                """;
        Connection connection = null;
        PreparedStatement preparedStatement = null;
        try {
            String analysis = MAPPER.writeValueAsString(vulnerabilityPolicy.getAnalysis());
            String ratings = MAPPER.writeValueAsString(vulnerabilityPolicy.getRatings());
            connection = (Connection) pm.getDataStoreConnection();
            preparedStatement = connection.prepareStatement(createQuery);
            Array conditions = connection.createArrayOf("text", vulnerabilityPolicy.getConditions());
            preparedStatement.setObject(1, analysis);
            preparedStatement.setString(2, vulnerabilityPolicy.getAuthor());
            preparedStatement.setArray(3, conditions);
            preparedStatement.setString(4, vulnerabilityPolicy.getDescription());
            preparedStatement.setObject(5, ratings);
            preparedStatement.setTimestamp(6, vulnerabilityPolicy.getUpdated() != null ? new java.sql.Timestamp(vulnerabilityPolicy.getUpdated().getTime()) : null);
            preparedStatement.setTimestamp(7, vulnerabilityPolicy.getValidFrom() != null ? new java.sql.Timestamp(vulnerabilityPolicy.getValidFrom().getTime()) : null);
            preparedStatement.setTimestamp(8, vulnerabilityPolicy.getValidUntil() != null ? new java.sql.Timestamp(vulnerabilityPolicy.getValidUntil().getTime()) : null);
            preparedStatement.setString(9, vulnerabilityPolicy.getName());

            return preparedStatement.executeUpdate();
        } catch (Exception ex) {
            LOGGER.error("Error in creating vulnerability policy", ex);
            throw new RuntimeException(ex);
        } finally {
            DbUtil.close(preparedStatement);
            DbUtil.close(connection);
        }
    }
}
