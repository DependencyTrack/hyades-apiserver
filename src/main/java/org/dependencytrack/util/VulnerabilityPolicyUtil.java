package org.dependencytrack.util;

import alpine.common.logging.Logger;
import alpine.model.ConfigProperty;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.DeserializationFeature;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.dataformat.yaml.YAMLFactory;
import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;
import com.networknt.schema.JsonSchema;
import com.networknt.schema.JsonSchemaFactory;
import com.networknt.schema.SpecVersion;
import com.networknt.schema.ValidationMessage;
import org.dependencytrack.model.ConfigPropertyConstants;
import org.dependencytrack.persistence.QueryManager;
import org.dependencytrack.persistence.jdbi.VulnerabilityPolicyDao;
import org.dependencytrack.policy.cel.CelPolicyScriptHost;
import org.dependencytrack.policy.cel.CelPolicyType;
import org.dependencytrack.policy.vulnerability.VulnerabilityPolicy;
import org.dependencytrack.tasks.vulnerabilitypolicy.blobstorage.VulnerabilityPolicyBundleFile;
import org.projectnessie.cel.tools.ScriptCreateException;

import java.io.IOException;
import java.io.InputStream;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Enumeration;
import java.util.List;
import java.util.Set;
import java.util.zip.ZipEntry;
import java.util.zip.ZipFile;

import static org.apache.commons.io.IOUtils.resourceToString;
import static org.dependencytrack.persistence.jdbi.JdbiFactory.jdbi;

public class VulnerabilityPolicyUtil {

    private static final Logger LOGGER = Logger.getLogger(VulnerabilityPolicyUtil.class);
    private static final ObjectMapper MAPPER = new ObjectMapper(new YAMLFactory())
            .registerModule(new JavaTimeModule())
            .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);

    private static JsonSchema schema = null;

    static {
        try {
            schema = JsonSchemaFactory.builder(JsonSchemaFactory.getInstance(SpecVersion.VersionFlag.V202012))
                    .objectMapper(MAPPER).build()
                    .getSchema(resourceToString("/schema/vulnerability-policy-v1.schema.json", StandardCharsets.UTF_8));
        } catch (IOException e) {
            LOGGER.error("Exception occurred while creating schema for YAML validation", e);
        }
    }

    public static void parseVulnerabilityPolicy(String out, List<VulnerabilityPolicy> createVulnerabilityPolicyList,
                                                List<VulnerabilityPolicy> updateVulnerabilityPolicyList,
                                                List<String> policyNames) throws IOException, ScriptCreateException {
        JsonNode jsonNode = MAPPER.readTree(out);
        //this is a precheck to existing validation so that if there are other yaml files in the bundle, we ignore them
        if (jsonNode.has("type") && jsonNode.get("type").asText().equals("Vulnerability Policy")) {
            Set<ValidationMessage> validateMsg = schema.validate(jsonNode);
            if (validateMsg.isEmpty()) { //yaml file provided is valid and we can proceed to validate the cel policy
                //if cel policy is invalid, ScriptCreateException will be thrown that trickles back to inform
                validateVulnerabilityCelPolicy(MAPPER.convertValue(jsonNode.get("conditions"), new TypeReference<>() {
                }));
                VulnerabilityPolicy vulnerabilityPolicy = MAPPER.convertValue(jsonNode, VulnerabilityPolicy.class);
                if (vulnerabilityPolicy != null) {
                    if (policyNames.contains(vulnerabilityPolicy.getName())) {
                        updateVulnerabilityPolicyList.add(vulnerabilityPolicy);
                    } else {
                        createVulnerabilityPolicyList.add(vulnerabilityPolicy);
                    }
                } else {
                    throw new NullPointerException("Was not able to create vulnerability policy object successfully");
                }
            } else {
                throw new IllegalArgumentException("Schema validation failed: %s".formatted(validateMsg));
            }
        }
    }

    private static void validateVulnerabilityCelPolicy(List<String> vulnerabilityCelPolicyConditions) throws ScriptCreateException {
        if (!vulnerabilityCelPolicyConditions.isEmpty()) {
            for (var vulnerabilityPolicyCondition : vulnerabilityCelPolicyConditions) {
                CelPolicyScriptHost.getInstance(CelPolicyType.VULNERABILITY).compile(vulnerabilityPolicyCondition, CelPolicyScriptHost.CacheMode.CACHE);
            }
        }
    }


    public static void parseAndSavePolicies(final VulnerabilityPolicyBundleFile bundleFile) throws IOException {
        List<VulnerabilityPolicy> createVulnerabilityPolicyList = new ArrayList<>();
        List<VulnerabilityPolicy> updateVulnerabilityPolicyList = new ArrayList<>();
        try (final var zipFile = new ZipFile(bundleFile.filePath().toFile());
             final var qm = new QueryManager()) {
            List<VulnerabilityPolicy> existingVulnerabilityPolicies = jdbi(qm).withExtension(VulnerabilityPolicyDao.class, VulnerabilityPolicyDao::getAll);
            List<String> policyNames = existingVulnerabilityPolicies.stream().map(VulnerabilityPolicy::getName).toList();
            final Enumeration<? extends ZipEntry> zipEntries = zipFile.entries();
            int numTotalPolicies = 0, numParsingFailures = 0;
            while (zipEntries.hasMoreElements()) {
                final ZipEntry zipEntry = zipEntries.nextElement();
                if (!(zipEntry.getName().startsWith(".") || zipEntry.getName().startsWith("_")) && (zipEntry.getName().contains(".yaml") || zipEntry.getName().contains(".yml"))) {
                    numTotalPolicies++;

                    final String policyYaml;
                    try (final InputStream zipEntryInputStream = zipFile.getInputStream(zipEntry)) {
                        policyYaml = new String(zipEntryInputStream.readAllBytes(), StandardCharsets.UTF_8);
                    }

                    try {
                        parseVulnerabilityPolicy(policyYaml, createVulnerabilityPolicyList, updateVulnerabilityPolicyList, policyNames);
                    } catch (IOException | ScriptCreateException | RuntimeException e) {
                        LOGGER.error("Failed to parse or validate policy %s".formatted(zipEntry.getName()), e);
                        numParsingFailures++;
                    }
                }
            }
            if (numParsingFailures > 0) {
                throw new IllegalStateException("""
                        Will not update policies in datastore because %d/%d policy definitions failed to validate. \
                        Policy bundles can only be applied when all policy definitions within them are valid.\
                        """.formatted(numParsingFailures, numTotalPolicies));
            }
            saveParsedVulnerabilities(qm, createVulnerabilityPolicyList, updateVulnerabilityPolicyList, policyNames);
        }
    }


    public static boolean matchWithHashConfigProperty(String etag) {
        try (QueryManager queryManager = new QueryManager()) {
            ConfigProperty lastModifiedHash = queryManager.getConfigProperty(ConfigPropertyConstants.VULNERABILITY_POLICY_FILE_LAST_MODIFIED_HASH.getGroupName(),
                    ConfigPropertyConstants.VULNERABILITY_POLICY_FILE_LAST_MODIFIED_HASH.getPropertyName());
            if (lastModifiedHash == null) {
                //lastmodified hash property is currently not in the db then it will be created and set to etag (null or not) value provided
                queryManager.createConfigProperty(ConfigPropertyConstants.VULNERABILITY_POLICY_FILE_LAST_MODIFIED_HASH.getGroupName(),
                        ConfigPropertyConstants.VULNERABILITY_POLICY_FILE_LAST_MODIFIED_HASH.getPropertyName(),
                        etag,
                        ConfigPropertyConstants.VULNERABILITY_POLICY_FILE_LAST_MODIFIED_HASH.getPropertyType(),
                        ConfigPropertyConstants.VULNERABILITY_POLICY_FILE_LAST_MODIFIED_HASH.getDescription());
                return true;
            }
            //if etag is not returned by head request then we need to return true all the time.
            // if etag was previously not null in config and now is getting fetched as null then the config property value
            //also needs to be set to null.
            if (etag == null || lastModifiedHash.getPropertyValue() == null || !(etag.equals(lastModifiedHash.getPropertyValue()))) {
                lastModifiedHash.setPropertyValue(etag);
                return true;
            }
            //the lastmodified hash is the same as the incoming value
            return false;
        }
    }

    public static void saveParsedVulnerabilities(QueryManager qm, List<VulnerabilityPolicy> createVulnerabilityPolicyList,
                                                 List<VulnerabilityPolicy> updateVulnerabilityPolicyList,
                                                 List<String> policyNames) {
        List<String> receivedPolicyNames = new ArrayList<>();
        for (var vulnerabilityPolicy : createVulnerabilityPolicyList) {
            receivedPolicyNames.add(vulnerabilityPolicy.getName());
        }
        for (var vulnerabilityPolicy : updateVulnerabilityPolicyList) {
            receivedPolicyNames.add(vulnerabilityPolicy.getName());
        }
        List<String> vulnerabilityPoliciesToBeDeleted = policyNames.stream()
                .filter(policyName -> !receivedPolicyNames.contains(policyName)).toList();

        jdbi(qm).useTransaction(jdbiHandle -> {
            final var vulnPolicyDao = jdbiHandle.attach(VulnerabilityPolicyDao.class);
            for (final VulnerabilityPolicy policy : createVulnerabilityPolicyList) {
                LOGGER.info("Creating vulnerability policy: %s".formatted(policy.getName()));
                vulnPolicyDao.create(policy);
            }
            for (final VulnerabilityPolicy policy : updateVulnerabilityPolicyList) {
                LOGGER.info("Updating vulnerability policy: %s".formatted(policy.getName()));
                final VulnerabilityPolicy updatedPolicy = vulnPolicyDao.update(policy);
                if (updatedPolicy == null) {
                    LOGGER.info("Vulnerability policy %s has not changed".formatted(policy.getName()));
                }
            }
            for (final String policyName : vulnerabilityPoliciesToBeDeleted) {
                LOGGER.info("Deleting vulnerability policy: %s".formatted(policyName));
                vulnPolicyDao.unassignAndDeleteByName(policyName);
            }
        });
    }

}
