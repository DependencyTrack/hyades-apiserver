/*
 * This file is part of Dependency-Track.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 * Copyright (c) OWASP Foundation. All Rights Reserved.
 */
package org.dependencytrack.tasks;

import alpine.common.logging.Logger;
import alpine.event.framework.Event;
import alpine.event.framework.Subscriber;
import net.javacrumbs.shedlock.core.LockConfiguration;
import net.javacrumbs.shedlock.core.LockExtender;
import net.javacrumbs.shedlock.core.LockingTaskExecutor;
import org.dependencytrack.event.ComponentVulnerabilityAnalysisEvent;
import org.dependencytrack.event.PortfolioVulnerabilityAnalysisEvent;
import org.dependencytrack.event.ProjectVulnerabilityAnalysisEvent;
import org.dependencytrack.event.kafka.KafkaEventDispatcher;
import org.dependencytrack.model.Component;
import org.dependencytrack.model.Project;
import org.dependencytrack.model.VulnerabilityAnalysisLevel;
import org.dependencytrack.model.VulnerabilityScan;
import org.dependencytrack.persistence.QueryManager;

import javax.jdo.PersistenceManager;
import javax.jdo.Query;
import java.time.Duration;
import java.util.HashMap;
import java.util.List;
import java.util.UUID;

import static java.lang.Math.toIntExact;
import static org.dependencytrack.util.LockProvider.executeWithLock;
import static org.dependencytrack.util.LockProvider.isTaskLockToBeExtended;
import static org.dependencytrack.util.TaskUtil.getLockConfigForTask;

/**
 * A {@link Subscriber} to {@link ProjectVulnerabilityAnalysisEvent} and {@link PortfolioVulnerabilityAnalysisEvent}
 * that submits components of a specific project, or all components in the entire portfolio, for vulnerability
 * analysis.
 */
public class VulnerabilityAnalysisTask implements Subscriber {

    private static final Logger LOGGER = Logger.getLogger(VulnerabilityAnalysisTask.class);

    private final KafkaEventDispatcher eventDispatcher = new KafkaEventDispatcher();

    /**
     * {@inheritDoc}
     */
    public void inform(final Event e) {
        if (e instanceof final ProjectVulnerabilityAnalysisEvent event) {
            try {
                processProject(event.getProjectUuid(), event.getChainIdentifier());
            } catch (Exception ex) {
                LOGGER.error("""
                        An unexpected error occurred while submitting components of\s
                        project %s for vulnerability analysis
                        """.formatted(event.getProjectUuid()), ex);
            }
        } else if (e instanceof final PortfolioVulnerabilityAnalysisEvent event) {
            try {
                executeWithLock(
                        getLockConfigForTask(VulnerabilityAnalysisTask.class),
                        (LockingTaskExecutor.Task) () -> processPortfolio(event.getChainIdentifier()));
            } catch (Throwable ex) {
                LOGGER.error("An unexpected error occurred while submitting components for vulnerability analysis", ex);
            }
        }
    }

    private void processProject(final UUID projectUuid, final UUID scanToken) throws Exception {
        LOGGER.info("Submitting components of project %s for vulnerability analysis".formatted(projectUuid));
        long submittedComponents = 0;

        try (final var qm = new QueryManager()) {
            final Project project = qm.getObjectByUuid(Project.class, projectUuid);
            if (project == null) {
                LOGGER.error("A project with UUID %s does not exist".formatted(projectUuid));
                return;
            }

            final PersistenceManager pm = qm.getPersistenceManager();
            final long componentCount = getComponentCount(pm, project);
            if (componentCount == 0) {
                LOGGER.info("Project %s does not have any components; Skipping".formatted(projectUuid));
                return;
            }

            qm.createVulnerabilityScan(VulnerabilityScan.TargetType.PROJECT, projectUuid, scanToken, toIntExact(componentCount));
            List<ComponentProjection> components = fetchNextComponentsPage(pm, project, null);
            while (!components.isEmpty()) {
                dispatchComponents(scanToken, components);
                submittedComponents += components.size();

                final long lastId = components.get(components.size() - 1).id();
                components = fetchNextComponentsPage(qm.getPersistenceManager(), project, lastId);
            }
        }

        LOGGER.info("All components (%d) of project %s submitted for vulnerability analysis".formatted(submittedComponents, projectUuid));
    }

    private void processPortfolio(final UUID scanToken) throws Exception {
        LOGGER.info("Submitting all components in portfolio for vulnerability analysis");

        LockConfiguration lockConfiguration = getLockConfigForTask(VulnerabilityAnalysisTask.class);
        long submittedComponents = 0;

        try (final QueryManager qm = new QueryManager()) {
            final PersistenceManager pm = qm.getPersistenceManager();
            long startTime = System.currentTimeMillis();
            List<ComponentProjection> components = fetchNextComponentsPage(pm, null, null);
            while (!components.isEmpty()) {
                long cumulativeProcessingTime = System.currentTimeMillis() - startTime;
                if (isTaskLockToBeExtended(cumulativeProcessingTime, VulnerabilityAnalysisTask.class)) {
                    LockExtender.extendActiveLock(Duration.ofMinutes(5).plus(lockConfiguration.getLockAtLeastFor()), lockConfiguration.getLockAtLeastFor());
                }
                dispatchComponents(scanToken, components);
                submittedComponents += components.size();

                final long lastId = components.get(components.size() - 1).id();
                components = fetchNextComponentsPage(qm.getPersistenceManager(), null, lastId);
            }
        }

        LOGGER.info("All components (%d) in portfolio submitted for vulnerability analysis".formatted(submittedComponents));
    }

    private void dispatchComponents(final UUID scanToken, final List<ComponentProjection> components) {
        for (final var component : components) {
            eventDispatcher.dispatchEvent(new ComponentVulnerabilityAnalysisEvent(scanToken,
                    component.uuid(), component.purl(), component.cpe(), component.swidTagId(),
                    component.internal(), VulnerabilityAnalysisLevel.PERIODIC_ANALYSIS, false));
        }
    }

    private List<ComponentProjection> fetchNextComponentsPage(final PersistenceManager pm, final Project project, final Long lastId) throws Exception {
        try (final Query<Component> query = pm.newQuery(Component.class)) {
            var filter = "project.inactiveSince == null";
            var params = new HashMap<String, Object>();
            if (project != null) {
                filter += " && project == :project";
                params.put("project", project);
            }
            if (lastId != null) {
                filter += " && id < :lastId";
                params.put("lastId", lastId);
            }
            query.setFilter(filter);
            query.setNamedParameters(params);
            query.setOrdering("id DESC");
            query.setRange(0, 5000);
            query.setResult("id, uuid, purl, cpe, swidTagId, internal");
            return List.copyOf(query.executeResultList(ComponentProjection.class));
        }
    }

    private long getComponentCount(final PersistenceManager pm, final Project project) throws Exception {
        try (final Query<Component> query = pm.newQuery(Component.class)) {
            query.setFilter("project == :project");
            query.setParameters(project);
            query.setResult("count(this)");
            return query.executeResultUnique(Long.class);
        }
    }

    public record ComponentProjection(long id, UUID uuid, String purl, String cpe, String swidTagId, Boolean internal) {
    }

}
