package org.dependencytrack.tasks.vulnerabilitypolicy;

import alpine.Config;
import alpine.common.logging.Logger;
import alpine.server.util.DbUtil;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.dataformat.yaml.YAMLFactory;
import com.fasterxml.jackson.datatype.jsonorg.JsonOrgModule;
import com.networknt.schema.JsonSchema;
import com.networknt.schema.JsonSchemaFactory;
import com.networknt.schema.SpecVersion;
import com.networknt.schema.ValidationMessage;
import org.apache.http.HttpEntity;
import org.apache.http.client.methods.CloseableHttpResponse;
import org.apache.http.client.methods.HttpGet;
import org.apache.http.client.methods.HttpHead;
import org.apache.http.client.methods.HttpUriRequest;
import org.apache.http.impl.client.CloseableHttpClient;
import org.dependencytrack.common.ConfigKey;
import org.dependencytrack.common.HttpClientPool;
import org.dependencytrack.model.VulnerabilityPolicy;
import org.dependencytrack.persistence.QueryManager;
import org.dependencytrack.policy.cel.CelPolicyScriptHost;
import org.dependencytrack.policy.cel.CelPolicyType;
import org.dependencytrack.util.HttpUtil;
import org.projectnessie.cel.tools.ScriptCreateException;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.nio.charset.StandardCharsets;
import java.sql.Connection;
import java.util.ArrayList;
import java.util.List;
import java.util.Set;
import java.util.zip.ZipEntry;
import java.util.zip.ZipInputStream;

import static org.apache.commons.io.IOUtils.resourceToString;

public abstract class AbstractVulnerabilityPolicyFetcher implements BlobStorageAccessHandler {

    private final Logger logger = Logger.getLogger(this.getClass());
    private static final ObjectMapper MAPPER = new ObjectMapper(new YAMLFactory()).registerModule(new JsonOrgModule());

    protected String username;
    protected String password;
    protected final CloseableHttpClient httpClient = HttpClientPool.getClient();

    void setUsername() {
        if (Config.getInstance().getProperty(ConfigKey.VULNERABILITY_POLICY_FILE_FETCH_USERNAME) != null) {
            username = Config.getInstance().getProperty(ConfigKey.VULNERABILITY_POLICY_FILE_FETCH_USERNAME);
        }
    }

    void setPassword() {
        if (Config.getInstance().getProperty(ConfigKey.VULNERABILITY_POLICY_FILE_FETCH_PASSWORD) != null) {
            password = Config.getInstance().getProperty(ConfigKey.VULNERABILITY_POLICY_FILE_FETCH_PASSWORD);
        }
    }

    @Override
    public void downloadAndparseZippedContent() throws IOException, ScriptCreateException {
        try (CloseableHttpResponse response = performGetRequest()) {
            HttpEntity entity = response.getEntity();
            ZipInputStream zipInputStream = new ZipInputStream(entity.getContent());
            BufferedReader reader = new BufferedReader(new InputStreamReader(zipInputStream, StandardCharsets.UTF_8));
            ZipEntry zipEntry = zipInputStream.getNextEntry();
            List<VulnerabilityPolicy> createVulnerabilityPolicyList = new ArrayList<>();
            List<VulnerabilityPolicy> updateVulnerabilityPolicyList = new ArrayList<>();
            try (QueryManager queryManager = new QueryManager()) {
                List<VulnerabilityPolicy> existingVulnerabilityPolicies = queryManager.getAllVulnerabilityPolicies();
                List<String> policyNames = existingVulnerabilityPolicies.stream().map(VulnerabilityPolicy::getName).toList();
                while (zipEntry != null) {
                    if (!(zipEntry.getName().startsWith(".") || zipEntry.getName().startsWith("_")) && (zipEntry.getName().contains(".yaml") || zipEntry.getName().contains(".yml"))) {
                        String line = null;
                        StringBuilder out = new StringBuilder();
                        while ((line = reader.readLine()) != null) {
                            out.append(line + '\n');
                        }
                        parseVulnerabilityPolicy(out, createVulnerabilityPolicyList, updateVulnerabilityPolicyList, policyNames);
                    }
                    zipEntry = zipInputStream.getNextEntry();
                }
                saveParsedVulnerabilities(queryManager, createVulnerabilityPolicyList, updateVulnerabilityPolicyList, policyNames);
            }
        }

    }

    public void saveParsedVulnerabilities(QueryManager queryManager, List<VulnerabilityPolicy> createVulnerabilityPolicyList,
                                          List<VulnerabilityPolicy> updateVulnerabilityPolicyList,
                                          List<String> policyNames) {
        List<String> receivedPolicyNames = new ArrayList<>();
        for (var vulnerabilityPolicy : createVulnerabilityPolicyList) {
            receivedPolicyNames.add(vulnerabilityPolicy.getName());
        }
        for (var vulnerabilityPolicy : updateVulnerabilityPolicyList) {
            receivedPolicyNames.add(vulnerabilityPolicy.getName());
        }
        List<String> vulnerabilityPoliciesToBeDeleted = policyNames.stream()
                .filter(policyName -> !receivedPolicyNames.contains(policyName)).toList();
        queryManager.runInTransaction(() -> {
            Connection connection = null;
            try {
                connection = (Connection) queryManager.getPersistenceManager().getDataStoreConnection();
                for (var vulnerabilityPolicy : createVulnerabilityPolicyList) {
                    queryManager.createVulnerabilityPolicy(vulnerabilityPolicy, connection);
                }
                for (var vulnerabilityPolicy : updateVulnerabilityPolicyList) {
                    queryManager.updateVulnerablePolicyByName(vulnerabilityPolicy, connection);
                }
                for (var name : vulnerabilityPoliciesToBeDeleted) {
                    queryManager.deleteVulnerabilityPolicyByName(name, connection);
                }
            } finally {
                DbUtil.close(connection);
            }

        });
    }

    private static JsonSchema enrichYamlOjMapperAndGetSchema() throws IOException {
        final String jsonSchemaContent = resourceToString("/schema/vulnerability-policy-v1.schema.json", StandardCharsets.UTF_8);
        JsonSchemaFactory factory = JsonSchemaFactory.builder(JsonSchemaFactory.getInstance(SpecVersion.VersionFlag.V202012)).objectMapper(MAPPER).build();
        return factory.getSchema(jsonSchemaContent);
    }

    @Override
    public void parseVulnerabilityPolicy(StringBuilder out, List<VulnerabilityPolicy> createVulnerabilityPolicyList,
                                         List<VulnerabilityPolicy> updateVulnerabilityPolicyList, List<String> policyNames)
            throws ScriptCreateException, IOException {
        JsonSchema schema = enrichYamlOjMapperAndGetSchema();
        JsonNode jsonNode = null;
        jsonNode = MAPPER.readTree(out.toString());
        Set<ValidationMessage> validateMsg = schema.validate(jsonNode);
        if (validateMsg.isEmpty()) { //yaml file provided is valid and we can proceed to validate the cel policy
            //if cel policy is invalid, ScriptCreateException will be thrown that trickles back to inform
            validateVulnerabilityCelPolicy(MAPPER.convertValue(jsonNode.get("conditions"), ArrayList.class));
            VulnerabilityPolicy vulnerabilityPolicy = MAPPER.convertValue(jsonNode, VulnerabilityPolicy.class);
            if (vulnerabilityPolicy != null) {
                if (policyNames.contains(vulnerabilityPolicy.getName())) {
                    updateVulnerabilityPolicyList.add(vulnerabilityPolicy);
                } else {
                    createVulnerabilityPolicyList.add(vulnerabilityPolicy);
                }
            } else {
                logger.warn("Was not able to create vulnerability policy object successfully");
            }
        } else {
            StringBuilder errorMessage = new StringBuilder();
            for (var message : validateMsg) {
                errorMessage.append(message.getMessage()).append("\n");
            }
            logger.error("unable to compile cel policy correctly. Errors received:%s".formatted(errorMessage.toString()));
        }
    }

    private void validateVulnerabilityCelPolicy(ArrayList vulnerabilityCelPolicyConditions) throws ScriptCreateException {
        if (!vulnerabilityCelPolicyConditions.isEmpty()) {
            for (var vulnerabilityPolicyCondition : vulnerabilityCelPolicyConditions) {
                try {
                    CelPolicyScriptHost.getInstance(CelPolicyType.VULNERABILITY).compile((String) vulnerabilityPolicyCondition, CelPolicyScriptHost.CacheMode.CACHE);
                } catch (ScriptCreateException ex) {
                    logger.warn("Unable to parse cel expression provided in vulnerability policy yaml file: ");
                    throw ex;
                }
            }
        }
    }

    public CloseableHttpResponse performHeadRequest() throws IOException {
        HttpUriRequest request = new HttpHead(Config.getInstance().getProperty(ConfigKey.VULNERABILITY_POLICY_FETCH_URL));
        if (username != null || password != null) {
            request.addHeader("Authorization", HttpUtil.basicAuthHeaderValue(username, password));
        }
        return httpClient.execute(request);
    }

    public CloseableHttpResponse performGetRequest() throws IOException {
        HttpUriRequest request = new HttpGet(Config.getInstance().getProperty(ConfigKey.VULNERABILITY_POLICY_FETCH_URL));
        if (username != null || password != null) {
            request.addHeader("Authorization", HttpUtil.basicAuthHeaderValue(username, password));
        }
        return httpClient.execute(request);
    }

}
