package org.dependencytrack.tasks.vulnerabilitypolicy;

import alpine.Config;
import alpine.common.logging.Logger;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.dataformat.yaml.YAMLFactory;
import com.networknt.schema.JsonSchema;
import com.networknt.schema.JsonSchemaFactory;
import com.networknt.schema.SpecVersion;
import com.networknt.schema.ValidationMessage;
import org.apache.http.HttpEntity;
import org.apache.http.client.methods.CloseableHttpResponse;
import org.apache.http.client.methods.HttpGet;
import org.apache.http.client.methods.HttpHead;
import org.apache.http.client.methods.HttpUriRequest;
import org.apache.http.impl.client.CloseableHttpClient;
import org.dependencytrack.common.ConfigKey;
import org.dependencytrack.common.HttpClientPool;
import org.dependencytrack.model.VulnerabilityPolicy;
import org.dependencytrack.persistence.QueryManager;
import org.dependencytrack.policy.cel.CelPolicyScriptHost;
import org.dependencytrack.policy.cel.CelPolicyType;
import org.dependencytrack.policy.vulnerability.VulnerabilityPolicyAnalysis;
import org.dependencytrack.policy.vulnerability.VulnerabilityPolicyRating;
import org.dependencytrack.util.HttpUtil;
import org.projectnessie.cel.tools.ScriptCreateException;

import java.io.BufferedReader;
import java.io.File;
import java.io.IOException;
import java.io.InputStreamReader;
import java.net.URI;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Date;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Optional;
import java.util.Set;
import java.util.zip.ZipEntry;
import java.util.zip.ZipInputStream;

public abstract class AbstractVulnerabilityPolicyFetcher implements BlobStorageAccessHandler {

    private final Logger logger = Logger.getLogger(this.getClass());

    protected String username;
    protected String password;
    protected final CloseableHttpClient httpClient = HttpClientPool.getClient();

    void setUsername() {
        if (Config.getInstance().getProperty(ConfigKey.VULNERABILITY_POLICY_FILE_FETCH_USERNAME) != null) {
            username = Config.getInstance().getProperty(ConfigKey.VULNERABILITY_POLICY_FILE_FETCH_USERNAME);
        }
    }

    void setPassword() {
        if (Config.getInstance().getProperty(ConfigKey.VULNERABILITY_POLICY_FILE_FETCH_PASSWORD) != null) {
            password = Config.getInstance().getProperty(ConfigKey.VULNERABILITY_POLICY_FILE_FETCH_PASSWORD);
        }
    }

    @Override
    public boolean downloadAndparseZippedContent() throws IOException {
        try (CloseableHttpResponse response = performGetRequest()) {
            HttpEntity entity = response.getEntity();
            ZipInputStream zipInputStream = new ZipInputStream(entity.getContent());
            BufferedReader reader = new BufferedReader(new InputStreamReader(zipInputStream, StandardCharsets.UTF_8));
            ZipEntry zipEntry = zipInputStream.getNextEntry();
            while (zipEntry != null) {
                if(zipEntry.getName().contains(".yaml")) {
                    String line = null;
                    StringBuilder out = new StringBuilder();
                    while ((line = reader.readLine()) != null) {
                        out.append(line + '\n');
                    }
                    if (!parseAndSaveVulnerabilityPolicy(out)) {
                        logger.error("Not able to save policy yaml to db successfully");
                        return false;
                    }
                }
                zipEntry = zipInputStream.getNextEntry();
            }
        }
        return true;

    }

    @Override
    public boolean parseAndSaveVulnerabilityPolicy(StringBuilder out) {
        ObjectMapper objMapper = new ObjectMapper(new YAMLFactory());
        final File jsonSchemaFile = new File("src/main/java/org/dependencytrack/policy/validation/policySchema.json");
        final URI uri = jsonSchemaFile.toURI();
        JsonSchemaFactory factory = JsonSchemaFactory.builder(JsonSchemaFactory.getInstance(SpecVersion.VersionFlag.V202012)).objectMapper(objMapper).build();
        JsonSchema schema = factory.getSchema(uri);
        JsonNode jsonNode = null;
        try {
            jsonNode = objMapper.readTree(out.toString());
        } catch (IOException ex) {
            logger.error("Unable to parse provided yaml into json content", ex);
            return false;
        }
        Set<ValidationMessage> validateMsg = schema.validate(jsonNode);
        try (QueryManager queryManager = new QueryManager()) {
            List<VulnerabilityPolicy> vulnerabilityPolicies = queryManager.getAllVulnerabilityPolicies();
            List<String> policyNames = vulnerabilityPolicies.stream().map(VulnerabilityPolicy::getName).toList();
            if (validateMsg.isEmpty()) { //yaml file provided is valid and we can proceed to validate the cel policy
                ObjectMapper objectMapper = new ObjectMapper();
                ArrayList vulnerabilityCelPolicyConditions = objectMapper.convertValue(jsonNode.get("conditions"), ArrayList.class);
                try {
                    validateVulnerabilityCelPolicy(vulnerabilityCelPolicyConditions);
                } catch (ScriptCreateException ex) {
                    logger.error("There was an error in parsing the specified cel policy in the yaml document", ex);
                    return false;
                }
                VulnerabilityPolicy vulnerabilityPolicy = createVulnerabilityPolicyObject(objectMapper, jsonNode, vulnerabilityCelPolicyConditions);
                if (vulnerabilityPolicy != null) {
                    if (policyNames.contains(vulnerabilityPolicy.getName())) {
                        return queryManager.updateVulnerablePolicyByName(vulnerabilityPolicy) == 1;
                    } else {
                        return queryManager.createVulnerabilityPolicy(vulnerabilityPolicy) == 1;
                    }
                }
            }
            return false;
        }
    }

    private VulnerabilityPolicy createVulnerabilityPolicyObject(ObjectMapper objectMapper, JsonNode jsonNode, ArrayList vulnerabilityCelPolicyConditions) {
        try {
            VulnerabilityPolicy vulnerabilityPolicy = new VulnerabilityPolicy();
            vulnerabilityPolicy.setName(jsonNode.get("name").asText());
            Optional.ofNullable(jsonNode.get("description").asText()).ifPresent(vulnerabilityPolicy::setDescription);
            Optional.ofNullable(jsonNode.get("author").asText()).ifPresent(vulnerabilityPolicy::setAuthor);

            if (jsonNode.get("created") != null) {
                Date date = objectMapper.convertValue(jsonNode.get("created"), Date.class);
                vulnerabilityPolicy.setCreated(date);
            }
            if (jsonNode.get("updated") != null) {
                Date date = objectMapper.convertValue(jsonNode.get("updated"), Date.class);
                vulnerabilityPolicy.setUpdated(date);
            }
            if (jsonNode.get("validFrom") != null) {
                Date date = objectMapper.convertValue(jsonNode.get("validFrom"), Date.class);
                vulnerabilityPolicy.setValidFrom(date);
            }
            if (jsonNode.get("validUntil") != null) {
                Date date = objectMapper.convertValue(jsonNode.get("validUntil"), Date.class);
                vulnerabilityPolicy.setValidUntil(date);
            }
            vulnerabilityPolicy.setConditions((String[]) vulnerabilityCelPolicyConditions.toArray(String[]::new));
            //Setting ratings
            ArrayList ratings = new ArrayList<VulnerabilityPolicyRating>();
            if (jsonNode.get("ratings") != null) {
                ratings = objectMapper.convertValue(jsonNode.get("ratings"), ArrayList.class);
            }
            List<VulnerabilityPolicyRating> ratingList = new ArrayList<>();
            for (Object rating : ratings) {
                VulnerabilityPolicyRating result = new VulnerabilityPolicyRating();
                LinkedHashMap rating1 = (LinkedHashMap) rating;
                if (rating1.get("method") == null || rating1.get("method").equals("")) {
                    logger.error("Rating method has not been provided in the rating section");
                    return null;
                }
                if (rating1.get("severity") == null || rating1.get("severity").equals("")) {
                    logger.error("Rating severity is not provided in the rating section");
                    return null;
                }
                result.setMethod(VulnerabilityPolicyRating.Method.valueOf(rating1.get("method").toString()));
                result.setSeverity(VulnerabilityPolicyRating.Severity.valueOf(rating1.get("severity").toString()));
                result.setScore((double) rating1.get("score"));
                result.setVector((String) rating1.get("vector"));
                ratingList.add(result);
            }
            vulnerabilityPolicy.setRatings(ratingList);

            //setting analysis
            JsonNode analysisNode = jsonNode.get("analysis");
            VulnerabilityPolicyAnalysis.State analysisState = objectMapper.convertValue(analysisNode.get("state"), VulnerabilityPolicyAnalysis.State.class);
            VulnerabilityPolicyAnalysis.Justification justification = null;
            if (analysisNode.get("justification") != null) {
                justification = objectMapper.convertValue(analysisNode.get("justification"), VulnerabilityPolicyAnalysis.Justification.class);
            }
            VulnerabilityPolicyAnalysis.Response response = null;
            if (analysisNode.get("vendorResponse") != null) {
                response = objectMapper.convertValue(analysisNode.get("vendorResponse"), VulnerabilityPolicyAnalysis.Response.class);
            }

            VulnerabilityPolicyAnalysis vulnerabilityPolicyAnalysis = new VulnerabilityPolicyAnalysis();
            vulnerabilityPolicyAnalysis.setJustification(justification);
            vulnerabilityPolicyAnalysis.setState(analysisState);
            vulnerabilityPolicyAnalysis.setResponse(response);
            Optional.ofNullable(analysisNode.get("details").asText()).ifPresent(vulnerabilityPolicyAnalysis::setDetails);
            Optional.of(analysisNode.get("suppress").asBoolean()).ifPresent(vulnerabilityPolicyAnalysis::setSuppress);
            vulnerabilityPolicy.setAnalysis(vulnerabilityPolicyAnalysis);
            return vulnerabilityPolicy;
        }catch (Exception ex){
            logger.error("Unable to parse yaml file into vulnerability policy object");
            return null;
        }
    }

    private void validateVulnerabilityCelPolicy(ArrayList vulnerabilityCelPolicyConditions) throws ScriptCreateException {
        if (!vulnerabilityCelPolicyConditions.isEmpty()) {
            for (var vulnerabilityPolicyCondition : vulnerabilityCelPolicyConditions) {
                try {
                    CelPolicyScriptHost.getInstance(CelPolicyType.VULNERABILITY).compile((String) vulnerabilityPolicyCondition, CelPolicyScriptHost.CacheMode.CACHE);
                } catch (ScriptCreateException ex) {
                    logger.warn("Unable to parse cel expression provided in vulnerability policy yaml file: ");
                    throw ex;
                }
            }
        }
    }

    public CloseableHttpResponse performHeadRequest() throws IOException {
        HttpUriRequest request = new HttpHead(Config.getInstance().getProperty(ConfigKey.VULNERABILITY_POLICY_FETCH_URL));
        if (username != null || password != null) {
            request.addHeader("Authorization", HttpUtil.basicAuthHeaderValue(username, password));
        }
        return httpClient.execute(request);
    }

    public CloseableHttpResponse performGetRequest() throws IOException {
        HttpUriRequest request = new HttpGet(Config.getInstance().getProperty(ConfigKey.VULNERABILITY_POLICY_FETCH_URL));
        if (username != null || password != null) {
            request.addHeader("Authorization", HttpUtil.basicAuthHeaderValue(username, password));
        }
        return httpClient.execute(request);
    }

}
