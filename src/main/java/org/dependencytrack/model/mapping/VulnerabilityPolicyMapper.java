package org.dependencytrack.model.mapping;

import org.dependencytrack.model.AnalysisJustification;
import org.dependencytrack.model.AnalysisResponse;
import org.dependencytrack.model.AnalysisState;
import org.dependencytrack.policy.vulnerability.VulnerabilityPolicyAnalysis;

public final class VulnerabilityPolicyMapper {

    private VulnerabilityPolicyMapper() {
    }

    public static AnalysisState map(final VulnerabilityPolicyAnalysis.State state) {
        if (state == null) {
            return null;
        }

        return switch (state) {
            case IN_TRIAGE -> AnalysisState.IN_TRIAGE;
            case EXPLOITABLE -> AnalysisState.EXPLOITABLE;
            case FALSE_POSITIVE -> AnalysisState.FALSE_POSITIVE;
            case NOT_AFFECTED -> AnalysisState.NOT_AFFECTED;
            case RESOLVED -> AnalysisState.RESOLVED;
        };
    }

    public static AnalysisJustification map(final VulnerabilityPolicyAnalysis.Justification justification) {
        if (justification == null) {
            return null;
        }

        return switch (justification) {
            case CODE_NOT_PRESENT -> AnalysisJustification.CODE_NOT_PRESENT;
            case CODE_NOT_REACHABLE -> AnalysisJustification.CODE_NOT_REACHABLE;
            case REQUIRES_CONFIGURATION -> AnalysisJustification.REQUIRES_CONFIGURATION;
            case REQUIRES_DEPENDENCY -> AnalysisJustification.REQUIRES_DEPENDENCY;
            case REQUIRES_ENVIRONMENT -> AnalysisJustification.REQUIRES_ENVIRONMENT;
            case PROTECTED_BY_COMPILER -> AnalysisJustification.PROTECTED_BY_COMPILER;
            case PROTECTED_AT_RUNTIME -> AnalysisJustification.PROTECTED_AT_RUNTIME;
            case PROTECTED_AT_PERIMETER -> AnalysisJustification.PROTECTED_AT_PERIMETER;
            case PROTECTED_BY_MITIGATING_CONTROL -> AnalysisJustification.PROTECTED_BY_MITIGATING_CONTROL;
        };
    }

    public static AnalysisResponse map(final VulnerabilityPolicyAnalysis.Response response) {
        if (response == null) {
            return null;
        }

        return switch (response) {
            case CAN_NOT_FIX -> AnalysisResponse.CAN_NOT_FIX;
            case ROLLBACK -> AnalysisResponse.ROLLBACK;
            case UPDATE -> AnalysisResponse.UPDATE;
            case WILL_NOT_FIX -> AnalysisResponse.WILL_NOT_FIX;
            case WORKAROUND_AVAILABLE -> AnalysisResponse.WORKAROUND_AVAILABLE;
        };
    }

}
