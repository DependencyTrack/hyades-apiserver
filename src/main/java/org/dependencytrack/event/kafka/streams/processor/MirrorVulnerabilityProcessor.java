package org.dependencytrack.event.kafka.streams.processor;

import alpine.common.logging.Logger;
import alpine.common.metrics.Metrics;
import com.github.packageurl.MalformedPackageURLException;
import com.github.packageurl.PackageURL;
import io.micrometer.core.instrument.Timer;
import org.apache.commons.lang3.StringUtils;
import org.apache.kafka.streams.processor.api.Processor;
import org.apache.kafka.streams.processor.api.Record;
import org.cyclonedx.proto.v1_4.Bom;
import org.cyclonedx.proto.v1_4.Component;
import org.cyclonedx.proto.v1_4.VulnerabilityAffects;
import org.dependencytrack.model.Vulnerability;
import org.dependencytrack.model.VulnerableSoftware;
import org.dependencytrack.parser.dependencytrack.ModelConverterCdxToVuln;
import org.dependencytrack.parser.nvd.ModelConverter;
import org.dependencytrack.parser.vers.Comparator;
import org.dependencytrack.parser.vers.Constraint;
import org.dependencytrack.parser.vers.Vers;
import org.dependencytrack.parser.vers.VersException;
import org.dependencytrack.persistence.QueryManager;
import us.springett.parsers.cpe.exceptions.CpeEncodingException;
import us.springett.parsers.cpe.exceptions.CpeParsingException;

import java.util.ArrayList;
import java.util.List;
import java.util.Optional;


public class MirrorVulnerabilityProcessor implements Processor<String, Bom, Void, Void> {

    private static final Logger LOGGER = Logger.getLogger(MirrorVulnerabilityProcessor.class);
    private static final Timer TIMER = Timer.builder("vuln_mirror_processing")
            .description("Time taken to process mirrored vulnerabilities")
            .register(Metrics.getRegistry());

    @Override
    public void process(final Record<String, Bom> record) {
        final Timer.Sample timerSample = Timer.start();

        try (QueryManager qm = new QueryManager().withL2CacheDisabled()) {
            LOGGER.debug("Synchronizing Mirrored Vulnerability : " + record.key());
            Bom bom = record.value();
            String key = record.key();
            String mirrorSource = key.substring(0, key.indexOf("/"));
            Vulnerability.Source source = Vulnerability.Source.valueOf(mirrorSource);
            final Vulnerability vulnerability = ModelConverterCdxToVuln.convert(qm, bom, bom.getVulnerabilities(0), false);
            final List<VulnerableSoftware> vsListOld = qm.detach(qm.getVulnerableSoftwareByVulnId(vulnerability.getSource(), vulnerability.getVulnId()));
            final Vulnerability synchronizedVulnerability = qm.synchronizeVulnerability(vulnerability, false);
            var cycloneVuln = bom.getVulnerabilities(0);
            // Alias synchronization across multiple sources is too unreliable right now.
            // We can re-enable this once we have more confidence in data quality, or a better
            // way of auditing reported aliases. See also: https://github.com/google/osv.dev/issues/888
//            if (!cycloneVuln.getReferencesList().isEmpty()) {
//                cycloneVuln.getReferencesList().stream().forEach(reference -> {
//                    final String alias = reference.getId();
//                    final VulnerabilityAlias vulnerabilityAlias = new VulnerabilityAlias();
//
//                    // OSV will use IDs of other vulnerability databases for its
//                    // primary advisory ID (e.g. GHSA-45hx-wfhj-473x). We need to ensure
//                    // that we don't falsely report GHSA IDs as stemming from OSV.
//                    final Vulnerability.Source advisorySource = extractSource(cycloneVuln.getId(), cycloneVuln.getSource());
//                    if (mirrorSource.equals("OSV")) {
//                        switch (advisorySource) {
//                            case NVD -> vulnerabilityAlias.setCveId(cycloneVuln.getId());
//                            case GITHUB -> vulnerabilityAlias.setGhsaId(cycloneVuln.getId());
//                            default -> vulnerabilityAlias.setOsvId(cycloneVuln.getId());
//                        }
//                    }
//                    if (alias.startsWith("CVE") && Vulnerability.Source.NVD != advisorySource) {
//                        vulnerabilityAlias.setCveId(alias);
//                        qm.synchronizeVulnerabilityAlias(vulnerabilityAlias);
//                    } else if (alias.startsWith("GHSA") && Vulnerability.Source.GITHUB != advisorySource) {
//                        vulnerabilityAlias.setGhsaId(alias);
//                        qm.synchronizeVulnerabilityAlias(vulnerabilityAlias);
//                    }
//                });
//            }
            final List<VulnerableSoftware> vsList = new ArrayList<>();
            for (final VulnerabilityAffects affect : cycloneVuln.getAffectsList()) {
                final Optional<Component> component = bom.getComponentsList().stream()
                        .filter(c -> c.getBomRef().equals(affect.getRef()))
                        .findFirst();
                if (component.isEmpty()) {
                    LOGGER.warn("No component in the BOV for %s is matching the BOM ref \"%s\" of the affects node; Skipping"
                            .formatted(synchronizedVulnerability.getVulnId(), affect.getRef()));
                    continue;
                }

                affect.getVersionsList().forEach(version -> {
                    if (version.hasRange()) {
                        final VulnerableSoftware vs = mapAffectedRangeToVulnerableSoftware(qm,
                                vulnerability.getVulnId(), version.getRange(), component.get().getPurl(), component.get().getCpe());
                        if (vs != null) {
                            vsList.add(vs);
                        }
                    }
                    if (version.hasVersion()) {
                        final VulnerableSoftware vs = mapAffectedVersionToVulnerableSoftware(qm,
                                vulnerability.getVulnId(), version.getVersion(), component.get().getPurl(), component.get().getCpe());
                        if (vs != null) {
                            vsList.add(vs);
                        }
                    }
                });
            }
            if (!vsList.isEmpty()) {
                qm.persist(vsList);
                qm.updateAffectedVersionAttributions(synchronizedVulnerability, vsList, source);
                var reconciledVsList = qm.reconcileVulnerableSoftware(synchronizedVulnerability, vsListOld, vsList, source);
                synchronizedVulnerability.setVulnerableSoftware(reconciledVsList);
            }
            qm.persist(synchronizedVulnerability);
        } catch (Exception e) {
            // TODO: Send record to a dead letter topic.
            LOGGER.error("Synchronizing vulnerability %s failed".formatted(record.key()), e);
        } finally {
            timerSample.stop(TIMER);
        }
    }

    public VulnerableSoftware mapAffectedVersionToVulnerableSoftware(final QueryManager qm, final String vulnId,
                                                                     String version, String purlStr, String cpeStr) {
        version = StringUtils.trimToNull(version);
        cpeStr = StringUtils.trimToNull(cpeStr);
        purlStr = StringUtils.trimToNull(purlStr);
        if (version == null || (cpeStr == null && purlStr == null)) {
            return null;
        }

        var vs = new VulnerableSoftware();
        if (purlStr != null) {
            final PackageURL purl;
            try {
                purl = new PackageURL(purlStr);
                vs = qm.getVulnerableSoftwareByPurlAndVersion(purl.getType(), purl.getNamespace(), purl.getName(), version);
                if (vs != null) {
                    return vs;
                } else {
                    vs = new VulnerableSoftware();
                    vs.setPurlType(purl.getType());
                    vs.setPurlNamespace(purl.getNamespace());
                    vs.setPurlName(purl.getName());
                    vs.setPurl(purl.canonicalize());
                    vs.setVersion(version);
                }
            } catch (MalformedPackageURLException e) {
                LOGGER.warn("Failed to parse PURL from \"%s\" for %s; Skipping".formatted(purlStr, vulnId), e);
                return null;
            }
        } else {
            try {
                vs = qm.getVulnerableSoftwareByCpe23AndVersion(cpeStr, version);
                if (vs != null) {
                    return vs;
                } else {
                    vs = ModelConverter.convertCpe23UriToVulnerableSoftware(cpeStr);
                    vs.setVersion(version);
                }
            } catch (CpeParsingException | CpeEncodingException e) {
                LOGGER.warn("Failed to parse CPE from \"%s\" for %s; Skipping".formatted(cpeStr, vulnId), e);
                return null;
            }
        }
        vs.setVulnerable(true);
        return vs;
    }

    public VulnerableSoftware mapAffectedRangeToVulnerableSoftware(final QueryManager qm, final String vulnId,
                                                                   String range, String purlStr, String cpeStr) {
        range = StringUtils.trimToNull(range);
        cpeStr = StringUtils.trimToNull(cpeStr);
        purlStr = StringUtils.trimToNull(purlStr);
        if (range == null || (cpeStr == null && purlStr == null)) {
            return null;
        }

        final Vers vers;
        try {
            vers = Vers.parse(range);
        } catch (VersException e) {
            LOGGER.warn("Failed to parse vers range from \"%s\" for %s".formatted(range, vulnId), e);
            return null;
        }

        if (vers.constraints().isEmpty()) {
            LOGGER.debug("Vers range \"%s\" (parsed: %s) for %s does not contain any constraints; Skipping".formatted(range, vers, vulnId));
            return null;
        } else if (vers.constraints().size() > 2) {
            // Vers ranges can express multiple "branches", which means that this method must potentially be able to return
            // multiple `VulnerableSoftware`s, not just one. For example:
            //   vers:tomee/>=1.0.0-beta1|<=1.7.5|>=7.0.0-M1|<=7.0.7|>=7.1.0|<=7.1.2|>=8.0.0-M1|<=8.0.1
            // would result in the following branches:
            //   * vers:tomee/>=1.0.0-beta1|<=1.7.5
            //   * vers:tomee/>=7.0.0-M1|<=7.0.7
            //   * vers:tomee/>=7.1.0|<=7.1.2
            //   * vers:tomee/>=8.0.0-M1|<=8.0.1
            //
            // Branches are not always pairs, for example:
            //   vers:npm/1.2.3|>=2.0.0|<5.0.0
            // would result in:
            //   * vers:npm/1.2.3
            //   * vers:npm/>=2.0.0|5.0.0
            // In both cases, separate `VulnerableSoftware`s are required.
            //
            // Because mirror-service does not currently produce such complex ranges, we log a warning
            // and skip them if we encounter them. Occurrences of this log would indicate broken parsing
            // logic in mirror-service.
            LOGGER.warn("Vers range \"%s\" (parsed: %s) for %s contains more than two constraints; Skipping".formatted(range, vers, vulnId));
            return null;
        }

        if (vers.constraints().size() == 1 && vers.constraints().get(0).comparator() == Comparator.WILDCARD) {
            // Wildcards in VulnerableSoftware can be represented via either:
            //   * version=*, or
            //   * versionStartIncluding=0
            // We choose the more explicit first option.
            //
            // Also, as wildcards have the potential to lead to lots of false positives,
            // we want to be informed when they enter our system. So logging a warning.
            LOGGER.warn("Wildcard range %s was reported for %s".formatted(vers, vulnId));
            return mapAffectedVersionToVulnerableSoftware(qm, vulnId, "*", purlStr, cpeStr);
        }

        String versionStartIncluding = null;
        String versionStartExcluding = null;
        String versionEndIncluding = null;
        String versionEndExcluding = null;

        for (final Constraint constraint : vers.constraints()) {
            if (constraint.version() == null
                    || constraint.version().equals("0")
                    || constraint.version().equals("*")) {
                // Semantically, ">=0" is equivalent to versionStartIncluding=null,
                // and ">0" is equivalent to versionStartExcluding=null.
                //
                // "<0", "<=0", and "=0" can be normalized to versionStartIncluding=null.
                //
                // "*" is a wildcard and can only be used on its own, without any comparator.
                // The Vers parsing / validation performed above will thus fail for ranges like "vers:generic/>=*".
                continue;
            }

            switch (constraint.comparator()) {
                case GREATER_THAN -> versionStartExcluding = constraint.version();
                case GREATER_THAN_OR_EQUAL -> versionStartIncluding = constraint.version();
                case LESS_THAN_OR_EQUAL -> versionEndIncluding = constraint.version();
                case LESS_THAN -> versionEndExcluding = constraint.version();
                default -> LOGGER.warn("Encountered unexpected comparator %s in %s for %s; Skipping"
                        .formatted(constraint.comparator(), vers, vulnId));
            }
        }

        if (versionStartIncluding == null && versionStartExcluding == null
                && versionEndIncluding == null && versionEndExcluding == null) {
            LOGGER.warn("Unable to assemble a version range from %s for %s".formatted(vers, vulnId));
            return null;
        }
        if ((versionStartIncluding != null || versionStartExcluding != null)
                && (versionEndIncluding == null && versionEndExcluding == null)) {
            LOGGER.warn("Skipping indefinite version range assembled from %s for %s".formatted(vers, vulnId));
            return null;
        }

        VulnerableSoftware vs;
        if (purlStr != null) {
            final PackageURL purl;
            try {
                purl = new PackageURL(purlStr);
            } catch (MalformedPackageURLException e) {
                LOGGER.warn("Failed to parse PURL from \"%s\" for %s; Skipping".formatted(purlStr, vulnId), e);
                return null;
            }
            vs = qm.getVulnerableSoftwareByPurl(purl.getType(), purl.getNamespace(), purl.getName(),
                    versionEndExcluding, versionEndIncluding, null, versionStartIncluding);
            if (vs != null) {
                return vs;
            }
            vs = new VulnerableSoftware();
            vs.setPurlType(purl.getType());
            vs.setPurlNamespace(purl.getNamespace());
            vs.setPurlName(purl.getName());
            vs.setPurl(purl.canonicalize());
        } else {
            vs = qm.getVulnerableSoftwareByCpe23(cpeStr, versionEndExcluding,
                    versionEndIncluding, versionStartExcluding, versionStartIncluding);
            if (vs != null) {
                return vs;
            }
            try {
                vs = ModelConverter.convertCpe23UriToVulnerableSoftware(cpeStr);
            } catch (CpeParsingException | CpeEncodingException e) {
                LOGGER.warn("Failed to parse CPE from \"%s\" for %s; Skipping".formatted(cpeStr, vulnId), e);
                return null;
            }
        }

        vs.setVulnerable(true);
        vs.setVersionStartExcluding(versionStartExcluding);
        vs.setVersionStartIncluding(versionStartIncluding);
        vs.setVersionEndExcluding(versionEndExcluding);
        vs.setVersionEndIncluding(versionEndIncluding);
        return vs;
    }
}
