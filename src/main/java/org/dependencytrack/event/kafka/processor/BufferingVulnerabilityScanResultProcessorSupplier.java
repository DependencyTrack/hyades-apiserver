package org.dependencytrack.event.kafka.processor;

import org.apache.kafka.common.config.TopicConfig;
import org.apache.kafka.common.serialization.Serdes;
import org.apache.kafka.streams.processor.api.FixedKeyProcessor;
import org.apache.kafka.streams.processor.api.FixedKeyProcessorSupplier;
import org.apache.kafka.streams.state.KeyValueStore;
import org.apache.kafka.streams.state.StoreBuilder;
import org.dependencytrack.event.kafka.serialization.KafkaProtobufSerde;
import org.hyades.proto.vulnanalysis.internal.v1.BufferedScanResults;
import org.hyades.proto.vulnanalysis.v1.ScanResult;

import java.time.Duration;
import java.util.Map;
import java.util.Set;

import static org.apache.kafka.streams.state.Stores.inMemoryKeyValueStore;
import static org.apache.kafka.streams.state.Stores.keyValueStoreBuilder;

public class BufferingVulnerabilityScanResultProcessorSupplier implements FixedKeyProcessorSupplier<String, ScanResult, BufferedScanResults> {

    private final StoreBuilder<KeyValueStore<String, BufferedScanResults>> storeBuilder;
    private final Duration flushInterval;

    public BufferingVulnerabilityScanResultProcessorSupplier(final String storeName, final Duration flushInterval) {
        this.storeBuilder = keyValueStoreBuilder(inMemoryKeyValueStore(storeName), Serdes.String(), new KafkaProtobufSerde<>(BufferedScanResults.parser()))
                .withLoggingEnabled(Map.of(
                        TopicConfig.CLEANUP_POLICY_CONFIG, TopicConfig.CLEANUP_POLICY_COMPACT,
                        TopicConfig.SEGMENT_BYTES_CONFIG, String.valueOf(64 * 1024 * 1024), // 64 MiB
                        TopicConfig.MAX_COMPACTION_LAG_MS_CONFIG, "0"
                ));
        this.flushInterval = flushInterval;
    }

    @Override
    public FixedKeyProcessor<String, ScanResult, BufferedScanResults> get() {
        return new BufferingVulnerabilityScanResultProcessor(storeBuilder.name(), flushInterval);
    }

    @Override
    public Set<StoreBuilder<?>> stores() {
        return Set.of(storeBuilder);
    }

}
