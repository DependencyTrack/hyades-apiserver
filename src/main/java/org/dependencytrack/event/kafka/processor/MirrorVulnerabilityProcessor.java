package org.dependencytrack.event.kafka.processor;

import alpine.common.logging.Logger;
import alpine.common.metrics.Metrics;
import alpine.event.framework.Event;
import com.github.packageurl.MalformedPackageURLException;
import com.github.packageurl.PackageURL;
import io.micrometer.core.instrument.Timer;
import org.apache.commons.lang3.StringUtils;
import org.apache.kafka.streams.processor.api.Processor;
import org.apache.kafka.streams.processor.api.Record;
import org.cyclonedx.proto.v1_4.Bom;
import org.cyclonedx.proto.v1_4.ScoreMethod;
import org.cyclonedx.proto.v1_4.Source;
import org.dependencytrack.event.IndexEvent;
import org.dependencytrack.model.Cwe;
import org.dependencytrack.model.Severity;
import org.dependencytrack.model.Vulnerability;
import org.dependencytrack.model.VulnerableSoftware;
import org.dependencytrack.parser.nvd.ModelConverter;
import org.dependencytrack.persistence.QueryManager;
import us.springett.parsers.cpe.exceptions.CpeEncodingException;
import us.springett.parsers.cpe.exceptions.CpeParsingException;

import java.math.BigDecimal;
import java.sql.Date;
import java.time.Instant;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.concurrent.atomic.AtomicReference;


public class MirrorVulnerabilityProcessor implements Processor<String, Bom, Void, Void> {

    private static final Logger LOGGER = Logger.getLogger(MirrorVulnerabilityProcessor.class);
    private static final Timer TIMER = Timer.builder("vuln_mirror_processing")
            .description("Time taken to process mirrored vulnerabilities")
            .register(Metrics.getRegistry());

    @Override
    public void process(final Record<String, Bom> record) {
        final Timer.Sample timerSample = Timer.start();

        try (QueryManager qm = new QueryManager().withL2CacheDisabled()) {
            LOGGER.debug("Synchronizing Mirrored Vulnerability : " + record.key());
            Bom bom = record.value();
            String key = record.key();
            String mirrorSource = key.substring(0, key.indexOf("/"));
            Vulnerability.Source source = Vulnerability.Source.valueOf(mirrorSource);
            final Vulnerability vulnerability = mapBomToVulnerability(qm, bom);
            final List<VulnerableSoftware> vsListOld = qm.detach(qm.getVulnerableSoftwareByVulnId(vulnerability.getSource(), vulnerability.getVulnId()));
            final Vulnerability synchronizedVulnerability = qm.synchronizeVulnerability(vulnerability, false);
            var cycloneVuln = bom.getVulnerabilities(0);
            // Alias synchronization across multiple sources is too unreliable right now.
            // We can re-enable this once we have more confidence in data quality, or a better
            // way of auditing reported aliases. See also: https://github.com/google/osv.dev/issues/888
//            if (!cycloneVuln.getReferencesList().isEmpty()) {
//                cycloneVuln.getReferencesList().stream().forEach(reference -> {
//                    final String alias = reference.getId();
//                    final VulnerabilityAlias vulnerabilityAlias = new VulnerabilityAlias();
//
//                    // OSV will use IDs of other vulnerability databases for its
//                    // primary advisory ID (e.g. GHSA-45hx-wfhj-473x). We need to ensure
//                    // that we don't falsely report GHSA IDs as stemming from OSV.
//                    final Vulnerability.Source advisorySource = extractSource(cycloneVuln.getId(), cycloneVuln.getSource());
//                    if (mirrorSource.equals("OSV")) {
//                        switch (advisorySource) {
//                            case NVD -> vulnerabilityAlias.setCveId(cycloneVuln.getId());
//                            case GITHUB -> vulnerabilityAlias.setGhsaId(cycloneVuln.getId());
//                            default -> vulnerabilityAlias.setOsvId(cycloneVuln.getId());
//                        }
//                    }
//                    if (alias.startsWith("CVE") && Vulnerability.Source.NVD != advisorySource) {
//                        vulnerabilityAlias.setCveId(alias);
//                        qm.synchronizeVulnerabilityAlias(vulnerabilityAlias);
//                    } else if (alias.startsWith("GHSA") && Vulnerability.Source.GITHUB != advisorySource) {
//                        vulnerabilityAlias.setGhsaId(alias);
//                        qm.synchronizeVulnerabilityAlias(vulnerabilityAlias);
//                    }
//                });
//            }
            if (!cycloneVuln.getAffectsList().isEmpty()) {
                final List<VulnerableSoftware> vsList = new ArrayList<>();
                cycloneVuln.getAffectsList().stream().forEach(affect -> {
                    AtomicReference<String> purlStr = new AtomicReference<>();
                    AtomicReference<String> cpeStr = new AtomicReference<>();
                    if (!bom.getComponentsList().isEmpty()) {
                        bom.getComponentsList().stream().forEach(component -> {
                            if (component.getBomRef().equals(affect.getRef())) {
                                purlStr.set(component.getPurl());
                                cpeStr.set(component.getCpe());
                            }
                        });
                    }

                    if (StringUtils.isEmpty(purlStr.get()) && StringUtils.isEmpty(cpeStr.get())) {
                        LOGGER.debug("No PURL or CPE provided for affected package  - skipping " + affect.getRef());

                    } else {
                        affect.getVersionsList().stream().forEach(version -> {
                            if (version.hasRange()) {
                                VulnerableSoftware vs = mapAffectedRangeToVulnerableSoftware(qm, version.getRange(), purlStr.get(), cpeStr.get());
                                if (vs != null) {
                                    vsList.add(vs);
                                }
                            } if (version.hasVersion()) {
                                vsList.add(mapAffectedVersionToVulnerableSoftware(qm, version.getVersion(), purlStr.get(), cpeStr.get()));
                            }
                        });
                    }
                });
                qm.persist(vsList);
                qm.updateAffectedVersionAttributions(synchronizedVulnerability, vsList, source);
                var reconciledVsList = qm.reconcileVulnerableSoftware(synchronizedVulnerability, vsListOld, vsList, source);
                synchronizedVulnerability.setVulnerableSoftware(reconciledVsList);
            }
            qm.persist(synchronizedVulnerability);
            Event.dispatch(new IndexEvent(IndexEvent.Action.COMMIT, Vulnerability.class));
        } catch (Exception e) {
            // TODO: Send record to a dead letter topic.
            LOGGER.error("Synchronizing vulnerability %s failed".formatted(record.key()), e);
        } finally {
            timerSample.stop(TIMER);
        }
    }

    public VulnerableSoftware mapAffectedVersionToVulnerableSoftware(QueryManager qm, String version, String purlStr, String cpeStr) {
        var vs = new VulnerableSoftware();
        if (!StringUtils.isEmpty(purlStr)) {
            final PackageURL purl;
            try {
                purl = new PackageURL(purlStr);
                vs = qm.getVulnerableSoftwareByPurlAndVersion(purl.getType(), purl.getNamespace(), purl.getName(), version);
                if (vs != null) {
                    return vs;
                } else {
                    vs = new VulnerableSoftware();
                    vs.setPurlType(purl.getType());
                    vs.setPurlNamespace(purl.getNamespace());
                    vs.setPurlName(purl.getName());
                    vs.setPurl(purl.canonicalize());
                    vs.setVersion(version);
                }
            } catch (MalformedPackageURLException e) {
                LOGGER.debug("Invalid PURL provided for affected package  - skipping", e);
                return null;
            }
        } else if (!StringUtils.isEmpty(cpeStr)) {
            try {

                VulnerableSoftware vsExisting = qm.getVulnerableSoftwareByCpe23AndVersion(cpeStr, version);
                if (vsExisting != null) {
                    return vsExisting;
                } else {
                    vs = ModelConverter.convertCpe23UriToVulnerableSoftware(cpeStr);
                    vs.setVersion(version);
                    vs.setVulnerable(true);
                }
            } catch (CpeParsingException | CpeEncodingException e) {
                LOGGER.warn("An error occurred while parsing: " + cpeStr);
            }
        }
        return vs;
    }

    public VulnerableSoftware mapAffectedRangeToVulnerableSoftware(final QueryManager qm, String range, String purlStr, String cpeStr) {
        VulnerableSoftware vs = new VulnerableSoftware();
        // Other sources do not populate the versionStartIncluding with 0.
        // Semantically, versionStartIncluding=null is equivalent to >=0.
        // Omit zero values here for consistency's sake.
        String versionStartIncluding = null;
        String versionStartExcluding = null;
        String versionEndIncluding = null;
        String versionEndExcluding = null;
        if (StringUtils.trimToNull(range) != null) {
            // Range should arrive in format:
            //   vers:<versioning-scheme>/<version-constraint>|<version-constraint>|...
            final String[] versParts = range.split("/", 2);
            if (versParts.length != 2) {
                LOGGER.warn("Encountered version range in invalid format: %s".formatted(range));
                return null;
            }

            range = versParts[1];
            final String[] parts;
            if (range.contains("|")) {
                parts = Arrays.stream(range.split("\\|")).map(String::trim).toArray(String[]::new);
            } else {
                parts = Arrays.stream(range.split(" ")).map(String::trim).toArray(String[]::new);
            }
            for (String part : parts) {
                if (part.startsWith(">=") || part.startsWith("[")) {
                    versionStartIncluding = part.replace(">=", "").replace("[", "").trim();
                    if (versionStartIncluding.length() == 0 || versionStartIncluding.contains("*")) {
                        versionStartIncluding = null;
                    }
                } else if (part.startsWith(">") || part.startsWith("(")) {
                    versionStartExcluding = part.replace(">", "").replace("(", "").trim();
                    if (versionStartExcluding.length() == 0 || versionStartExcluding.contains("*")) {
                        versionStartIncluding = null;
                    }
                } else if (part.startsWith("<=") || part.endsWith("]")) {
                    versionEndIncluding = part.replace("<=", "").replace("]", "").trim();
                } else if (part.startsWith("<") || part.endsWith(")")) {
                    versionEndExcluding = part.replace("<", "").replace(")", "").trim();
                    if (versionEndExcluding.length() == 0 || versionEndExcluding.contains("*")) {
                        versionStartIncluding = null;
                    }
                } else if (part.startsWith("=")) {
                    versionStartIncluding = part.replace("=", "").trim();
                    versionEndIncluding = part.replace("=", "").trim();
                    if (versionStartIncluding.length() == 0 || versionStartIncluding.contains("*")) {
                        versionStartIncluding = null;
                    }
                    if (versionEndIncluding.length() == 0 || versionEndIncluding.contains("*")) {
                        versionStartIncluding = null;
                    }
                } else { //since we are not able to parse specific range, we do not want to end up with false positives and therefore this part will be skipped from being saved to db.
                    LOGGER.debug("Range not definite");
                }
            }
        }

        if (!StringUtils.isEmpty(purlStr)) {
            final PackageURL purl;
            try {
                purl = new PackageURL(purlStr);
            } catch (MalformedPackageURLException e) {
                LOGGER.debug("Invalid PURL provided for affected package  - skipping", e);
                return null;
            }
            vs = qm.getVulnerableSoftwareByPurl(purl.getType(), purl.getNamespace(), purl.getName(),
                    versionEndExcluding, versionEndIncluding, null, versionStartIncluding);
            if (vs != null) {
                return vs;
            }
            vs = new VulnerableSoftware();
            vs.setPurlType(purl.getType());
            vs.setPurlNamespace(purl.getNamespace());
            vs.setPurlName(purl.getName());
            vs.setPurl(purl.canonicalize());

        } else if (!StringUtils.isEmpty(cpeStr)) {
            vs = qm.getVulnerableSoftwareByCpe23(cpeStr, versionEndExcluding,
                    versionEndIncluding, versionStartExcluding, versionStartIncluding);
            if (vs != null) {
                return vs;
            }
            try {
                vs = ModelConverter.convertCpe23UriToVulnerableSoftware(cpeStr);
            } catch (CpeParsingException | CpeEncodingException e) {
                LOGGER.warn("An error occurred while parsing: " + cpeStr);
            }
        }

        vs.setVulnerable(true);
        vs.setVersionStartIncluding(versionStartIncluding);
        vs.setVersionEndExcluding(versionEndExcluding);
        vs.setVersionEndIncluding(versionEndIncluding);
        return vs;
    }

    public Vulnerability mapBomToVulnerability(final QueryManager qm, final Bom bom) {
        org.cyclonedx.proto.v1_4.Vulnerability cycloneVuln = bom.getVulnerabilities(0);
        final Vulnerability vuln = new Vulnerability();
        if (cycloneVuln.getId() != null) {
            vuln.setSource(extractSource(cycloneVuln.getId(), cycloneVuln.getSource()));
        }
        vuln.setVulnId(cycloneVuln.getId());
        vuln.setTitle(StringUtils.abbreviate(cycloneVuln.getDescription(), 255));
        vuln.setDescription(cycloneVuln.getDetail());
        vuln.setPublished(Date.from(Instant.ofEpochSecond(cycloneVuln.getPublished().getSeconds())));
        vuln.setUpdated(Date.from(Instant.ofEpochSecond(cycloneVuln.getUpdated().getSeconds())));

        if (cycloneVuln.getCredits() != null) {
            vuln.setCredits(String.join(", ", cycloneVuln.getCredits().toString()));
        }
        final StringBuilder sb = new StringBuilder();
        if (!bom.getExternalReferencesList().isEmpty()) {
            bom.getExternalReferencesList().stream().forEach(externalReference -> {
                sb.append("* [").append(externalReference.getUrl()).append("](").append(externalReference.getUrl()).append(")\n");
            });
            vuln.setReferences(sb.toString());
        }
        if(!cycloneVuln.getAdvisoriesList().isEmpty()){
            cycloneVuln.getAdvisoriesList().stream().forEach(advisory -> {
                sb.append("* [").append(advisory.getUrl()).append("](").append(advisory.getUrl()).append(")\n");
            });
            vuln.setReferences(sb.toString());
        }


        if (!cycloneVuln.getCwesList().isEmpty()) {
            cycloneVuln.getCwesList().stream().forEach(cweId -> {
                final Cwe cwe = qm.getCweById(cweId);
                if (cwe != null) {
                    vuln.addCwe(cwe);
                }
            });
        }
        vuln.setSeverity(calculateSeverity(bom));
        if (!cycloneVuln.getRatingsList().isEmpty() && cycloneVuln.getRatings(0).getMethod() != null) {
            if (cycloneVuln.getRatings(0).getMethod().equals(ScoreMethod.SCORE_METHOD_CVSSV2)) {
                vuln.setCvssV2Vector(cycloneVuln.getRatings(0).getVector());
                vuln.setCvssV2BaseScore(BigDecimal.valueOf(cycloneVuln.getRatings(0).getScore()));
            }
            if (cycloneVuln.getRatings(0).getMethod().equals(ScoreMethod.SCORE_METHOD_CVSSV3)) {
                vuln.setCvssV3Vector(cycloneVuln.getRatings(0).getVector());
                vuln.setCvssV3BaseScore(BigDecimal.valueOf(cycloneVuln.getRatings(0).getScore()));
            }
        }
        return vuln;
    }

    public Severity calculateSeverity(Bom bom) {
        if (bom.getVulnerabilities(0) != null
                && !bom.getVulnerabilities(0).getRatingsList().isEmpty()
                && bom.getVulnerabilities(0).getRatings(0) != null) {
            org.cyclonedx.proto.v1_4.Severity severity =
                    bom.getVulnerabilities(0).getRatings(0).getSeverity();
            if (severity != null) {
                if (severity.equals(org.cyclonedx.proto.v1_4.Severity.SEVERITY_CRITICAL)) {
                    return Severity.CRITICAL;
                } else if (severity.equals(org.cyclonedx.proto.v1_4.Severity.SEVERITY_HIGH)) {
                    return Severity.HIGH;
                } else if (severity.equals(org.cyclonedx.proto.v1_4.Severity.SEVERITY_MEDIUM)) {
                    return Severity.MEDIUM;
                } else if (severity.equals(org.cyclonedx.proto.v1_4.Severity.SEVERITY_LOW)) {
                    return Severity.LOW;
                }
            }
        }
        return Severity.UNASSIGNED;
    }

    public Vulnerability.Source extractSource(String vulnId, Source source) {
        final String sourceId = vulnId.split("-")[0];
        return switch (sourceId) {
            case "GHSA" -> Vulnerability.Source.GITHUB;
            case "CVE" -> Vulnerability.Source.NVD;
            default -> source!= null ? Vulnerability.Source.valueOf(source.getName()) : Vulnerability.Source.INTERNAL;
        };
    }
}
