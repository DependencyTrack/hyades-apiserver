package org.dependencytrack.event.kafka.processor;

import alpine.event.framework.ChainableEvent;
import alpine.event.framework.Event;
import org.apache.kafka.clients.consumer.ConsumerRecord;
import org.dependencytrack.event.ComponentMetricsUpdateEvent;
import org.dependencytrack.event.ComponentPolicyEvaluationEvent;
import org.dependencytrack.event.ProjectMetricsUpdateEvent;
import org.dependencytrack.event.ProjectPolicyEvaluationEvent;
import org.dependencytrack.event.kafka.processor.api.BatchRecordProcessor;
import org.dependencytrack.event.kafka.processor.exception.RecordProcessingException;
import org.dependencytrack.model.VulnerabilityScan;
import org.dependencytrack.model.VulnerabilityScan.Status;
import org.dependencytrack.persistence.QueryManager;
import org.dependencytrack.persistence.jdbi.mapping.VulnerabilityScanRowMapper;
import org.dependencytrack.proto.vulnanalysis.v1.ScanResult;
import org.jdbi.v3.core.Handle;
import org.jdbi.v3.core.statement.PreparedBatch;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.UUID;

import static java.lang.Math.toIntExact;
import static org.dependencytrack.persistence.jdbi.JdbiFactory.jdbi;
import static org.dependencytrack.proto.vulnanalysis.v1.ScanStatus.SCAN_STATUS_FAILED;

public class ProcessedVulnerabilityScanResultProcessor implements BatchRecordProcessor<String, ScanResult> {

    public static final String PROCESSOR_NAME = "processed.vuln.scan.result";

    @Override
    public void process(final List<ConsumerRecord<String, ScanResult>> records) throws RecordProcessingException {
        final List<VulnerabilityScan> completedScans = processScanResults(records);
        triggerPolicyEvalAndMetricsUpdates(completedScans);
    }

    private static List<VulnerabilityScan> processScanResults(final List<ConsumerRecord<String, ScanResult>> records) {
        try (final var qm = new QueryManager()) {
            return jdbi(qm).inTransaction(jdbiHandle -> {
                final List<VulnerabilityScan> completedScans = recordScanResults(jdbiHandle, records);
                if (completedScans.isEmpty()) {
                    return completedScans;
                }

                updateWorkflowSteps(jdbiHandle, completedScans);

                return completedScans;
            });
        }
    }

    private static List<VulnerabilityScan> recordScanResults(final Handle jdbiHandle, final List<ConsumerRecord<String, ScanResult>> records) {
        // As we may get multiple records for the same scan token,
        // aggregate their respective values to reduce the number
        // of SQL updates we have to execute.
        final var aggregatesByToken = new HashMap<String, ResultAggregate>();
        for (final ConsumerRecord<String, ScanResult> record : records) {
            aggregatesByToken.compute(record.key(), (token, existingAggregate) -> {
                final ResultAggregate aggregate = Optional.ofNullable(existingAggregate)
                        .orElseGet(ResultAggregate::new);
                aggregate.results++;
                aggregate.scannerResultsTotal += record.value().getScannerResultsCount();
                aggregate.scannerResultsFailed += toIntExact(record.value().getScannerResultsList().stream()
                        .filter(result -> result.getStatus() == SCAN_STATUS_FAILED)
                        .count());
                return aggregate;
            });
        }

        final PreparedBatch preparedBatch = jdbiHandle.prepareBatch("""
                UPDATE "VULNERABILITYSCAN"
                SET
                  "RECEIVED_RESULTS" = "RECEIVED_RESULTS" + :results,
                  "SCAN_TOTAL" = "SCAN_TOTAL" + :scannerResultsTotal,
                  "SCAN_FAILED" = "SCAN_FAILED" + :scannerResultsFailed,
                  "STATUS" = (
                    CASE
                      WHEN "EXPECTED_RESULTS" = ("RECEIVED_RESULTS" + :results) THEN
                        CASE
                          WHEN
                            (("SCAN_FAILED" + :scannerResultsFailed)
                             / ("SCAN_TOTAL" + :scannerResultsTotal)) > "FAILURE_THRESHOLD"
                          THEN
                            'FAILED'
                          ELSE
                            'COMPLETED'
                        END
                      ELSE 'IN_PROGRESS'
                    END
                  ),
                  "UPDATED_AT" = NOW()
                WHERE
                  "TOKEN" = :token
                RETURNING
                  "TOKEN",
                  "STATUS",
                  "TARGET_TYPE",
                  "TARGET_IDENTIFIER",
                  CASE
                    WHEN
                      "STATUS" = 'FAILED'
                    THEN
                      'Failure threshold of ' || "FAILURE_THRESHOLD" || '% exceeded: '
                      || "SCAN_FAILED" || '/' || "SCAN_TOTAL" || ' of scans failed'
                  END
                """);

        for (final Map.Entry<String, ResultAggregate> tokenAndAggregate : aggregatesByToken.entrySet()) {
            final String token = tokenAndAggregate.getKey();
            final ResultAggregate aggregate = tokenAndAggregate.getValue();

            preparedBatch
                    .bind("token", token)
                    .bind("results", aggregate.results)
                    .bind("scannerResultsTotal", aggregate.scannerResultsTotal)
                    .bind("scannerResultsFailed", aggregate.scannerResultsFailed)
                    .add();
        }

        return preparedBatch
                .executePreparedBatch("TOKEN", "STATUS", "TARGET_TYPE", "TARGET_IDENTIFIER")
                .map(new VulnerabilityScanRowMapper())
                .stream()
                // Unfortunately we can't perform this filtering in SQL, as RETURNING
                // does not allow a WHERE clause. Tried using a CTE as workaround:
                //   WITH "CTE" AS (UPDATE ... RETURNING ...) SELECT * FROM "CTE"
                // but that didn't return any results at all.
                .filter(vulnScan -> vulnScan.getStatus() == Status.COMPLETED
                        || vulnScan.getStatus() == Status.FAILED)
                .toList();
    }

    private static void updateWorkflowSteps(final Handle jdbiHandle, final List<VulnerabilityScan> completedScans) {
        final PreparedBatch preparedBatch = jdbiHandle.prepareBatch("""
                UPDATE "WORKFLOW_STATE"
                SET
                  "STATUS" = :status,
                  "FAILURE_REASON" = :failureReason,
                  "UPDATED_AT" = NOW()
                WHERE
                  "TOKEN" = :token
                """);

        for (final VulnerabilityScan vulnScan : completedScans) {
            preparedBatch
                    .bind("token", vulnScan.getToken())
                    .bind("status", vulnScan.getStatus())
                    .bind("failureReason", vulnScan.getFailureReason())
                    .add();
        }

        preparedBatch.executePreparedBatch();
    }

    private static void triggerPolicyEvalAndMetricsUpdates(final List<VulnerabilityScan> completedScans) {
        for (final VulnerabilityScan vulnScan : completedScans) {
            final ChainableEvent policyEvaluationEvent = switch (vulnScan.getTargetType()) {
                case COMPONENT -> new ComponentPolicyEvaluationEvent(vulnScan.getTargetIdentifier());
                case PROJECT -> new ProjectPolicyEvaluationEvent(vulnScan.getTargetIdentifier());
            };
            policyEvaluationEvent.setChainIdentifier(UUID.fromString(vulnScan.getToken()));

            final ChainableEvent metricsUpdateEvent = switch (vulnScan.getTargetType()) {
                case COMPONENT -> new ComponentMetricsUpdateEvent(vulnScan.getTargetIdentifier());
                case PROJECT -> new ProjectMetricsUpdateEvent(vulnScan.getTargetIdentifier());
            };
            metricsUpdateEvent.setChainIdentifier(UUID.fromString(vulnScan.getToken()));

            policyEvaluationEvent.onFailure(metricsUpdateEvent);
            policyEvaluationEvent.onSuccess(metricsUpdateEvent);

            Event.dispatch(policyEvaluationEvent);
        }
    }

    private static class ResultAggregate {

        private int results;
        private int scannerResultsTotal;
        private int scannerResultsFailed;

    }

}
