package org.dependencytrack.event.kafka.processor;

import org.apache.kafka.streams.KeyValue;
import org.apache.kafka.streams.processor.Cancellable;
import org.apache.kafka.streams.processor.PunctuationType;
import org.apache.kafka.streams.processor.api.ContextualFixedKeyProcessor;
import org.apache.kafka.streams.processor.api.FixedKeyProcessorContext;
import org.apache.kafka.streams.processor.api.FixedKeyRecord;
import org.apache.kafka.streams.state.KeyValueIterator;
import org.apache.kafka.streams.state.KeyValueStore;
import org.dependencytrack.event.kafka.streams.FixedKeyRecordFactory;
import org.hyades.proto.vulnanalysis.internal.v1.BufferedScanResults;
import org.hyades.proto.vulnanalysis.v1.ScanResult;
import org.hyades.proto.vulnanalysis.v1.ScanStatus;
import org.hyades.proto.vulnanalysis.v1.ScannerResult;

import java.time.Duration;
import java.util.Optional;

class BufferingVulnerabilityScanResultProcessor extends ContextualFixedKeyProcessor<String, ScanResult, BufferedScanResults> {

    private final String storeName;
    private final Duration flushInterval;
    private KeyValueStore<String, BufferedScanResults> store;
    private Cancellable punctuator;

    BufferingVulnerabilityScanResultProcessor(final String storeName, final Duration flushInterval) {
        this.storeName = storeName;
        this.flushInterval = flushInterval;
    }

    @Override
    public void init(final FixedKeyProcessorContext<String, BufferedScanResults> context) {
        super.init(context);

        store = context().getStateStore(storeName);
        punctuator = context().schedule(flushInterval, PunctuationType.WALL_CLOCK_TIME, this::punctuate);
    }

    @Override
    public void process(final FixedKeyRecord<String, ScanResult> record) {
        final String scanToken = record.key();
        final ScanResult scanResult = record.value();

        final BufferedScanResults.Builder resultsBuilder = Optional.ofNullable(store.get(scanToken))
                .map(BufferedScanResults::toBuilder)
                .orElseGet(BufferedScanResults::newBuilder);

        resultsBuilder
                .setResultsTotal(resultsBuilder.getResultsTotal() + 1)
                .setScannerResultsTotal(scanResult.getScannerResultsCount())
                .setScannerResultsFailed(Math.toIntExact(scanResult.getScannerResultsList().stream()
                        .map(ScannerResult::getStatus)
                        .filter(ScanStatus.SCAN_STATUS_FAILED::equals)
                        .count()));

        store.put(scanToken, resultsBuilder.build());
    }

    @Override
    public void close() {
        Optional.ofNullable(punctuator).ifPresent(Cancellable::cancel);
    }

    private void punctuate(final long timestamp) {
        try (final KeyValueIterator<String, BufferedScanResults> all = store.all()) {
            while (all.hasNext()) {
                final KeyValue<String, BufferedScanResults> record = all.next();
                context().forward(FixedKeyRecordFactory.create(record.key, record.value, context().currentSystemTimeMs(), null));
                store.delete(record.key);
            }
        }
    }

}
