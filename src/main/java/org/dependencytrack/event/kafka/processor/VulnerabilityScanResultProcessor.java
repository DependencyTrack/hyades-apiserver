package org.dependencytrack.event.kafka.processor;

import alpine.common.logging.Logger;
import org.apache.commons.lang3.exception.ExceptionUtils;
import org.apache.kafka.streams.processor.api.ContextualProcessor;
import org.apache.kafka.streams.processor.api.Record;
import org.dependencytrack.event.kafka.dto.VulnerabilityScanKey;
import org.dependencytrack.event.kafka.dto.VulnerabilityScanResult;
import org.dependencytrack.event.kafka.dto.VulnerabilityScanStatus;
import org.dependencytrack.model.Component;
import org.dependencytrack.model.Vulnerability;
import org.dependencytrack.persistence.QueryManager;
import org.postgresql.util.PSQLState;

import javax.jdo.JDODataStoreException;
import javax.jdo.PersistenceManager;
import javax.jdo.Query;
import javax.jdo.Transaction;
import java.sql.SQLException;
import java.util.Optional;
import java.util.UUID;

/**
 * A {@link ContextualProcessor} responsible for processing {@link VulnerabilityScanResult}s.
 * <p>
 * {@link VulnerabilityScanResult}s with status {@link VulnerabilityScanStatus#COMPLETE} will be forwarded,
 * results of any other status will be dropped after processing. Forwarded records are re-keyed to their
 * original {@link VulnerabilityScanKey}.
 */
public class VulnerabilityScanResultProcessor extends ContextualProcessor<UUID, VulnerabilityScanResult, VulnerabilityScanKey, VulnerabilityScanResult> {

    private static final Logger LOGGER = Logger.getLogger(VulnerabilityScanResultProcessor.class);

    @Override
    public void process(final Record<UUID, VulnerabilityScanResult> record) {
        final UUID componentUuid = record.key();
        final VulnerabilityScanResult result = record.value();

        if (VulnerabilityScanStatus.COMPLETE == result.status()) {
            context().forward(record.withKey(result.key()));
            return;
        } else if (VulnerabilityScanStatus.FAILED == result.status()) {
            LOGGER.warn("Scan of component %s (token: %s) with %s failed: %s"
                    .formatted(componentUuid, result.key().token(), result.scanner(), result.failureReason()));
            return;
        } else if (VulnerabilityScanStatus.SUCCESSFUL != result.status()) {
            LOGGER.warn("Unable to process results with status %s; Dropping record for component %s (token: %s)"
                    .formatted(result.status(), componentUuid, result.key().token()));
            return;
        }

        if (result.vulnerabilities() == null || result.vulnerabilities().isEmpty()) {
            LOGGER.debug("No vulnerabilities identified for %s by %s".formatted(componentUuid, result.scanner()));
            return;
        }

        try (final var qm = new QueryManager()) {
            final PersistenceManager pm = qm.getPersistenceManager();

            if (!componentExists(pm, componentUuid)) {
                LOGGER.warn("Received result for component %s (token: %s), but it does not exist (anymore?)"
                        .formatted(componentUuid, result.key().token()));
                return;
            }

            for (final Vulnerability vuln : result.vulnerabilities()) {
                final Vulnerability persistentVuln = persistVulnerability(pm, vuln);
                addVulnerability(pm, componentUuid, persistentVuln);
            }
        }
    }

    private Vulnerability persistVulnerability(final PersistenceManager pm, final Vulnerability vuln) {
        final int maxRetryAttempts = 3;
        Vulnerability persistentVuln = null;

        // It is possible that the same vulnerability is reported for multiple components in parallel,
        // causing unique constraint violations when attempting to insert into the VULNERABILITY table.
        // In such cases, we can get away with simply retrying to SELECT or INSERT again. We'll attempt
        // up to 3 times before giving up.
        for (int i = 0; i < maxRetryAttempts; i++) {
            final Transaction trx = pm.currentTransaction();
            try {
                trx.begin();

                final Query<Vulnerability> query = pm.newQuery(Vulnerability.class);
                query.setFilter("vulnId == :vulnId && source == :source");
                query.setParameters(vuln.getVulnId(), vuln.getSource());
                persistentVuln = query.executeUnique();
                if (persistentVuln != null) {
                    break;
                }

                persistentVuln = pm.makePersistent(vuln);
                trx.commit();
            } catch (JDODataStoreException e) {
                // TODO: DataNucleus doesn't map constraint violation exceptions very well,
                // so we have to depend on the exception of the underlying JDBC driver to
                // tell us what happened. We currently only handle PostgreSQL, but we'll have
                // to do the same for at least H2 and MSSQL.
                if (ExceptionUtils.getRootCause(e) instanceof final SQLException se
                        && PSQLState.UNIQUE_VIOLATION.getState().equals(se.getSQLState())) {
                    continue; // Retry
                }

                throw e;
            } finally {
                if (trx.isActive()) {
                    trx.rollback();
                }
            }
        }

        return Optional.ofNullable(persistentVuln)
                .orElseThrow(() -> new IllegalStateException(
                        "Failed to persist vulnerability %s after %d attempts".formatted(vuln, maxRetryAttempts)));
    }

    private boolean componentExists(final PersistenceManager pm, final UUID uuid) {
        final Transaction trx = pm.currentTransaction();
        try {
            trx.begin();
            final Query<Component> query = pm.newQuery(Component.class);
            query.setFilter("uuid == :uuid");
            query.setParameters(uuid);
            query.setResult("count(this)");
            return query.executeResultUnique(Long.class) > 0;
        } finally {
            trx.rollback(); // Read-only transaction, no need to commit anything
        }
    }

    private void addVulnerability(final PersistenceManager pm, final UUID componentUuid, final Vulnerability vuln) {
        final Transaction trx = pm.currentTransaction();
        try {
            trx.begin();
            final Query<Component> query = pm.newQuery(Component.class);
            query.setFilter("uuid == :uuid");
            query.setParameters(componentUuid);
            final Component component = query.executeUnique();
            component.addVulnerability(vuln);
            trx.commit();
        } finally {
            if (trx.isActive()) {
                trx.rollback();
            }
        }
    }

}
