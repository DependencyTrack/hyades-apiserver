/*
 * This file is part of Dependency-Track.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 * Copyright (c) OWASP Foundation. All Rights Reserved.
 */
package org.dependencytrack.event.kafka.processor;

import alpine.Config;
import alpine.common.logging.Logger;
import alpine.notification.Notification;
import alpine.notification.NotificationLevel;
import com.google.protobuf.Any;
import com.google.protobuf.Timestamp;
import com.google.protobuf.util.Timestamps;
import org.apache.kafka.clients.consumer.ConsumerRecord;
import org.dependencytrack.event.PortfolioVulnerabilityAnalysisEvent;
import org.dependencytrack.event.kafka.KafkaEvent;
import org.dependencytrack.event.kafka.KafkaEventConverter;
import org.dependencytrack.event.kafka.KafkaEventDispatcher;
import org.dependencytrack.event.kafka.KafkaEventHeaders;
import org.dependencytrack.event.kafka.KafkaTopics;
import org.dependencytrack.event.kafka.KafkaUtil;
import org.dependencytrack.event.kafka.processor.api.Processor;
import org.dependencytrack.model.AnalysisJustification;
import org.dependencytrack.model.AnalysisResponse;
import org.dependencytrack.model.AnalysisState;
import org.dependencytrack.model.AnalyzerIdentity;
import org.dependencytrack.model.Severity;
import org.dependencytrack.model.Vulnerability;
import org.dependencytrack.model.VulnerabilityAlias;
import org.dependencytrack.model.VulnerabilityAnalysisLevel;
import org.dependencytrack.model.mapping.PolicyProtoMapper;
import org.dependencytrack.notification.NotificationConstants;
import org.dependencytrack.notification.NotificationGroup;
import org.dependencytrack.notification.NotificationScope;
import org.dependencytrack.persistence.QueryManager;
import org.dependencytrack.persistence.jdbi.NotificationSubjectDao;
import org.dependencytrack.policy.vulnerability.VulnerabilityPolicy;
import org.dependencytrack.policy.vulnerability.VulnerabilityPolicyEvaluator;
import org.dependencytrack.policy.vulnerability.VulnerabilityPolicyOperation;
import org.dependencytrack.policy.vulnerability.VulnerabilityPolicyRating;
import org.dependencytrack.proto.notification.v1.Group;
import org.dependencytrack.proto.policy.v1.Project;
import org.dependencytrack.proto.vulnanalysis.v1.ScanKey;
import org.dependencytrack.proto.vulnanalysis.v1.ScanResult;
import org.dependencytrack.proto.vulnanalysis.v1.ScanStatus;
import org.dependencytrack.proto.vulnanalysis.v1.Scanner;
import org.dependencytrack.proto.vulnanalysis.v1.ScannerResult;
import org.dependencytrack.util.AnalysisCommentFormatter.AnalysisCommentField;
import org.dependencytrack.util.NotificationUtil;
import org.dependencytrack.util.PersistenceUtil;
import org.dependencytrack.util.PersistenceUtil.Differ;
import org.jdbi.v3.core.mapper.reflect.ColumnName;
import org.jdbi.v3.sqlobject.config.RegisterBeanMapper;
import org.jdbi.v3.sqlobject.config.RegisterConstructorMapper;
import org.jdbi.v3.sqlobject.customizer.Bind;
import org.jdbi.v3.sqlobject.customizer.BindBean;
import org.jdbi.v3.sqlobject.customizer.BindMethods;
import org.jdbi.v3.sqlobject.customizer.DefineNamedBindings;
import org.jdbi.v3.sqlobject.statement.GetGeneratedKeys;
import org.jdbi.v3.sqlobject.statement.SqlBatch;
import org.jdbi.v3.sqlobject.statement.SqlQuery;
import org.slf4j.MDC;

import jakarta.ws.rs.core.MultivaluedHashMap;
import javax.jdo.Query;
import javax.jdo.Transaction;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.NoSuchElementException;
import java.util.Objects;
import java.util.ServiceLoader;
import java.util.Set;
import java.util.UUID;
import java.util.function.Function;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import static org.apache.commons.lang3.StringUtils.isNotBlank;
import static org.datanucleus.PropertyNames.PROPERTY_PERSISTENCE_BY_REACHABILITY_AT_COMMIT;
import static org.datanucleus.PropertyNames.PROPERTY_RETAIN_VALUES;
import static org.dependencytrack.common.ConfigKey.VULNERABILITY_POLICY_ANALYSIS_ENABLED;
import static org.dependencytrack.common.MdcKeys.MDC_COMPONENT_UUID;
import static org.dependencytrack.common.MdcKeys.MDC_SCAN_TOKEN;
import static org.dependencytrack.parser.dependencytrack.ModelConverterCdxToVuln.convert;
import static org.dependencytrack.persistence.jdbi.JdbiFactory.inJdbiTransaction;
import static org.dependencytrack.persistence.jdbi.JdbiFactory.useJdbiHandle;
import static org.dependencytrack.persistence.jdbi.JdbiFactory.withJdbiHandle;
import static org.dependencytrack.proto.notification.v1.Group.GROUP_NEW_VULNERABILITY;
import static org.dependencytrack.proto.notification.v1.Group.GROUP_NEW_VULNERABLE_DEPENDENCY;
import static org.dependencytrack.proto.notification.v1.Group.GROUP_PROJECT_AUDIT_CHANGE;
import static org.dependencytrack.proto.notification.v1.Level.LEVEL_INFORMATIONAL;
import static org.dependencytrack.proto.notification.v1.Scope.SCOPE_PORTFOLIO;
import static org.dependencytrack.proto.vulnanalysis.v1.ScanStatus.SCAN_STATUS_FAILED;
import static org.dependencytrack.proto.vulnanalysis.v1.Scanner.SCANNER_INTERNAL;
import static org.dependencytrack.proto.vulnanalysis.v1.Scanner.SCANNER_SNYK;
import static org.dependencytrack.util.AnalysisCommentFormatter.formatComment;
import static org.dependencytrack.util.NotificationUtil.generateNotificationContent;
import static org.dependencytrack.util.NotificationUtil.generateNotificationTitle;
import static org.dependencytrack.util.NotificationUtil.generateTitle;
import static org.dependencytrack.util.VulnerabilityUtil.canBeMirrored;
import static org.dependencytrack.util.VulnerabilityUtil.isAuthoritativeSource;
import static org.dependencytrack.util.VulnerabilityUtil.isMirroringEnabled;

/**
 * A {@link Processor} responsible for processing {@link ScanResult}s.
 */
public class VulnerabilityScanResultProcessor implements Processor<ScanKey, ScanResult> {

    static String PROCESSOR_NAME = "vuln.scan.result";

    private static final Logger LOGGER = Logger.getLogger(VulnerabilityScanResultProcessor.class);

    private final ThreadLocal<List<KafkaEvent<?, ?>>> eventsToDispatch = ThreadLocal.withInitial(ArrayList::new);
    private final KafkaEventDispatcher eventDispatcher = new KafkaEventDispatcher();
    private final VulnerabilityPolicyEvaluator vulnPolicyEvaluator;

    public VulnerabilityScanResultProcessor() {
        this(Config.getInstance().getPropertyAsBoolean(VULNERABILITY_POLICY_ANALYSIS_ENABLED)
                ? ServiceLoader.load(VulnerabilityPolicyEvaluator.class).findFirst().orElseThrow()
                : null);
    }

    VulnerabilityScanResultProcessor(final VulnerabilityPolicyEvaluator vulnPolicyEvaluator) {
        this.vulnPolicyEvaluator = vulnPolicyEvaluator;
    }

    @Override
    public void process(final ConsumerRecord<ScanKey, ScanResult> record) {
        final ScanKey scanKey = record.key();
        final ScanResult scanResult = record.value();
        final VulnerabilityAnalysisLevel analysisLevel = determineAnalysisLevel(record);
        final boolean isNewComponent = determineIsComponentNew(record);

        try (var ignoredMdcComponentUuid = MDC.putCloseable(MDC_COMPONENT_UUID, scanKey.getComponentUuid());
             var ignoredMdcScanToken = MDC.putCloseable(MDC_SCAN_TOKEN, scanKey.getScanToken())) {
            maybeQueueResultProcessedEvent(scanKey, scanResult);

            processInternal(scanKey, scanResult, analysisLevel, isNewComponent);

            // NB: Dispatching asynchronously here as blocking comes with a latency penalty
            // that is too high, given the frequency at which records are processed.
            eventDispatcher.dispatchAll(eventsToDispatch.get());
        } finally {
            eventsToDispatch.get().clear();
        }
    }

    private void processInternal(final ScanKey scanKey,
                                 final ScanResult scanResult,
                                 final VulnerabilityAnalysisLevel analysisLevel,
                                 final boolean isNewComponent) {
        try (final var qm = new QueryManager()) {
            // Do not unload fields upon commit (why is this even the default WTF).
            qm.getPersistenceManager().setProperty(PROPERTY_RETAIN_VALUES, "true");
            qm.getPersistenceManager().setProperty(PROPERTY_PERSISTENCE_BY_REACHABILITY_AT_COMMIT, "false");

            final Component component = withJdbiHandle(handle -> handle.attach(Dao.class).getComponentByUuid(UUID.fromString(scanKey.getComponentUuid())));
            if (component == null) {
                LOGGER.warn("Received result for component, but it does not exist");
                return;
            }

            for (final ScannerResult scannerResult : scanResult.getScannerResultsList()) {
                processScannerResult(qm, component, scanKey, scannerResult, analysisLevel, isNewComponent);
            }
        }
    }

    private void processScannerResult(final QueryManager qm, final Component component,
                                      final ScanKey scanKey, final ScannerResult scannerResult,
                                      final VulnerabilityAnalysisLevel analysisLevel,
                                      final boolean isNewComponent) {
        if (scannerResult.getStatus() == SCAN_STATUS_FAILED) {
            final var message = "Scan of component %s with %s failed (scanKey: %s): %s"
                    .formatted(component.uuid(), scannerResult.getScanner(), prettyPrint(scanKey), scannerResult.getFailureReason());
            eventDispatcher.dispatchNotification(new Notification()
                    .scope(NotificationScope.SYSTEM)
                    .group(NotificationGroup.ANALYZER)
                    .level(NotificationLevel.ERROR)
                    .title(NotificationConstants.Title.ANALYZER_ERROR)
                    .content(message));
            LOGGER.warn(message);
            return;
        } else if (scannerResult.getStatus() != ScanStatus.SCAN_STATUS_SUCCESSFUL) {
            LOGGER.warn("Unable to process results from %s with status %s; Dropping record (scanKey: %s)"
                    .formatted(scannerResult.getScanner(), scannerResult.getStatus(), prettyPrint(scanKey)));
            return;
        }

        final Set<Vulnerability> syncedVulns = syncVulnerabilities(qm, component, scanKey, scannerResult);
        LOGGER.debug("Synchronized %d vulnerabilities reported by %s for %s (scanKey: %s)"
                .formatted(syncedVulns.size(), scannerResult.getScanner(), scanKey.getComponentUuid(), prettyPrint(scanKey)));

        final Map<UUID, VulnerabilityPolicy> matchedPoliciesByVulnUuid = maybeEvaluateVulnPolicies(component, syncedVulns);
        LOGGER.debug("Identified policy matches for %d/%d vulnerabilities (scanKey: %s)"
                .formatted(matchedPoliciesByVulnUuid.size(), syncedVulns.size(), prettyPrint(scanKey)));

        // Log the matched policies with operation mode LOG
        final List<String> loggablePolicies = matchedPoliciesByVulnUuid.entrySet().stream()
                .filter(policy -> policy.getValue().getOperationMode() == VulnerabilityPolicyOperation.LOG)
                .map(policy -> policy.getValue().getName()).toList();
        if (!loggablePolicies.isEmpty()) {
            LOGGER.info("List of matched vulnerability policies with mode LOG : " + loggablePolicies);
        }

        final Map<UUID, VulnerabilityPolicy> actionablePolicies = matchedPoliciesByVulnUuid.entrySet().stream()
                .filter(policy -> policy.getValue().getOperationMode() == VulnerabilityPolicyOperation.APPLY)
                .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));

        // Perform analysis for only actionable policies.
        final List<Vulnerability> newVulnUuids = synchronizeFindingsAndAnalyses(qm, component, syncedVulns,
                scannerResult.getScanner(), actionablePolicies);
        LOGGER.debug("Identified %d new vulnerabilities for %s with %s (scanKey: %s)"
                .formatted(newVulnUuids.size(), scanKey.getComponentUuid(), scannerResult.getScanner(), prettyPrint(scanKey)));

        maybeQueueNotifications(qm, component, isNewComponent, analysisLevel, newVulnUuids);
    }

    /**
     * Synchronize vulnerabilities reported in a given {@link ScannerResult} with the datastore.
     *
     * @param qm            The {@link QueryManager} to use
     * @param scanKey       The {@link ScanKey} associated with the {@link ScannerResult}
     * @param scannerResult The {@link ScannerResult} to synchronize vulnerabilities from
     * @return A {@link Set} of synchronized {@link Vulnerability}s
     */
    private Set<Vulnerability> syncVulnerabilities(final QueryManager qm, final Component component, final ScanKey scanKey, final ScannerResult scannerResult) {
        final var syncedVulns = new HashSet<Vulnerability>();

        if (scannerResult.getScanner() == SCANNER_SNYK && component.hasSnykVulns()) {
            // Compare component's Snyk vulnerabilities and suppress those which are longer vulnerable by SNYK.
            compareAndSuppressVulnBySnyk(qm, component, scannerResult.getBom().getVulnerabilitiesList());
        }

        for (final org.cyclonedx.proto.v1_6.Vulnerability reportedVuln : scannerResult.getBom().getVulnerabilitiesList()) {
            final Vulnerability vuln;
            try {
                vuln = convert(qm, scannerResult.getBom(), reportedVuln, true);
            } catch (RuntimeException e) {
                LOGGER.error("Failed to convert vulnerability %s/%s (reported by %s for component %s) to internal model (scanKey: %s)"
                        .formatted(reportedVuln.getSource(), reportedVuln.getId(), scannerResult.getScanner(), scanKey.getComponentUuid(), prettyPrint(scanKey)), e);
                continue;
            }

            try {
                final Vulnerability syncedVuln = syncVulnerability(qm, vuln, scannerResult.getScanner());

                // Detach vulnerabilities from JDO persistence context.
                // We do not want to trigger any DB interactions by accessing their fields later.
                // Note that even PersistenceManager#detachCopy will load / unload fields based
                // on the current FetchPlan. But we just want to keep the data we already have,
                // and #makeTransientAll does exactly that.
                qm.getPersistenceManager().makeTransient(syncedVuln);

                if (vuln.getAliases() != null && !vuln.getAliases().isEmpty()) {
                    final var syncedAliases = new ArrayList<VulnerabilityAlias>();
                    for (VulnerabilityAlias alias : vuln.getAliases()) {
                        final VulnerabilityAlias syncedAlias = qm.synchronizeVulnerabilityAlias(alias);
                        qm.getPersistenceManager().makeTransient(syncedAlias);
                        syncedAliases.add(syncedAlias);
                    }
                    syncedVuln.setAliases(syncedAliases);
                }

                syncedVulns.add(syncedVuln);
            } catch (RuntimeException e) {
                // Use a broad catch here, so we can still try to process other
                // vulnerabilities, even though processing one of them failed.

                LOGGER.warn("Failed to synchronize vulnerability %s/%s (reported by %s for component %s; scanKey: %s)"
                        .formatted(vuln.getSource(), vuln.getVulnId(), scannerResult.getScanner(), scanKey.getComponentUuid(), prettyPrint(scanKey)), e);
            }
        }
        return syncedVulns;
    }

    private void compareAndSuppressVulnBySnyk(QueryManager qm, Component component, List<org.cyclonedx.proto.v1_6.Vulnerability> vulnList) {
        final List<Long> analysisIds = inJdbiTransaction(handle -> {
            final var dao = handle.attach(Dao.class);

            final List<Long> modifiedAnalysisIds = dao.suppressSnykAnalyses(
                    component.id,
                    !vulnList.isEmpty()
                            ? vulnList.stream().map(org.cyclonedx.proto.v1_6.Vulnerability::getId).toList()
                            : null,
                    component.projectId);

            final List<AnalysisComment> analysisComments = modifiedAnalysisIds.stream()
                    .flatMap(analysisId -> Stream.of(
                            new AnalysisComment(analysisId, formatComment(AnalysisCommentField.SUPPRESSED, null, true), /* commenter */ null),
                            new AnalysisComment(analysisId, "The vulnerability is no longer reported by any analyzer.", /* commenter */ null)))
                    .toList();
            if (!analysisComments.isEmpty()) {
                dao.createAnalysisComments(analysisComments);
            }

            return modifiedAnalysisIds;
        });
        for (var analysisId : analysisIds) {
            // TODO: Use this#maybeQueueProjectAuditChangeNotification instead.
            var analysis = qm.getObjectById(org.dependencytrack.model.Analysis.class, analysisId);
            var notification = NotificationUtil.generateAnalysisNotification(qm, analysis, true, true);
            final var event = KafkaEventConverter.convert(notification);
            eventsToDispatch.get().add(event);
        }
    }

    /**
     * Synchronize a given {@link Vulnerability} as reported by a given {@link Scanner} with the datastore.
     * <p>
     * This method differs from {@link QueryManager#synchronizeVulnerability(Vulnerability, boolean)} in that it expects
     * an active {@link Transaction}, and only calls setters of existing vulnerabilities when the respective
     * value actually changed, saving network round-trips.
     *
     * @param qm      The {@link QueryManager} to use
     * @param vuln    The {@link Vulnerability} to synchronize
     * @param scanner The {@link AnalyzerIdentity} that reported the vulnerability
     * @return The synchronized {@link Vulnerability}
     * @throws IllegalStateException  When no {@link Transaction} is active
     * @throws NoSuchElementException When the reported vulnerability is internal, but does not exist in the datastore
     */
    private Vulnerability syncVulnerability(final QueryManager qm, final Vulnerability vuln, final Scanner scanner) {
        // TODO: Refactor this to use JDBI instead.
        // It is possible that the same vulnerability is reported for multiple components in parallel,
        // causing unique constraint violations when attempting to INSERT into the VULNERABILITY table.
        // In such cases, we can get away with simply retrying to SELECT or INSERT again.
        return qm.runInRetryableTransaction(() -> {
            final Vulnerability existingVuln;
            final Query<Vulnerability> query = qm.getPersistenceManager().newQuery(Vulnerability.class);
            try {
                query.setFilter("vulnId == :vulnId && source == :source");
                query.setParameters(vuln.getVulnId(), vuln.getSource());
                existingVuln = query.executeUnique();
            } finally {
                query.closeAll();
            }

            if (existingVuln == null) {
                if (Vulnerability.Source.INTERNAL.name().equals(vuln.getSource())) {
                    throw new NoSuchElementException("An internal vulnerability with ID %s does not exist".formatted(vuln.getVulnId()));
                }

                return qm.getPersistenceManager().makePersistent(vuln);
            }

            if (canUpdateVulnerability(existingVuln, scanner)) {
                final var differ = new Differ<>(existingVuln, vuln);

                // TODO: Consider using something like javers to get a rich diff of WHAT changed; https://github.com/javers/javers
                differ.applyIfChanged("title", Vulnerability::getTitle, existingVuln::setTitle);
                differ.applyIfChanged("subTitle", Vulnerability::getSubTitle, existingVuln::setSubTitle);
                differ.applyIfChanged("description", Vulnerability::getDescription, existingVuln::setDescription);
                differ.applyIfChanged("detail", Vulnerability::getDetail, existingVuln::setDetail);
                differ.applyIfChanged("recommendation", Vulnerability::getRecommendation, existingVuln::setRecommendation);
                differ.applyIfChanged("references", Vulnerability::getReferences, existingVuln::setReferences);
                differ.applyIfChanged("credits", Vulnerability::getCredits, existingVuln::setCredits);
                differ.applyIfChanged("created", Vulnerability::getCreated, existingVuln::setCreated);
                differ.applyIfChanged("published", Vulnerability::getPublished, existingVuln::setPublished);
                differ.applyIfChanged("updated", Vulnerability::getUpdated, existingVuln::setUpdated);
                differ.applyIfChanged("cwes", Vulnerability::getCwes, existingVuln::setCwes);
                differ.applyIfChanged("severity", Vulnerability::getSeverity, existingVuln::setSeverity);
                differ.applyIfChanged("cvssV2BaseScore", Vulnerability::getCvssV2BaseScore, existingVuln::setCvssV2BaseScore);
                differ.applyIfChanged("cvssV2ImpactSubScore", Vulnerability::getCvssV2ImpactSubScore, existingVuln::setCvssV2ImpactSubScore);
                differ.applyIfChanged("cvssV2ExploitabilitySubScore", Vulnerability::getCvssV2ExploitabilitySubScore, existingVuln::setCvssV2ExploitabilitySubScore);
                differ.applyIfChanged("cvssV2Vector", Vulnerability::getCvssV2Vector, existingVuln::setCvssV2Vector);
                differ.applyIfChanged("cvssv3BaseScore", Vulnerability::getCvssV3BaseScore, existingVuln::setCvssV3BaseScore);
                differ.applyIfChanged("cvssV3ImpactSubScore", Vulnerability::getCvssV3ImpactSubScore, existingVuln::setCvssV3ImpactSubScore);
                differ.applyIfChanged("cvssV3ExploitabilitySubScore", Vulnerability::getCvssV3ExploitabilitySubScore, existingVuln::setCvssV3ExploitabilitySubScore);
                differ.applyIfChanged("cvssV3Vector", Vulnerability::getCvssV3Vector, existingVuln::setCvssV3Vector);
                differ.applyIfChanged("owaspRRLikelihoodScore", Vulnerability::getOwaspRRLikelihoodScore, existingVuln::setOwaspRRLikelihoodScore);
                differ.applyIfChanged("owaspRRTechnicalImpactScore", Vulnerability::getOwaspRRTechnicalImpactScore, existingVuln::setOwaspRRTechnicalImpactScore);
                differ.applyIfChanged("owaspRRBusinessImpactScore", Vulnerability::getOwaspRRBusinessImpactScore, existingVuln::setOwaspRRBusinessImpactScore);
                differ.applyIfChanged("owaspRRVector", Vulnerability::getOwaspRRVector, existingVuln::setOwaspRRVector);
                // Aliases of existingVuln will always be null, as they'd have to be fetched separately.
                // Synchronization of aliases is performed after synchronizing the vulnerability.
                // updated |= applyIfChanged(existingVuln, vuln, Vulnerability::getAliases, existingVuln::setAliases);

                differ.applyIfChanged("vulnerableVersions", Vulnerability::getVulnerableVersions, existingVuln::setVulnerableVersions);
                differ.applyIfChanged("patchedVersions", Vulnerability::getPatchedVersions, existingVuln::setPatchedVersions);

                if (!differ.getDiffs().isEmpty()) {
                    // TODO: Send a notification?
                    //   (But notifications should only be sent if the transaction was committed)
                    LOGGER.debug("Vulnerability %s/%s was updated by %s: %s".formatted(vuln.getSource(), vuln.getVulnId(), scanner, differ.getDiffs()));
                }
            }

            return existingVuln;
        }, PersistenceUtil::isUniqueConstraintViolation);
    }

    private Map<UUID, VulnerabilityPolicy> maybeEvaluateVulnPolicies(final Component component, final Collection<Vulnerability> vulns) {
        if (vulnPolicyEvaluator == null) {
            return Collections.emptyMap();
        }

        final var policyProject = Project.newBuilder()
                .setUuid(component.projectUuid().toString())
                .build();
        final var policyComponent = org.dependencytrack.proto.policy.v1.Component.newBuilder()
                .setUuid(component.uuid().toString())
                .build();
        final List<org.dependencytrack.proto.policy.v1.Vulnerability> policyVulns = vulns.stream()
                .map(PolicyProtoMapper::mapToProto)
                .toList();

        return vulnPolicyEvaluator.evaluate(policyVulns, policyComponent, policyProject);
    }

    /**
     * Associate a given {@link Collection} of {@link Vulnerability}s with a given {@link Component},
     * evaluate applicable {@link VulnerabilityPolicy}s, and apply the resulting analyses.
     * <p>
     * If a {@link Vulnerability} was not previously associated with the {@link Component},
     * a {@link FindingAttribution} will be created for the {@link Scanner}.
     *
     * @param qm                 The {@link QueryManager} to use
     * @param component          The {@link Component} to associate with
     * @param vulns              The {@link Vulnerability}s to associate with
     * @param scanner            The {@link Scanner} that identified the association
     * @param policiesByVulnUuid Matched {@link VulnerabilityPolicy}s grouped by {@link Vulnerability#getUuid()}
     * @return A {@link List} of {@link Vulnerability}s, that were not previously associated with the {@link Component},
     * and which have not been suppressed via {@link VulnerabilityPolicy}.
     */
    private List<Vulnerability> synchronizeFindingsAndAnalyses(final QueryManager qm, final Component component,
                                                               final Collection<Vulnerability> vulns, final Scanner scanner,
                                                               final Map<UUID, VulnerabilityPolicy> policiesByVulnUuid) {
        return inJdbiTransaction(handle -> {
            final var dao = handle.attach(Dao.class);

            // Bulk-create new findings and corresponding scanner attributions.
            final List<Long> newFindingVulnIds = dao.createFindings(component, vulns);
            final List<FindingAttribution> findingAttributions = newFindingVulnIds.stream()
                    .map(vulnId -> new FindingAttribution(vulnId, component.id(), component.projectId(),
                            convert(scanner).name(), UUID.randomUUID()))
                    .toList();
            dao.createFindingAttributions(findingAttributions);

            return maybeApplyPolicyAnalyses(qm, dao, component, vulns, newFindingVulnIds, policiesByVulnUuid);
        });
    }

    /**
     * Apply analyses of matched {@link VulnerabilityPolicy}s. Do nothing when no policies matched.
     *
     * @param qm
     * @param dao                The {@link Dao} to use for persistence operations
     * @param component          The {@link Component} to apply analyses for
     * @param vulns              The {@link Vulnerability}s identified for the {@link Component}
     * @param newFindingVulnIds  IDs of {@link Vulnerability}s that newly affect the {@link Component}
     * @param policiesByVulnUuid Matched {@link VulnerabilityPolicy}s grouped by {@link Vulnerability#getUuid()}
     * @return A {@link List} of {@link Vulnerability}s, that were not previously associated with the {@link Component},
     * and which have not been suppressed via {@link VulnerabilityPolicy}.
     */
    private List<Vulnerability> maybeApplyPolicyAnalyses(QueryManager qm, final Dao dao, final Component component, final Collection<Vulnerability> vulns,
                                                         final List<Long> newFindingVulnIds, Map<UUID, VulnerabilityPolicy> policiesByVulnUuid) {
        if (vulns.isEmpty()) {
            return Collections.emptyList();
        }

        // Mark vulnerability UUIDs without policy match with an explicit "null" policy.
        policiesByVulnUuid = new HashMap<>(policiesByVulnUuid);
        for (final Vulnerability vuln : vulns) {
            if (!policiesByVulnUuid.containsKey(vuln.getUuid())) {
                policiesByVulnUuid.put(vuln.getUuid(), null);
            }
        }

        // Index vulnerabilities by ID and UUID for more efficient lookups.
        final var vulnById = new HashMap<Long, Vulnerability>();
        final var vulnByUuid = new HashMap<UUID, Vulnerability>();
        for (final Vulnerability vuln : vulns) {
            vulnById.put(vuln.getId(), vuln);
            vulnByUuid.put(vuln.getUuid(), vuln);
        }

        // For all vulnerabilities with matching policies, bulk-fetch existing analyses.
        // Index them by vulnerability UUID for more efficient access.
        final Map<UUID, Analysis> existingAnalyses = dao.getAnalyses(component, policiesByVulnUuid.keySet()).stream()
                .collect(Collectors.toMap(Analysis::getVulnUuid, Function.identity()));

        final var analysesToCreateOrUpdate = new ArrayList<Analysis>();
        final var analysisCommentsByVulnId = new MultivaluedHashMap<Long, AnalysisComment>();

        for (final Map.Entry<UUID, VulnerabilityPolicy> vulnUuidAndPolicy : policiesByVulnUuid.entrySet()) {
            final Vulnerability vuln = vulnByUuid.get(vulnUuidAndPolicy.getKey());
            final VulnerabilityPolicy policy = vulnUuidAndPolicy.getValue();
            final Analysis policyAnalysis;
            try {
                policyAnalysis = Analysis.fromPolicy(policy);
            } catch (IllegalArgumentException e) {
                LOGGER.warn("Unable to apply policy %s as it was found to be invalid".formatted(policy.getName()), e);
                continue;
            }
            final Analysis existingAnalysis = existingAnalyses.get(vuln.getUuid());
            if (policy != null && existingAnalysis == null) {
                policyAnalysis.setComponentId(component.id());
                policyAnalysis.setProjectId(component.projectId());
                policyAnalysis.setVulnId(vuln.getId());
                policyAnalysis.setVulnUuid(vuln.getUuid());

                // We'll create comments for analysisId=null for now, as the Analysis we're referring
                // to hasn't been created yet. The analysisId is populated later, after bulk upserting
                // all analyses.
                final var commentFactory = new AnalysisCommentFactory(null, policy);
                if (policyAnalysis.getState() != null) {
                    commentFactory.createComment(formatComment(AnalysisCommentField.STATE, null, policyAnalysis.getState()));
                }
                if (policyAnalysis.getJustification() != null) {
                    commentFactory.createComment(formatComment(AnalysisCommentField.JUSTIFICATION, null, policyAnalysis.getJustification()));
                }
                if (policyAnalysis.getResponse() != null) {
                    commentFactory.createComment(formatComment(AnalysisCommentField.RESPONSE, null, policyAnalysis.getResponse()));
                }
                if (policyAnalysis.getDetails() != null) {
                    commentFactory.createComment(formatComment(AnalysisCommentField.DETAILS, null, policyAnalysis.getDetails()));
                }
                if (policyAnalysis.getSuppressed()) {
                    commentFactory.createComment(formatComment(AnalysisCommentField.SUPPRESSED, null, policyAnalysis.getSuppressed()));
                }
                if (policyAnalysis.getSeverity() != null) {
                    commentFactory.createComment(formatComment(AnalysisCommentField.SEVERITY, vuln.getSeverity(), policyAnalysis.getSeverity()));
                }
                if (policyAnalysis.getCvssV2Vector() != null) {
                    commentFactory.createComment(formatComment(AnalysisCommentField.CVSSV2_VECTOR, null, policyAnalysis.getCvssV2Vector()));
                }
                if (policyAnalysis.getCvssV2Score() != null) {
                    commentFactory.createComment(formatComment(AnalysisCommentField.CVSSV2_SCORE, null, policyAnalysis.getCvssV2Score()));
                }
                if (policyAnalysis.getCvssV3Vector() != null) {
                    commentFactory.createComment(formatComment(AnalysisCommentField.CVSSV3_VECTOR, null, policyAnalysis.getCvssV3Vector()));
                }
                if (policyAnalysis.getCvssV3Score() != null) {
                    commentFactory.createComment(formatComment(AnalysisCommentField.CVSSV3_SCORE, null, policyAnalysis.getCvssV3Score()));
                }
                if (policyAnalysis.getOwaspVector() != null) {
                    commentFactory.createComment(formatComment(AnalysisCommentField.OWASP_VECTOR, null, policyAnalysis.getOwaspVector()));
                }
                if (policyAnalysis.getOwaspScore() != null) {
                    commentFactory.createComment(formatComment(AnalysisCommentField.OWASP_SCORE, null, policyAnalysis.getOwaspScore()));
                }
                analysesToCreateOrUpdate.add(policyAnalysis);
                analysisCommentsByVulnId.addAll(policyAnalysis.getVulnId(), commentFactory.getComments());
            } else if (existingAnalysis != null && (policy != null || existingAnalysis.getVulnPolicyName() != null)) {
                boolean shouldUpdate = false;
                boolean analysisStateChange = false;
                boolean suppressionChange = false;
                final var commentFactory = new AnalysisCommentFactory(existingAnalysis.getId(), policy);
                if (!Objects.equals(existingAnalysis.getState(), policyAnalysis.getState())) {
                    commentFactory.createComment(formatComment(AnalysisCommentField.STATE,
                            existingAnalysis.getState(), policyAnalysis.getState()));

                    existingAnalysis.setState(policyAnalysis.getState());
                    shouldUpdate = true;
                    analysisStateChange = true;
                }
                if (!Objects.equals(existingAnalysis.getJustification(), policyAnalysis.getJustification())) {
                    commentFactory.createComment(formatComment(AnalysisCommentField.JUSTIFICATION,
                            existingAnalysis.getJustification(), policyAnalysis.getJustification()));

                    existingAnalysis.setJustification(policyAnalysis.getJustification());
                    shouldUpdate = true;
                }
                if (!Objects.equals(existingAnalysis.getResponse(), policyAnalysis.getResponse())) {
                    commentFactory.createComment(formatComment(AnalysisCommentField.RESPONSE,
                            existingAnalysis.getResponse(), policyAnalysis.getResponse()));

                    existingAnalysis.setResponse(policyAnalysis.getResponse());
                    shouldUpdate = true;
                }
                if (!Objects.equals(existingAnalysis.details, policyAnalysis.getDetails())) {
                    commentFactory.createComment(formatComment(AnalysisCommentField.DETAILS,
                            existingAnalysis.getDetails(), policyAnalysis.getDetails()));

                    existingAnalysis.setDetails(policyAnalysis.getDetails());
                    shouldUpdate = true;
                }
                if (existingAnalysis.getSuppressed() == null || (existingAnalysis.getSuppressed() != policyAnalysis.getSuppressed())) {
                    commentFactory.createComment(formatComment(AnalysisCommentField.SUPPRESSED,
                            existingAnalysis.getSuppressed(), policyAnalysis.getSuppressed()));

                    existingAnalysis.setSuppressed(policyAnalysis.getSuppressed());
                    shouldUpdate = true;
                    suppressionChange = true;
                }
                if (!Objects.equals(existingAnalysis.getSeverity(), policyAnalysis.getSeverity())) {
                    commentFactory.createComment(formatComment(AnalysisCommentField.SEVERITY,
                            existingAnalysis.getSeverity(), policyAnalysis.getSeverity()));

                    existingAnalysis.setSeverity(policyAnalysis.getSeverity());
                    shouldUpdate = true;
                }
                if (!Objects.equals(existingAnalysis.getCvssV2Vector(), policyAnalysis.getCvssV2Vector())) {
                    commentFactory.createComment(formatComment(AnalysisCommentField.CVSSV2_VECTOR,
                            existingAnalysis.getCvssV2Vector(), policyAnalysis.getCvssV2Vector()));

                    existingAnalysis.setCvssV2Vector(policyAnalysis.getCvssV2Vector());
                    shouldUpdate = true;
                }
                if (!Objects.equals(existingAnalysis.getCvssV2Score(), policyAnalysis.getCvssV2Score())) {
                    commentFactory.createComment(formatComment(AnalysisCommentField.CVSSV2_SCORE,
                            existingAnalysis.getCvssV2Score(), policyAnalysis.getCvssV2Score()));

                    existingAnalysis.setCvssV2Score(policyAnalysis.getCvssV2Score());
                    shouldUpdate = true;
                }
                if (!Objects.equals(existingAnalysis.getCvssV3Vector(), policyAnalysis.getCvssV3Vector())) {
                    commentFactory.createComment(formatComment(AnalysisCommentField.CVSSV3_VECTOR,
                            existingAnalysis.getCvssV3Vector(), policyAnalysis.getCvssV3Vector()));

                    existingAnalysis.setCvssV3Vector(policyAnalysis.getCvssV3Vector());
                    shouldUpdate = true;
                }
                if (!Objects.equals(existingAnalysis.getCvssV3Score(), policyAnalysis.getCvssV3Score())) {
                    commentFactory.createComment(formatComment(AnalysisCommentField.CVSSV3_SCORE,
                            existingAnalysis.getCvssV3Score(), policyAnalysis.getCvssV3Score()));

                    existingAnalysis.setCvssV3Score(policyAnalysis.getCvssV3Score());
                    shouldUpdate = true;
                }
                if (!Objects.equals(existingAnalysis.getOwaspVector(), policyAnalysis.getOwaspVector())) {
                    commentFactory.createComment(formatComment(AnalysisCommentField.OWASP_VECTOR,
                            existingAnalysis.getOwaspVector(), policyAnalysis.getOwaspVector()));

                    existingAnalysis.setOwaspVector(policyAnalysis.getCvssV2Vector());
                    shouldUpdate = true;
                }
                if (!Objects.equals(existingAnalysis.getOwaspScore(), policyAnalysis.getOwaspScore())) {
                    commentFactory.createComment(formatComment(AnalysisCommentField.OWASP_SCORE,
                            existingAnalysis.getOwaspScore(), policyAnalysis.getOwaspScore()));

                    existingAnalysis.setOwaspScore(policyAnalysis.getOwaspScore());
                    shouldUpdate = true;
                }
                if (shouldUpdate) {
                    existingAnalysis.setVulnPolicyName(policy != null ? policy.getName() : null);
                    analysesToCreateOrUpdate.add(existingAnalysis);
                    analysisCommentsByVulnId.addAll(existingAnalysis.getVulnId(), commentFactory.getComments());
                    maybeQueueProjectAuditChangeNotification(qm, component, vuln, existingAnalysis, analysisStateChange, suppressionChange);
                }
            }

            // If the finding was suppressed, do not report it as new.
            if (Boolean.TRUE.equals(policyAnalysis.getSuppressed())) {
                newFindingVulnIds.remove(vuln.getId());
            }
        }

        if (!analysesToCreateOrUpdate.isEmpty()) {
            final List<CreatedAnalysis> createdAnalyses = dao.createOrUpdateAnalyses(analysesToCreateOrUpdate);
            // Comments for new analyses do not have an analysis ID set yet, as that ID was not known prior
            // to inserting the respective analysis record. Enrich comments with analysis IDs now that we know them.
            for (final CreatedAnalysis createdAnalysis : createdAnalyses) {
                analysisCommentsByVulnId.computeIfPresent(createdAnalysis.vulnId(),
                        (vulnId, comments) -> comments.stream()
                                .map(comment -> new AnalysisComment(createdAnalysis.id(), comment.comment(), comment.commenter()))
                                .toList());
            }
            dao.createAnalysisComments(analysisCommentsByVulnId.values().stream().flatMap(Collection::stream).toList());
        }

        return vulnById.entrySet().stream()
                .filter(entry -> newFindingVulnIds.contains(entry.getKey()))
                .map(Map.Entry::getValue)
                .toList();
    }

    private void maybeQueueProjectAuditChangeNotification(final QueryManager qm, final Component component,
                                                          final Vulnerability vuln, final Analysis policyAnalysis,
                                                          final boolean analysisStateChange, final boolean suppressionChange) {
        if (!analysisStateChange && !suppressionChange) {
            return;
        }

        withJdbiHandle(handle -> handle.attach(NotificationSubjectDao.class).getForProjectAuditChange(component.uuid(), vuln.getUuid(), policyAnalysis.state, policyAnalysis.suppressed))
                .map(subject -> org.dependencytrack.proto.notification.v1.Notification.newBuilder()
                        .setScope(SCOPE_PORTFOLIO)
                        .setGroup(GROUP_PROJECT_AUDIT_CHANGE)
                        .setLevel(LEVEL_INFORMATIONAL)
                        .setTimestamp(Timestamps.now())
                        .setTitle(generateTitle(policyAnalysis.getState(), policyAnalysis.getSuppressed(), analysisStateChange, suppressionChange))
                        .setContent("An analysis decision was made to a finding affecting a project")
                        .setSubject(Any.pack(subject))
                        .build())
                .map(KafkaEventConverter::convert)
                .ifPresent(eventsToDispatch.get()::add);
    }

    private void maybeQueueResultProcessedEvent(final ScanKey scanKey, final ScanResult scanResult) {
        // Vulnerability scans targeting the entire portfolio are currently not tracked.
        // There's no point in including results in the following repartition, and querying
        // the database for their scan token, given the queries will never return anything anyway.
        // Filtering results of portfolio analyses here also reduces the chance of hot partitions.
        if (PortfolioVulnerabilityAnalysisEvent.CHAIN_IDENTIFIER.toString().equals(scanKey.getScanToken())) {
            return;
        }

        // Drop vulnerabilities from scanner results, as they can be rather large, and we don't need them anymore.
        // Dropping them will save us some compression and network overhead during the repartition.
        // We can remove this step should we ever need access to the vulnerabilities again.
        final ScanResult strippedScanResult = scanResult.toBuilder()
                .clearScannerResults()
                .addAllScannerResults(scanResult.getScannerResultsList().stream()
                        .map(scannerResult -> scannerResult.toBuilder()
                                .clearBom()
                                .build())
                        .toList())
                .build();

        final var event = new KafkaEvent<>(KafkaTopics.VULN_ANALYSIS_RESULT_PROCESSED, scanKey.getScanToken(), strippedScanResult);
        eventsToDispatch.get().add(event);
    }

    /**
     * Send {@link Group#GROUP_NEW_VULNERABLE_DEPENDENCY} and {@link Group#GROUP_NEW_VULNERABILITY} notifications
     * for a given {@link Component}, <em>if it was found to have at least one non-suppressed vulnerability</em>.
     *
     * @param qm             The {@link QueryManager} to use
     * @param component      The {@link Component} to send notifications for
     * @param isNewComponent Whether {@code component} is new
     * @param analysisLevel  The {@link VulnerabilityAnalysisLevel}
     * @param newVulns       Newly identified {@link Vulnerability}s
     */
    private void maybeQueueNotifications(final QueryManager qm, final Component component, final boolean isNewComponent,
                                         final VulnerabilityAnalysisLevel analysisLevel, final List<Vulnerability> newVulns) {
        if (newVulns.isEmpty()) {
            return;
        }

        final Timestamp notificationTimestamp = Timestamps.now();
        useJdbiHandle(handle -> {
            final var dao = handle.attach(NotificationSubjectDao.class);

            if (isNewComponent) {
                dao.getForNewVulnerableDependency(component.uuid())
                        .map(subject -> org.dependencytrack.proto.notification.v1.Notification.newBuilder()
                                .setScope(SCOPE_PORTFOLIO)
                                .setGroup(GROUP_NEW_VULNERABLE_DEPENDENCY)
                                .setLevel(LEVEL_INFORMATIONAL)
                                .setTimestamp(notificationTimestamp)
                                .setTitle(generateNotificationTitle(NotificationConstants.Title.NEW_VULNERABLE_DEPENDENCY, subject.getProject()))
                                .setContent(generateNotificationContent(subject.getComponent(), subject.getVulnerabilitiesList()))
                                .setSubject(Any.pack(subject))
                                .build())
                        .map(KafkaEventConverter::convert)
                        .ifPresent(eventsToDispatch.get()::add);
            }

            dao.getForNewVulnerabilities(component.uuid(), newVulns.stream().map(Vulnerability::getUuid).toList(), analysisLevel).stream()
                    .map(subject -> org.dependencytrack.proto.notification.v1.Notification.newBuilder()
                            .setScope(SCOPE_PORTFOLIO)
                            .setGroup(GROUP_NEW_VULNERABILITY)
                            .setLevel(LEVEL_INFORMATIONAL)
                            .setTimestamp(notificationTimestamp)
                            .setTitle(generateNotificationTitle(NotificationConstants.Title.NEW_VULNERABILITY, subject.getProject()))
                            .setContent(generateNotificationContent(subject.getVulnerability()))
                            .setSubject(Any.pack(subject))
                            .build())
                    .map(KafkaEventConverter::convert)
                    .forEach(eventsToDispatch.get()::add);
        });
    }

    private boolean canUpdateVulnerability(final Vulnerability vuln, final Scanner scanner) {
        var canUpdate = true;

        // Results from the internal scanner only contain vulnId and source, nothing else.
        // As they only refer to existing vulnerabilities in the database, no update must be performed.
        canUpdate &= scanner != SCANNER_INTERNAL;

        // Internal vulnerabilities can only be updated via REST API.
        canUpdate &= !Vulnerability.Source.INTERNAL.name().equals(vuln.getSource());

        // If the scanner is also the authoritative source of the given vulnerability,
        // it should be able to update it. This will be the case for the OSS Index scanner
        // and sonatype-XXX vulnerabilities for example.
        canUpdate &= isAuthoritativeSource(vuln, convert(scanner))
                     // Alternatively, if the vulnerability could be mirrored, but mirroring
                     // is disabled, it is OK to override any existing data.
                     //
                     // Ideally, we'd track the data from all sources instead of just overriding
                     // it, but for now this will have to do it.
                     || (canBeMirrored(vuln) && !isMirroringEnabled(vuln));

        return canUpdate;
    }

    private static VulnerabilityAnalysisLevel determineAnalysisLevel(final ConsumerRecord<?, ?> record) {
        return KafkaUtil.getEventHeader(record.headers(), KafkaEventHeaders.VULN_ANALYSIS_LEVEL)
                .map(value -> {
                    try {
                        return VulnerabilityAnalysisLevel.valueOf(value);
                    } catch (IllegalArgumentException e) {
                        LOGGER.warn("The reported analysis type %s is invalid, assuming %s"
                                .formatted(value, VulnerabilityAnalysisLevel.PERIODIC_ANALYSIS));
                        return VulnerabilityAnalysisLevel.PERIODIC_ANALYSIS;
                    }
                })
                .orElse(VulnerabilityAnalysisLevel.PERIODIC_ANALYSIS);
    }

    private static boolean determineIsComponentNew(final ConsumerRecord<?, ?> record) {
        return KafkaUtil.getEventHeader(record.headers(), KafkaEventHeaders.IS_NEW_COMPONENT)
                .map(Boolean::parseBoolean)
                .orElse(false);
    }

    private static String prettyPrint(final ScanKey scanKey) {
        return "%s/%s".formatted(scanKey.getScanToken(), scanKey.getComponentUuid());
    }

    public interface Dao {

        @SqlQuery("""
                SELECT
                  "C"."ID"   AS "id",
                  "C"."UUID" AS "uuid",
                  "P"."ID"   AS "projectId",
                  "P"."UUID" AS "projectUuid",
                   (SELECT EXISTS(SELECT 1
                        FROM "COMPONENTS_VULNERABILITIES" AS "CV"
                    INNER JOIN "VULNERABILITY" AS "V"
                        ON "V"."ID" = "CV"."VULNERABILITY_ID"
                    WHERE "CV"."COMPONENT_ID" = "C"."ID"
                        AND "V"."SOURCE" = 'SNYK')) AS "hasSnykVulns"
                FROM
                  "COMPONENT" AS "C"
                INNER JOIN
                  "PROJECT" AS "P" ON "P"."ID" = "C"."PROJECT_ID"
                WHERE
                  "C"."UUID" = :uuid
                """)
        @RegisterConstructorMapper(Component.class)
        Component getComponentByUuid(final UUID uuid);

        @SqlBatch("""
                INSERT INTO "COMPONENTS_VULNERABILITIES"
                  ("COMPONENT_ID", "VULNERABILITY_ID")
                VALUES
                  (:component.id, :vuln.id)
                ON CONFLICT DO NOTHING
                RETURNING "VULNERABILITY_ID"
                """)
        @GetGeneratedKeys("VULNERABILITY_ID")
        List<Long> createFindings(@BindMethods("component") final Component component, @BindBean("vuln") final Iterable<Vulnerability> vuln);

        @SqlBatch("""
                INSERT INTO "FINDINGATTRIBUTION"
                  ("VULNERABILITY_ID", "COMPONENT_ID", "PROJECT_ID", "ANALYZERIDENTITY", "ATTRIBUTED_ON", "UUID")
                VALUES
                  (:vulnId, :componentId, :projectId, :analyzer, NOW(), :uuid)
                ON CONFLICT ("VULNERABILITY_ID", "COMPONENT_ID") DO NOTHING
                """)
        void createFindingAttributions(@BindMethods final Iterable<FindingAttribution> attribution);

        @SqlQuery("""
                SELECT
                  "V"."ID"            AS "vulnId",
                  "V"."UUID"          AS "vulnUuid",
                  "A"."ID"            AS "id",
                  "A"."COMPONENT_ID"  AS "componentId",
                  "A"."PROJECT_ID"    AS "projectId",
                  "A"."STATE"         AS "state",
                  "A"."JUSTIFICATION" AS "justification",
                  "A"."RESPONSE"      AS "response",
                  "A"."DETAILS"       AS "details",
                  "A"."SUPPRESSED"    AS "suppressed",
                  "A"."SEVERITY"      AS "severity",
                  "A"."CVSSV2VECTOR"  AS "cvssV2Vector",
                  "A"."CVSSV2SCORE"   AS "cvssV2Score",
                  "A"."CVSSV3VECTOR"  AS "cvssV3Vector",
                  "A"."CVSSV3SCORE"   AS "cvssV3Score",
                  "A"."OWASPVECTOR"   AS "owaspVector",
                  "A"."OWASPSCORE"    AS "owaspScore",
                  "VP"."NAME"         AS "vulnPolicyName"
                FROM
                  "VULNERABILITY" AS "V"
                INNER JOIN
                  "ANALYSIS" AS "A" ON "A"."VULNERABILITY_ID" = "V"."ID"
                LEFT JOIN
                  "VULNERABILITY_POLICY" AS "VP" ON "VP"."ID" = "A"."VULNERABILITY_POLICY_ID"
                WHERE
                  "A"."COMPONENT_ID" = :component.id
                  AND "V"."UUID" = ANY(:vulnUuids)
                """)
        @RegisterBeanMapper(Analysis.class)
        List<Analysis> getAnalyses(@BindMethods("component") final Component component, final Iterable<UUID> vulnUuids);

        @SqlBatch("""
                WITH "CTE_VULN_POLICY" AS (
                  SELECT
                    "ID"
                  FROM
                    "VULNERABILITY_POLICY"
                  WHERE
                    "NAME" = :vulnPolicyName
                )
                INSERT INTO "ANALYSIS"
                  ("VULNERABILITY_ID", "COMPONENT_ID", "PROJECT_ID", "STATE", "JUSTIFICATION", "RESPONSE", "DETAILS",
                   "SUPPRESSED", "SEVERITY", "CVSSV2VECTOR", "CVSSV2SCORE", "CVSSV3VECTOR", "CVSSV3SCORE", "OWASPVECTOR",
                   "OWASPSCORE", "VULNERABILITY_POLICY_ID")
                VALUES
                  (:vulnId, :componentId, :projectId, :state, :justification, :response, :details, :suppressed,
                   :severity, :cvssV2Vector, :cvssV2Score, :cvssV3Vector, :cvssV3Score, :owaspVector, :owaspScore,
                   (SELECT "ID" FROM "CTE_VULN_POLICY"))
                ON CONFLICT ("VULNERABILITY_ID", "COMPONENT_ID", "PROJECT_ID") DO UPDATE
                  SET
                    "STATE"         = :state,
                    "JUSTIFICATION" = :justification,
                    "RESPONSE"      = :response,
                    "DETAILS"       = :details,
                    "SUPPRESSED"    = :suppressed,
                    "SEVERITY"      = :severity,
                    "CVSSV2VECTOR"  = :cvssV2Vector,
                    "CVSSV2SCORE"   = :cvssV2Score,
                    "CVSSV3VECTOR"  = :cvssV3Vector,
                    "CVSSV3SCORE"   = :cvssV3Score,
                    "OWASPVECTOR"   = :owaspVector,
                    "OWASPSCORE"    = :owaspScore,
                    "VULNERABILITY_POLICY_ID" = (SELECT "ID" FROM "CTE_VULN_POLICY")
                RETURNING "ID", "VULNERABILITY_ID"
                """)
        @GetGeneratedKeys({"ID", "VULNERABILITY_ID"})
        @RegisterConstructorMapper(CreatedAnalysis.class)
        List<CreatedAnalysis> createOrUpdateAnalyses(@BindBean final Iterable<Analysis> analysis);

        @SqlBatch("""
                INSERT INTO "ANALYSISCOMMENT"
                  ("ANALYSIS_ID", "TIMESTAMP", "COMMENT", "COMMENTER")
                VALUES
                  (:analysisId, NOW(), :comment, :commenter)
                """)
        void createAnalysisComments(@BindMethods final Iterable<AnalysisComment> comment);

        @SqlQuery("""
                 -- Find the IDs of all Snyk vulns currently assigned to the component,
                 -- that are not suppressed or have no analysis at all,
                 -- and are not excluded by vulnIdsToExclude.
                 WITH "CTE_VULNERABILITY" AS (
                   SELECT "V"."ID"
                     FROM "VULNERABILITY" AS "V"
                    INNER JOIN "COMPONENTS_VULNERABILITIES" AS "CV"
                       ON "CV"."VULNERABILITY_ID" = "V"."ID"
                     LEFT JOIN "ANALYSIS" AS "A"
                       ON "A"."COMPONENT_ID" = "CV"."COMPONENT_ID"
                      AND "A"."VULNERABILITY_ID" = "CV"."VULNERABILITY_ID"
                    WHERE "CV"."COMPONENT_ID" = :componentId
                      AND "V"."SOURCE" = 'SNYK'
                      AND ("A"."SUPPRESSED" IS NULL OR NOT "A"."SUPPRESSED")
                     <#if vulnIdsToExclude>
                       AND "V"."VULNID" != ALL(:vulnIdsToExclude)
                     </#if>
                 )
                 -- Try to create suppression analyses for all Snyk vulns identified above.
                 INSERT INTO "ANALYSIS" ("COMPONENT_ID", "PROJECT_ID", "VULNERABILITY_ID", "SUPPRESSED", "STATE")
                 SELECT :componentId AS "COMPONENT_ID"
                      , :projectId AS "PROJECT_ID"
                      , "CTE_VULNERABILITY"."ID" AS "VULNERABILITY_ID"
                      , TRUE AS "SUPPRESSED"
                      , 'FALSE_POSITIVE' AS "STATE"
                 FROM "CTE_VULNERABILITY"
                 -- Update existing record if not already suppressed.
                 ON CONFLICT ("PROJECT_ID", "COMPONENT_ID", "VULNERABILITY_ID")
                 DO UPDATE SET "SUPPRESSED" = TRUE, "STATE" = 'FALSE_POSITIVE'
                 RETURNING "ID"
            """)
        @DefineNamedBindings
        @RegisterBeanMapper(org.dependencytrack.model.Analysis.class)
        List<Long> suppressSnykAnalyses(@Bind final long componentId, @Bind final List<String> vulnIdsToExclude, @Bind final long projectId);
    }

    public static class Analysis {

        private long id;
        private long componentId;
        private long projectId;
        private long vulnId;
        private UUID vulnUuid;
        private String vulnPolicyName;
        private AnalysisState state;
        private AnalysisJustification justification;
        private AnalysisResponse response;
        private String details;
        private Boolean suppressed;
        private Severity severity;
        private String cvssV2Vector;
        private Double cvssV2Score;
        private String cvssV3Vector;
        private Double cvssV3Score;
        private String owaspVector;
        private Double owaspScore;

        private static Analysis fromPolicy(final VulnerabilityPolicy policy) {
            final var analysis = new Analysis();
            if (policy == null) {
                analysis.setState(AnalysisState.NOT_SET);
                analysis.setSuppressed(false);
                return analysis;
            }

            analysis.setVulnPolicyName(policy.getName());
            if (policy.getAnalysis().getState() != null) {
                analysis.setState(switch (policy.getAnalysis().getState()) {
                    case EXPLOITABLE -> AnalysisState.EXPLOITABLE;
                    case FALSE_POSITIVE -> AnalysisState.FALSE_POSITIVE;
                    case IN_TRIAGE -> AnalysisState.IN_TRIAGE;
                    case NOT_AFFECTED -> AnalysisState.NOT_AFFECTED;
                    case RESOLVED -> AnalysisState.RESOLVED;
                });
            } else {
                throw new IllegalArgumentException("Analysis of policy does not define a state");
            }
            if (policy.getAnalysis().getJustification() != null) {
                analysis.setJustification(switch (policy.getAnalysis().getJustification()) {
                    case CODE_NOT_PRESENT -> AnalysisJustification.CODE_NOT_PRESENT;
                    case CODE_NOT_REACHABLE -> AnalysisJustification.CODE_NOT_REACHABLE;
                    case PROTECTED_AT_PERIMETER -> AnalysisJustification.PROTECTED_AT_PERIMETER;
                    case PROTECTED_AT_RUNTIME -> AnalysisJustification.PROTECTED_AT_RUNTIME;
                    case PROTECTED_BY_COMPILER -> AnalysisJustification.PROTECTED_BY_COMPILER;
                    case PROTECTED_BY_MITIGATING_CONTROL -> AnalysisJustification.PROTECTED_BY_MITIGATING_CONTROL;
                    case REQUIRES_CONFIGURATION -> AnalysisJustification.REQUIRES_CONFIGURATION;
                    case REQUIRES_DEPENDENCY -> AnalysisJustification.REQUIRES_DEPENDENCY;
                    case REQUIRES_ENVIRONMENT -> AnalysisJustification.REQUIRES_ENVIRONMENT;
                });
            }
            if (policy.getAnalysis().getVendorResponse() != null) {
                analysis.setResponse(switch (policy.getAnalysis().getVendorResponse()) {
                    case CAN_NOT_FIX -> AnalysisResponse.CAN_NOT_FIX;
                    case ROLLBACK -> AnalysisResponse.ROLLBACK;
                    case UPDATE -> AnalysisResponse.UPDATE;
                    case WILL_NOT_FIX -> AnalysisResponse.WILL_NOT_FIX;
                    case WORKAROUND_AVAILABLE -> AnalysisResponse.WORKAROUND_AVAILABLE;
                });
            }
            if (policy.getAnalysis().getDetails() != null) {
                analysis.setDetails(policy.getAnalysis().getDetails());
            }
            analysis.setSuppressed(policy.getAnalysis().isSuppress());

            if (policy.getRatings() != null && !policy.getRatings().isEmpty()) {
                if (policy.getRatings().size() > 3) {
                    throw new IllegalArgumentException("Policy defines more than three ratings");
                }

                final var methodsSeen = new HashSet<VulnerabilityPolicyRating.Method>();
                for (final VulnerabilityPolicyRating policyRating : policy.getRatings()) {
                    if (policyRating.getMethod() == null) {
                        throw new IllegalArgumentException("Rating #%d does not define a method"
                                .formatted(policy.getRatings().indexOf(policyRating)));
                    }
                    if (!methodsSeen.add(policyRating.getMethod())) {
                        throw new IllegalArgumentException("Rating method %s is defined more than once"
                                .formatted(policyRating.getMethod()));
                    }
                    if (policyRating.getSeverity() == null) {
                        throw new IllegalArgumentException("Rating #%d (%s) does not define a severity"
                                .formatted(policy.getRatings().indexOf(policyRating), policyRating.getMethod()));
                    }

                    analysis.setSeverity(switch (policyRating.getSeverity()) {
                        case INFO -> Severity.INFO;
                        case LOW -> Severity.LOW;
                        case MEDIUM -> Severity.MEDIUM;
                        case HIGH -> Severity.HIGH;
                        case CRITICAL -> Severity.CRITICAL;
                    });
                    switch (policyRating.getMethod()) {
                        case CVSSV2 -> {
                            analysis.setCvssV2Vector(policyRating.getVector());
                            analysis.setCvssV2Score(policyRating.getScore());
                        }
                        case CVSSV3 -> {
                            analysis.setCvssV3Vector(policyRating.getVector());
                            analysis.setCvssV3Score(policyRating.getScore());
                        }
                        case OWASP -> {
                            analysis.setOwaspVector(policyRating.getVector());
                            analysis.setOwaspScore(policyRating.getScore());
                        }
                    }
                }
            }

            return analysis;
        }

        public long getId() {
            return id;
        }

        public void setId(final long id) {
            this.id = id;
        }

        public long getComponentId() {
            return componentId;
        }

        public void setComponentId(final long componentId) {
            this.componentId = componentId;
        }

        public long getProjectId() {
            return projectId;
        }

        public void setProjectId(final long projectId) {
            this.projectId = projectId;
        }

        public long getVulnId() {
            return vulnId;
        }

        public void setVulnId(final long vulnId) {
            this.vulnId = vulnId;
        }

        public UUID getVulnUuid() {
            return vulnUuid;
        }

        public void setVulnUuid(final UUID vulnUuid) {
            this.vulnUuid = vulnUuid;
        }

        public String getVulnPolicyName() {
            return vulnPolicyName;
        }

        public void setVulnPolicyName(final String vulnPolicyName) {
            this.vulnPolicyName = vulnPolicyName;
        }

        public AnalysisState getState() {
            return state;
        }

        public void setState(final AnalysisState state) {
            this.state = state;
        }

        public AnalysisJustification getJustification() {
            return justification;
        }

        public void setJustification(final AnalysisJustification justification) {
            this.justification = justification;
        }

        public AnalysisResponse getResponse() {
            return response;
        }

        public void setResponse(final AnalysisResponse response) {
            this.response = response;
        }

        public String getDetails() {
            return details;
        }

        public void setDetails(final String details) {
            this.details = details;
        }

        public Boolean getSuppressed() {
            return suppressed;
        }

        public void setSuppressed(final Boolean suppressed) {
            this.suppressed = suppressed;
        }

        public Severity getSeverity() {
            return severity;
        }

        public void setSeverity(final Severity severity) {
            this.severity = severity;
        }

        public String getCvssV2Vector() {
            return cvssV2Vector;
        }

        public void setCvssV2Vector(final String cvssV2Vector) {
            this.cvssV2Vector = cvssV2Vector;
        }

        public Double getCvssV2Score() {
            return cvssV2Score;
        }

        public void setCvssV2Score(final Double cvssV2Score) {
            this.cvssV2Score = cvssV2Score;
        }

        public String getCvssV3Vector() {
            return cvssV3Vector;
        }

        public void setCvssV3Vector(final String cvssV3Vector) {
            this.cvssV3Vector = cvssV3Vector;
        }

        public Double getCvssV3Score() {
            return cvssV3Score;
        }

        public void setCvssV3Score(final Double cvssV3Score) {
            this.cvssV3Score = cvssV3Score;
        }

        public String getOwaspVector() {
            return owaspVector;
        }

        public void setOwaspVector(final String owaspVector) {
            this.owaspVector = owaspVector;
        }

        public Double getOwaspScore() {
            return owaspScore;
        }

        public void setOwaspScore(final Double owaspScore) {
            this.owaspScore = owaspScore;
        }

    }

    public record CreatedAnalysis(long id, @ColumnName("VULNERABILITY_ID") long vulnId) {
    }

    public record AnalysisComment(Long analysisId, String comment, String commenter) {
    }

    private static final class AnalysisCommentFactory {

        private final Long analysisId;
        private final VulnerabilityPolicy policy;
        private final String commenter;
        private final List<AnalysisComment> comments;

        private AnalysisCommentFactory(final Long analysisId, VulnerabilityPolicy policy) {
            this.analysisId = analysisId;
            this.policy = policy;
            this.commenter = createCommenter(policy);
            this.comments = new ArrayList<>();
        }

        private void createComment(final String comment) {
            comments.add(new AnalysisComment(this.analysisId, comment, this.commenter));
        }

        private List<AnalysisComment> getComments() {
            if (comments.isEmpty()) {
                return comments;
            }

            // If we have comments already, additionally include what the policy matched on.
            // Include this as the very first comment, and do not modify the original list.
            final var commentsCopy = new ArrayList<AnalysisComment>();
            if (policy == null) {
                commentsCopy.add(new AnalysisComment(this.analysisId, "No longer covered by any policy", this.commenter));
            } else {
                commentsCopy.add(new AnalysisComment(this.analysisId, "Matched on condition(s):\n%s"
                        .formatted(policy.getConditions().stream().map("- %s"::formatted).collect(Collectors.joining("\n"))), this.commenter));
            }
            commentsCopy.addAll(comments);
            return commentsCopy;
        }

        private static String createCommenter(final VulnerabilityPolicy policy) {
            if (policy == null) {
                return "[Policy{None}]";
            }

            if (isNotBlank(policy.getAuthor())) {
                return "[Policy{Name=%s, Author=%s}]".formatted(policy.getName(), policy.getAuthor());
            }

            return "[Policy{Name=%s}]".formatted(policy.getName());
        }

    }

    public record Component(long id, UUID uuid, long projectId, UUID projectUuid, boolean hasSnykVulns) {
    }

    public record FindingAttribution(long vulnId, long componentId, long projectId, String analyzer, UUID uuid) {
    }
}
