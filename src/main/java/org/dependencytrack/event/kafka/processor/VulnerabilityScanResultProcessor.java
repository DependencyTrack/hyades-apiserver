package org.dependencytrack.event.kafka.processor;

import alpine.common.logging.Logger;
import org.apache.commons.lang3.exception.ExceptionUtils;
import org.apache.kafka.streams.processor.api.ContextualFixedKeyProcessor;
import org.apache.kafka.streams.processor.api.ContextualProcessor;
import org.apache.kafka.streams.processor.api.FixedKeyRecord;
import org.dependencytrack.model.AnalyzerIdentity;
import org.dependencytrack.model.Component;
import org.dependencytrack.model.FindingAttribution;
import org.dependencytrack.model.Vulnerability;
import org.dependencytrack.parser.hyades.ModelConverter;
import org.dependencytrack.persistence.QueryManager;
import org.hyades.proto.vulnanalysis.v1.ScanResult;
import org.hyades.proto.vulnanalysis.v1.ScanStatus;
import org.hyades.proto.vulnanalysis.v1.Scanner;
import org.postgresql.util.PSQLState;

import javax.jdo.JDODataStoreException;
import javax.jdo.PersistenceManager;
import javax.jdo.Query;
import javax.jdo.Transaction;
import java.sql.SQLException;
import java.util.Optional;
import java.util.UUID;

/**
 * A {@link ContextualProcessor} responsible for processing {@link ScanResult}s.
 * <p>
 * {@link ScanResult}s with status {@link ScanStatus#SCAN_STATUS_COMPLETE} will be forwarded,
 * results of any other status will be dropped after processing.
 */
public class VulnerabilityScanResultProcessor extends ContextualFixedKeyProcessor<UUID, ScanResult, ScanResult> {

    private static final Logger LOGGER = Logger.getLogger(VulnerabilityScanResultProcessor.class);

    @Override
    public void process(final FixedKeyRecord<UUID, ScanResult> record) {
        final UUID componentUuid = record.key();
        final ScanResult result = record.value();

        if (result.getStatus() == ScanStatus.SCAN_STATUS_COMPLETE) {
            context().forward(record);
            return;
        } else if (result.getStatus() == ScanStatus.SCAN_STATUS_FAILED) {
            LOGGER.warn("Scan of component %s (token: %s) with %s failed: %s"
                    .formatted(componentUuid, result.getKey().getScanToken(), result.getScanner(), result.getFailureReason()));
            return;
        } else if (result.getStatus() != ScanStatus.SCAN_STATUS_SUCCESSFUL) {
            LOGGER.warn("Unable to process results with status %s; Dropping record for component %s (token: %s)"
                    .formatted(result.getStatus(), componentUuid, result.getKey().getScanToken()));
            return;
        }

        if (result.getVulnerabilitiesCount() == 0) {
            LOGGER.debug("No vulnerabilities identified for %s by %s".formatted(componentUuid, result.getScanner()));
            return;
        }

        try (final var qm = new QueryManager()) {
            final PersistenceManager pm = qm.getPersistenceManager();

            if (!componentExists(pm, componentUuid)) {
                LOGGER.warn("Received result for component %s (token: %s), but it does not exist (anymore?)"
                        .formatted(componentUuid, result.getKey().getScanToken()));
                return;
            }

            for (final org.hyades.proto.vuln.v1.Vulnerability hyadesVuln : result.getVulnerabilitiesList()) {
                final Vulnerability vuln;
                try {
                    vuln = ModelConverter.convert(hyadesVuln);
                } catch (RuntimeException e) {
                    LOGGER.error("Failed to convert reported vulnerability to internal model", e);
                    return;
                }

                final Vulnerability persistentVuln = persistVulnerability(pm, vuln);
                addVulnerability(pm, componentUuid, persistentVuln, result.getScanner());
            }
        } catch (Exception e) {
            LOGGER.error("An unexpected error occurred while processing record %s".formatted(record), e);
        }
    }

    private Vulnerability persistVulnerability(final PersistenceManager pm, final Vulnerability vuln) {
        final int maxRetryAttempts = 3;
        Vulnerability persistentVuln = null;

        // It is possible that the same vulnerability is reported for multiple components in parallel,
        // causing unique constraint violations when attempting to insert into the VULNERABILITY table.
        // In such cases, we can get away with simply retrying to SELECT or INSERT again. We'll attempt
        // up to 3 times before giving up.
        for (int i = 0; i < maxRetryAttempts; i++) {
            final Transaction trx = pm.currentTransaction();
            try {
                trx.begin();

                final Query<Vulnerability> query = pm.newQuery(Vulnerability.class);
                query.setFilter("vulnId == :vulnId && source == :source");
                query.setParameters(vuln.getVulnId(), vuln.getSource());
                persistentVuln = query.executeUnique();
                if (persistentVuln != null) {
                    break;
                }

                persistentVuln = pm.makePersistent(vuln);
                trx.commit();
            } catch (JDODataStoreException e) {
                // TODO: DataNucleus doesn't map constraint violation exceptions very well,
                // so we have to depend on the exception of the underlying JDBC driver to
                // tell us what happened. We currently only handle PostgreSQL, but we'll have
                // to do the same for at least H2 and MSSQL.
                if (ExceptionUtils.getRootCause(e) instanceof final SQLException se
                        && PSQLState.UNIQUE_VIOLATION.getState().equals(se.getSQLState())) {
                    continue; // Retry
                }

                throw e;
            } finally {
                if (trx.isActive()) {
                    trx.rollback();
                }
            }
        }

        return Optional.ofNullable(persistentVuln)
                .orElseThrow(() -> new IllegalStateException(
                        "Failed to persist vulnerability %s after %d attempts".formatted(vuln, maxRetryAttempts)));
    }

    private boolean componentExists(final PersistenceManager pm, final UUID uuid) {
        final Transaction trx = pm.currentTransaction();
        try {
            trx.begin();
            final Query<Component> query = pm.newQuery(Component.class);
            query.setFilter("uuid == :uuid");
            query.setParameters(uuid);
            query.setResult("count(this)");
            return query.executeResultUnique(Long.class) > 0;
        } finally {
            trx.rollback(); // Read-only transaction, no need to commit anything
        }
    }

    private void addVulnerability(final PersistenceManager pm, final UUID componentUuid, final Vulnerability vuln, Scanner scanner) {
        final Transaction trx = pm.currentTransaction();
        try {
            trx.begin();
            Query<Component> query = pm.newQuery(Component.class);
            query.setFilter("uuid == :uuid");
            query.setParameters(componentUuid);
            Component component = query.executeUnique();
            component.addVulnerability(vuln);
            component = pm.makePersistent(component);
            var finding = new FindingAttribution(component, vuln, getAnalyzerIdentity(scanner), null, null);
            pm.makePersistent(finding);
            trx.commit();
        } finally {
            if (trx.isActive()) {
                trx.rollback();
            }
        }
    }

    private AnalyzerIdentity getAnalyzerIdentity(Scanner scanner) {
        return switch(scanner) {
            case SCANNER_INTERNAL -> AnalyzerIdentity.INTERNAL_ANALYZER;
            case SCANNER_OSSINDEX -> AnalyzerIdentity.OSSINDEX_ANALYZER;
            case SCANNER_SNYK -> AnalyzerIdentity.SNYK_ANALYZER;
            case SCANNER_NONE, UNRECOGNIZED -> AnalyzerIdentity.NONE;
        };
    }

}
