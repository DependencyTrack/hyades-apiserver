package org.dependencytrack.event.kafka.processor;

import alpine.common.logging.Logger;
import alpine.common.metrics.Metrics;
import alpine.notification.Notification;
import alpine.notification.NotificationLevel;
import io.micrometer.core.instrument.Timer;
import org.apache.kafka.streams.processor.api.ContextualFixedKeyProcessor;
import org.apache.kafka.streams.processor.api.ContextualProcessor;
import org.apache.kafka.streams.processor.api.FixedKeyRecord;
import org.dependencytrack.event.kafka.KafkaEventDispatcher;
import org.dependencytrack.event.kafka.KafkaEventHeaders;
import org.dependencytrack.event.kafka.KafkaUtil;
import org.dependencytrack.model.AnalyzerIdentity;
import org.dependencytrack.model.Component;
import org.dependencytrack.model.FindingAttribution;
import org.dependencytrack.model.Vulnerability;
import org.dependencytrack.model.VulnerabilityAlias;
import org.dependencytrack.model.VulnerabilityAnalysisLevel;
import org.dependencytrack.notification.NotificationConstants;
import org.dependencytrack.notification.NotificationGroup;
import org.dependencytrack.notification.NotificationScope;
import org.dependencytrack.notification.vo.NewVulnerabilityIdentified;
import org.dependencytrack.notification.vo.NewVulnerableDependency;
import org.dependencytrack.parser.hyades.ModelConverterCdxToVuln;
import org.dependencytrack.persistence.QueryManager;
import org.dependencytrack.util.PersistenceUtil;
import org.hyades.proto.vulnanalysis.v1.ScanKey;
import org.hyades.proto.vulnanalysis.v1.ScanResult;
import org.hyades.proto.vulnanalysis.v1.ScanStatus;
import org.hyades.proto.vulnanalysis.v1.Scanner;
import org.hyades.proto.vulnanalysis.v1.ScannerResult;

import javax.jdo.Query;
import java.util.Collection;
import java.util.HashSet;
import java.util.List;
import java.util.NoSuchElementException;
import java.util.Set;
import java.util.UUID;

import static org.dependencytrack.parser.hyades.ModelConverterCdxToVuln.convert;
import static org.dependencytrack.util.NotificationUtil.generateNotificationContent;
import static org.dependencytrack.util.NotificationUtil.generateNotificationTitle;
import static org.dependencytrack.util.PersistenceUtil.applyIfChanged;
import static org.dependencytrack.util.PersistenceUtil.applyIfNonNullAndChanged;
import static org.dependencytrack.util.VulnerabilityUtil.canBeMirrored;
import static org.dependencytrack.util.VulnerabilityUtil.isAuthoritativeSource;
import static org.dependencytrack.util.VulnerabilityUtil.isMirroringEnabled;
import static org.hyades.proto.vulnanalysis.v1.ScanStatus.SCAN_STATUS_FAILED;
import static org.hyades.proto.vulnanalysis.v1.Scanner.SCANNER_INTERNAL;

/**
 * A {@link ContextualProcessor} responsible for processing {@link ScanResult}s.
 */
public class VulnerabilityScanResultProcessor extends ContextualFixedKeyProcessor<ScanKey, ScanResult, ScanResult> {

    private static final Logger LOGGER = Logger.getLogger(VulnerabilityScanResultProcessor.class);
    private static final Timer TIMER = Timer.builder("vuln_scan_result_processing")
            .description("Time taken to process vulnerability scan results")
            .register(Metrics.getRegistry());

    private final KafkaEventDispatcher eventDispatcher = new KafkaEventDispatcher();

    @Override
    public void process(final FixedKeyRecord<ScanKey, ScanResult> record) {
        final ScanKey scanKey = record.key();
        final ScanResult result = record.value();
        final UUID componentUuid = UUID.fromString(scanKey.getComponentUuid());
        final VulnerabilityAnalysisLevel analysisLevel = determineAnalysisLevel(record);
        final boolean isNewComponent = determineIsComponentNew(record);
        final Timer.Sample timerSample = Timer.start();
        try (final var qm = new QueryManager().withL2CacheDisabled()) {
            final Component component = qm.getObjectByUuid(Component.class, componentUuid, List.of(Component.FetchGroup.IDENTITY.name()));
            if (component == null) {
                LOGGER.warn("Received result for component %s, but it does not exist (scanKey: %s)"
                        .formatted(componentUuid, prettyPrint(scanKey)));
                return;
            }
            
            for (final ScannerResult scannerResult : result.getScannerResultsList()) {
                processScannerResult(qm, component, scanKey, scannerResult, analysisLevel, isNewComponent);
            }
        } catch (Exception e) {
            LOGGER.error("Failed to process scan result for component %s (scanKey: %s)"
                    .formatted(componentUuid, prettyPrint(scanKey)), e);
        } finally {
            timerSample.stop(TIMER);
            context().forward(record);
        }
    }

    private void processScannerResult(final QueryManager qm, final Component component,
                                      final ScanKey scanKey, final ScannerResult scannerResult,
                                      final VulnerabilityAnalysisLevel analysisLevel,
                                      final boolean isNewComponent) {
        if (scannerResult.getStatus() == SCAN_STATUS_FAILED) {
            final var message = "Scan of component %s with %s failed (scanKey: %s): %s"
                    .formatted(component.getUuid(), scannerResult.getScanner(), prettyPrint(scanKey), scannerResult.getFailureReason());
            eventDispatcher.dispatchAsync(component.getProject().getUuid(), new Notification()
                    .scope(NotificationScope.SYSTEM)
                    .group(NotificationGroup.ANALYZER)
                    .level(NotificationLevel.ERROR)
                    .title(NotificationConstants.Title.ANALYZER_ERROR)
                    .content(message));
            LOGGER.warn(message);
            return;
        } else if (scannerResult.getStatus() != ScanStatus.SCAN_STATUS_SUCCESSFUL) {
            LOGGER.warn("Unable to process results from %s with status %s; Dropping record (scanKey: %s)"
                    .formatted(scannerResult.getScanner(), scannerResult.getStatus(), prettyPrint(scanKey)));
            return;
        }

        final Set<Vulnerability> syncedVulns = syncVulnerabilities(qm, scanKey, scannerResult);
        LOGGER.debug("Synchronized %d vulnerabilities reported by %s for %s (scanKey: %s)"
                .formatted(syncedVulns.size(), scannerResult.getScanner(), scanKey.getComponentUuid(), prettyPrint(scanKey)));

        //send notification if there is a new vulnerable component
        if(isNewComponent && !syncedVulns.isEmpty()) {
            final Component detachedComponent = qm.getPersistenceManager().detachCopy(component);
            eventDispatcher.dispatchAsync(component.getProject().getUuid(), new Notification()
                    .scope(NotificationScope.PORTFOLIO)
                    .group(NotificationGroup.NEW_VULNERABLE_DEPENDENCY)
                    .level(NotificationLevel.INFORMATIONAL)
                    .title(generateNotificationTitle(NotificationConstants.Title.NEW_VULNERABLE_DEPENDENCY, detachedComponent.getProject()))
                    .content(generateNotificationContent(component, syncedVulns))
                    .subject(new NewVulnerableDependency(detachedComponent, syncedVulns)));
        }


        final Set<Vulnerability> newVulns = addVulnerabilities(qm, component, syncedVulns, scannerResult.getScanner());
        LOGGER.debug("Identified %d new vulnerabilities for %s with %s (scanKey: %s)"
                .formatted(newVulns.size(), scanKey.getComponentUuid(), scannerResult.getScanner(), prettyPrint(scanKey)));

        if (!newVulns.isEmpty()) {
            final Component detachedComponent = qm.getPersistenceManager().detachCopy(component);
            final Collection<Vulnerability> detachedVulns = qm.getPersistenceManager().detachCopyAll(newVulns);
            for (final Vulnerability detachedVuln : detachedVulns) {
                eventDispatcher.dispatchAsync(component.getProject().getUuid(), new Notification()
                        .scope(NotificationScope.PORTFOLIO)
                        .group(NotificationGroup.NEW_VULNERABILITY)
                        .level(NotificationLevel.INFORMATIONAL)
                        .title(generateNotificationTitle(NotificationConstants.Title.NEW_VULNERABILITY, detachedComponent.getProject()))
                        .content(generateNotificationContent(detachedVuln))
                        .subject(new NewVulnerabilityIdentified(detachedVuln, detachedComponent, analysisLevel)));
            }
        }
    }

    /**
     * Synchronize vulnerabilities reported in a given {@link ScannerResult} with the datastore.
     *
     * @param qm            The {@link QueryManager} to use
     * @param scanKey       The {@link ScanKey} associated with the {@link ScannerResult}
     * @param scannerResult The {@link ScannerResult} to synchronize vulnerabilities from
     * @return A {@link Set} of synchronized {@link Vulnerability}s
     */
    private Set<Vulnerability> syncVulnerabilities(final QueryManager qm, final ScanKey scanKey, final ScannerResult scannerResult) {
        final var syncedVulns = new HashSet<Vulnerability>();

        for (final org.cyclonedx.proto.v1_4.Vulnerability reportedVuln : scannerResult.getBom().getVulnerabilitiesList()) {
            final Vulnerability vuln;
            try {
                vuln = ModelConverterCdxToVuln.convert(qm, scannerResult.getBom(), reportedVuln, true);
            } catch (RuntimeException e) {
                LOGGER.error("Failed to convert vulnerability %s/%s (reported by %s for component %s) to internal model (scanKey: %s)"
                        .formatted(reportedVuln.getSource(), reportedVuln.getId(), scannerResult.getScanner(), scanKey.getComponentUuid(), prettyPrint(scanKey)), e);
                continue;
            }

            try {
                syncedVulns.add(syncVulnerability(qm, vuln, scannerResult.getScanner()));
                if (vuln.getAliases() != null && !vuln.getAliases().isEmpty()) {
                    for (VulnerabilityAlias alias : vuln.getAliases()) {
                        qm.synchronizeVulnerabilityAlias(alias);
                    }
                }
            } catch (RuntimeException e) {
                // Use a broad catch here, so we can still try to process other
                // vulnerabilities, even though processing one of them failed.

                LOGGER.warn("Failed to synchronize vulnerability %s/%s (reported by %s for component %s; scanKey: %s)"
                        .formatted(vuln.getSource(), vuln.getVulnId(), scannerResult.getScanner(), scanKey.getComponentUuid(), prettyPrint(scanKey)), e);
            }
        }

        return syncedVulns;
    }

    /**
     * Synchronize a given {@link Vulnerability} as reported by a given {@link Scanner} with the datastore.
     * <p>
     * This method differs from {@link QueryManager#synchronizeVulnerability(Vulnerability, boolean)} in that it expects
     * an active {@link javax.jdo.Transaction}, and only calls setters of existing vulnerabilities when the respective
     * value actually changed, saving network round-trips.
     *
     * @param qm      The {@link QueryManager} to use
     * @param vuln    The {@link Vulnerability} to synchronize
     * @param scanner The {@link AnalyzerIdentity} that reported the vulnerability
     * @return The synchronized {@link Vulnerability}
     * @throws IllegalStateException  When no {@link javax.jdo.Transaction} is active
     * @throws NoSuchElementException When the reported vulnerability is internal, but does not exist in the datastore
     */
    private Vulnerability syncVulnerability(final QueryManager qm, final Vulnerability vuln, final Scanner scanner) {
        // It is possible that the same vulnerability is reported for multiple components in parallel,
        // causing unique constraint violations when attempting to INSERT into the VULNERABILITY table.
        // In such cases, we can get away with simply retrying to SELECT or INSERT again.
        return qm.runInRetryableTransaction(() -> {
            final Vulnerability existingVuln;
            final Query<Vulnerability> query = qm.getPersistenceManager().newQuery(Vulnerability.class);
            try {
                query.setFilter("vulnId == :vulnId && source == :source");
                query.setParameters(vuln.getVulnId(), vuln.getSource());
                existingVuln = query.executeUnique();
            } finally {
                query.closeAll();
            }

            if (existingVuln == null) {
                if (Vulnerability.Source.INTERNAL.name().equals(vuln.getSource())) {
                    throw new NoSuchElementException("An internal vulnerability with ID %s does not exist".formatted(vuln.getVulnId()));
                }

                return qm.getPersistenceManager().makePersistent(vuln);
            }

            if (canUpdateVulnerability(existingVuln, scanner)) {
                var updated = false;

                // TODO: Consider using something like javers to get a rich diff of WHAT changed; https://github.com/javers/javers
                updated |= applyIfChanged(existingVuln, vuln, Vulnerability::getTitle, existingVuln::setTitle);
                updated |= applyIfChanged(existingVuln, vuln, Vulnerability::getSubTitle, existingVuln::setSubTitle);
                updated |= applyIfChanged(existingVuln, vuln, Vulnerability::getDescription, existingVuln::setDescription);
                updated |= applyIfChanged(existingVuln, vuln, Vulnerability::getDetail, existingVuln::setDetail);
                updated |= applyIfChanged(existingVuln, vuln, Vulnerability::getRecommendation, existingVuln::setRecommendation);
                updated |= applyIfChanged(existingVuln, vuln, Vulnerability::getReferences, existingVuln::setReferences);
                updated |= applyIfChanged(existingVuln, vuln, Vulnerability::getCredits, existingVuln::setCredits);
                updated |= applyIfChanged(existingVuln, vuln, Vulnerability::getCreated, existingVuln::setCreated);
                updated |= applyIfChanged(existingVuln, vuln, Vulnerability::getPublished, existingVuln::setPublished);
                updated |= applyIfChanged(existingVuln, vuln, Vulnerability::getUpdated, existingVuln::setUpdated);
                updated |= applyIfChanged(existingVuln, vuln, Vulnerability::getCwes, existingVuln::setCwes);
                // Calling setSeverity nulls all CVSS and OWASP RR fields. getSeverity calculates the severity on-the-fly,
                // and will return UNASSIGNED even when no severity is set explicitly. Thus, calling setSeverity
                // must happen before CVSS and OWASP RR fields are set, to avoid null-ing them again.
                updated |= applyIfChanged(existingVuln, vuln, Vulnerability::getSeverity, existingVuln::setSeverity);
                updated |= applyIfChanged(existingVuln, vuln, Vulnerability::getCvssV2BaseScore, existingVuln::setCvssV2BaseScore);
                updated |= applyIfChanged(existingVuln, vuln, Vulnerability::getCvssV2ImpactSubScore, existingVuln::setCvssV2ImpactSubScore);
                updated |= applyIfChanged(existingVuln, vuln, Vulnerability::getCvssV2ExploitabilitySubScore, existingVuln::setCvssV2ExploitabilitySubScore);
                updated |= applyIfChanged(existingVuln, vuln, Vulnerability::getCvssV2Vector, existingVuln::setCvssV2Vector);
                updated |= applyIfChanged(existingVuln, vuln, Vulnerability::getCvssV3BaseScore, existingVuln::setCvssV3BaseScore);
                updated |= applyIfChanged(existingVuln, vuln, Vulnerability::getCvssV3ImpactSubScore, existingVuln::setCvssV3ImpactSubScore);
                updated |= applyIfChanged(existingVuln, vuln, Vulnerability::getCvssV3ExploitabilitySubScore, existingVuln::setCvssV3ExploitabilitySubScore);
                updated |= applyIfChanged(existingVuln, vuln, Vulnerability::getCvssV3Vector, existingVuln::setCvssV3Vector);
                updated |= applyIfChanged(existingVuln, vuln, Vulnerability::getOwaspRRLikelihoodScore, existingVuln::setOwaspRRLikelihoodScore);
                updated |= applyIfChanged(existingVuln, vuln, Vulnerability::getOwaspRRTechnicalImpactScore, existingVuln::setOwaspRRTechnicalImpactScore);
                updated |= applyIfChanged(existingVuln, vuln, Vulnerability::getOwaspRRBusinessImpactScore, existingVuln::setOwaspRRBusinessImpactScore);
                updated |= applyIfChanged(existingVuln, vuln, Vulnerability::getOwaspRRVector, existingVuln::setOwaspRRVector);
                // Aliases of existingVuln will always be null, as they'd have to be fetched separately.
                // Synchronization of aliases is performed after synchronizing the vulnerability.
                // updated |= applyIfChanged(existingVuln, vuln, Vulnerability::getAliases, existingVuln::setAliases);

                updated |= applyIfChanged(existingVuln, vuln, Vulnerability::getVulnerableVersions, existingVuln::setVulnerableVersions);
                updated |= applyIfChanged(existingVuln, vuln, Vulnerability::getPatchedVersions, existingVuln::setPatchedVersions);
                // EPSS is an additional enrichment that no scanner currently provides.
                // We don't want EPSS scores of CVEs to be purged just because the CVE information came from e.g. OSS Index.
                updated |= applyIfNonNullAndChanged(existingVuln, vuln, Vulnerability::getEpssScore, existingVuln::setEpssScore);
                updated |= applyIfNonNullAndChanged(existingVuln, vuln, Vulnerability::getEpssPercentile, existingVuln::setEpssPercentile);

                if (updated) {
                    // TODO: Send a notification?
                    //   (But notifications should only be sent if the transaction was committed)
                    // TODO: Reduce to DEBUG; It's set to WARN for testing
                    LOGGER.warn("Vulnerability %s/%s was updated by %s".formatted(vuln.getSource(), vuln.getVulnId(), scanner));
                }
            }

            return existingVuln;
        }, PersistenceUtil::isUniqueConstraintViolation);
    }

    /**
     * Associate a given {@link Set} of {@link Vulnerability}s with a given {@link Component}.
     * <p>
     * If a {@link Vulnerability} was not previously associated with the {@link Component},
     * a {@link FindingAttribution} will be created for the {@link Scanner}.
     *
     * @param qm        The {@link QueryManager} to use
     * @param component The {@link Component} to associate with
     * @param vulns     The {@link Vulnerability}s to associate with
     * @param scanner   The {@link Scanner} that identified the association
     * @return A {@link Set} of {@link Vulnerability}s that were not previously associated with the {@link Component}
     */
    private Set<Vulnerability> addVulnerabilities(final QueryManager qm, final Component component,
                                                  final Set<Vulnerability> vulns, final Scanner scanner) {
        final var newVulns = new HashSet<Vulnerability>();

        for (final Vulnerability vuln : vulns) {
            qm.runInTransaction(() -> {
                if (!qm.contains(vuln, component)) {
                    component.addVulnerability(vuln);
                    qm.getPersistenceManager().makePersistent(new FindingAttribution(
                            component, vuln, convert(scanner), null, null));
                    newVulns.add(vuln);
                }
            });
        }

        return newVulns;
    }

    private boolean canUpdateVulnerability(final Vulnerability vuln, final Scanner scanner) {
        var canUpdate = true;

        // Results from the internal scanner only contain vulnId and source, nothing else.
        // As they only refer to existing vulnerabilities in the database, no update must be performed.
        canUpdate &= scanner != SCANNER_INTERNAL;

        // Internal vulnerabilities can only be updated via REST API.
        canUpdate &= !Vulnerability.Source.INTERNAL.name().equals(vuln.getSource());

        // If the scanner is also the authoritative source of the given vulnerability,
        // it should be able to update it. This will be the case for the OSS Index scanner
        // and sonatype-XXX vulnerabilities for example.
        canUpdate &= isAuthoritativeSource(vuln, convert(scanner))
                // Alternatively, if the vulnerability could be mirrored, but mirroring
                // is disabled, it is OK to override any existing data.
                //
                // Ideally, we'd track the data from all sources instead of just overriding
                // it, but for now this will have to do it.
                || (canBeMirrored(vuln) && !isMirroringEnabled(vuln));

        return canUpdate;
    }

    private static VulnerabilityAnalysisLevel determineAnalysisLevel(final FixedKeyRecord<?, ?> record) {
        return KafkaUtil.getEventHeader(record.headers(), KafkaEventHeaders.VULN_ANALYSIS_LEVEL)
                .map(value -> {
                    try {
                        return VulnerabilityAnalysisLevel.valueOf(value);
                    } catch (IllegalArgumentException e) {
                        LOGGER.warn("The reported analysis type %s is invalid, assuming %s"
                                .formatted(value, VulnerabilityAnalysisLevel.PERIODIC_ANALYSIS));
                        return VulnerabilityAnalysisLevel.PERIODIC_ANALYSIS;
                    }
                })
                .orElse(VulnerabilityAnalysisLevel.PERIODIC_ANALYSIS);
    }

    private static boolean determineIsComponentNew(final FixedKeyRecord<?, ?> record) {
        return KafkaUtil.getEventHeader(record.headers(), KafkaEventHeaders.IS_NEW_COMPONENT)
                .map(Boolean::parseBoolean)
                .orElse(false);
    }

    private static String prettyPrint(final ScanKey scanKey) {
        return "%s/%s".formatted(scanKey.getScanToken(), scanKey.getComponentUuid());
    }

}
