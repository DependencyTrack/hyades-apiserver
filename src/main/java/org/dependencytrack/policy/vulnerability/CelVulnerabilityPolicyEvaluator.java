package org.dependencytrack.policy.vulnerability;

import alpine.common.logging.Logger;
import alpine.common.metrics.Metrics;
import alpine.server.cache.AbstractCacheManager;
import com.google.api.expr.v1alpha1.Type;
import com.google.protobuf.Descriptors.FieldDescriptor;
import io.micrometer.core.instrument.Timer;
import org.apache.commons.collections4.MultiValuedMap;
import org.apache.commons.collections4.multimap.HashSetValuedHashMap;
import org.apache.commons.lang3.NotImplementedException;
import org.apache.commons.lang3.reflect.FieldUtils;
import org.apache.commons.lang3.tuple.Pair;
import org.dependencytrack.persistence.QueryManager;
import org.dependencytrack.policy.cel.CelPolicyScript;
import org.dependencytrack.policy.cel.CelPolicyScriptHost;
import org.dependencytrack.policy.cel.mapping.ComponentProjection;
import org.dependencytrack.policy.cel.mapping.ProjectProjection;
import org.dependencytrack.proto.policy.v1.Component;
import org.dependencytrack.proto.policy.v1.Project;
import org.dependencytrack.proto.policy.v1.Vulnerability;
import org.projectnessie.cel.tools.ScriptCreateException;
import org.projectnessie.cel.tools.ScriptExecutionException;

import javax.jdo.Query;
import java.time.Duration;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;
import java.util.function.Function;
import java.util.stream.Collectors;

import static java.util.Map.entry;
import static java.util.Objects.requireNonNull;
import static org.dependencytrack.policy.cel.CelPolicyLibrary.TYPE_COMPONENT;
import static org.dependencytrack.policy.cel.CelPolicyLibrary.TYPE_PROJECT;
import static org.dependencytrack.policy.cel.CelPolicyLibrary.TYPE_VULNERABILITY;
import static org.dependencytrack.policy.cel.mapping.FieldMappingUtil.getFieldMappings;

/**
 * A {@link VulnerabilityPolicyEvaluator} capable of evaluating conditions as CEL expressions.
 */
public class CelVulnerabilityPolicyEvaluator implements VulnerabilityPolicyEvaluator {

    private static final Logger LOGGER = Logger.getLogger(CelVulnerabilityPolicyEvaluator.class);

    private final VulnerabilityPolicyProvider policyProvider;
    private final CelPolicyScriptHost scriptHost;
    private final AbstractCacheManager cacheManager;

    public CelVulnerabilityPolicyEvaluator() {
        this(new DummyVulnerabilityPolicyProvider(), CelPolicyScriptHost.getInstance(), new CelVulnerabilityPolicyCacheManager());
    }

    CelVulnerabilityPolicyEvaluator(final VulnerabilityPolicyProvider policyProvider,
                                    final CelPolicyScriptHost scriptHost, final AbstractCacheManager cacheManager) {
        this.policyProvider = policyProvider;
        this.scriptHost = scriptHost;
        this.cacheManager = cacheManager;

        // FIXME: Caches are not initialized until the first entry is added...
        cacheManager.put("foo", Project.getDefaultInstance());
        cacheManager.put("foo", Component.getDefaultInstance());
        cacheManager.put("foo", Vulnerability.getDefaultInstance());
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public Map<UUID, VulnerabilityPolicy> evaluate(final Collection<Vulnerability> vulns, final Component component, final Project project) {
        final Timer.Sample timerSample = Timer.start();
        try {
            return evaluateInternal(vulns, component, project);
        } finally {
            final long evaluationDurationNs = timerSample.stop(Timer
                    .builder("dtrack_vuln_policy_evaluation")
                    .register(Metrics.getRegistry()));
            if (Duration.ofNanos(evaluationDurationNs).toMillis() >= 500) {
                // TODO: Issue this warning based on average duration instead.
                LOGGER.warn("Evaluation took longer than 500ms; Potential system performance degradation");
            }
        }
    }

    private Map<UUID, VulnerabilityPolicy> evaluateInternal(final Collection<Vulnerability> vulns, final Component component, final Project project) {
        requireNonNull(project, "project must not be null");
        requireNonNull(component, "component must not be null");
        requireNonNull(vulns, "vulns must not be null");

        // UUIDs are the bare minimum, everything else can be loaded if required.
        if (project.getUuid().isBlank()) {
            throw new IllegalArgumentException("project must have a UUID");
        }
        if (component.getUuid().isBlank()) {
            throw new IllegalArgumentException("component must have a UUID");
        }
        for (final Vulnerability vuln : vulns) {
            if (vuln.getUuid().isBlank()) {
                throw new IllegalArgumentException("vulns must have a UUID");
            }
        }

        if (vulns.isEmpty()) {
            LOGGER.debug("No vulnerabilities to evaluate policies for");
            return Collections.emptyMap();
        }

        // TODO: Can this be cached? Would be good to avoid having to do a DB query for each component.
        final List<VulnerabilityPolicy> applicablePolicies = policyProvider.getApplicablePolicies(project);
        if (applicablePolicies == null || applicablePolicies.isEmpty()) {
            LOGGER.debug("No applicable policies found");
            return Collections.emptyMap();
        }

        // Compile condition scripts and group them by policy name.
        // Using LinkedHashMap to preserve the order of the policies.
        final var compiledScriptsByPolicyName = new LinkedHashMap<String, List<CelPolicyScript>>();
        for (final VulnerabilityPolicy policy : applicablePolicies) {
            for (final String condition : policy.conditions()) {
                compiledScriptsByPolicyName.compute(policy.name(), (policyName, compiledScripts) -> {
                    final CelPolicyScript compiledScript = compileConditionScript(condition);
                    if (compiledScript == null) {
                        return compiledScripts;
                    }
                    if (compiledScripts == null) {
                        final var scripts = new ArrayList<CelPolicyScript>();
                        scripts.add(compiledScript);
                        return scripts;
                    } else {
                        compiledScripts.add(compiledScript);
                        return compiledScripts;
                    }
                });
            }
        }

        // Determine requirements across all condition scripts.
        final MultiValuedMap<Type, String> scriptRequirements = compiledScriptsByPolicyName.values().stream()
                .flatMap(Collection::stream)
                .map(CelPolicyScript::getRequirements)
                .reduce(new HashSetValuedHashMap<>(), (lhs, rhs) -> {
                    lhs.putAll(rhs);
                    return lhs;
                });

        final Project scriptArgProject;
        if (scriptRequirements.containsKey(TYPE_PROJECT)) {
            scriptArgProject = ensureRequirementsLoaded(project, scriptRequirements);
        } else {
            scriptArgProject = org.dependencytrack.proto.policy.v1.Project.getDefaultInstance();
        }

        final Component scriptArgComponent;
        if (scriptRequirements.containsKey(TYPE_COMPONENT)) {
            scriptArgComponent = ensureRequirementsLoaded(component, scriptRequirements);
        } else {
            scriptArgComponent = org.dependencytrack.proto.policy.v1.Component.getDefaultInstance();
        }

        final Map<String, Vulnerability> scriptArgVulns;
        if (scriptRequirements.containsKey(TYPE_VULNERABILITY)) {
            scriptArgVulns = ensureRequirementsLoaded(vulns, scriptRequirements);
        } else {
            scriptArgVulns = vulns.stream()
                    .map(vuln -> entry(vuln.getUuid(), vuln))
                    .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));
        }

        // Index policies by their (unique) name to make lookups easier.
        final Map<String, VulnerabilityPolicy> policiesByName = applicablePolicies.stream()
                .collect(Collectors.toMap(VulnerabilityPolicy::name, Function.identity()));

        // Iterate over all policies IN THE ORDER THEY WERE GIVEN TO US, evaluating their conditions
        // IN THE ORDER THEY WERE GIVEN TO US.
        // TODO: Clean this up; Those nested for loops are hideous.
        final var matchedPolicies = new HashMap<UUID, VulnerabilityPolicy>();
        for (final Vulnerability protoVuln : scriptArgVulns.values()) {
            final var shortCircuitedPolicies = new HashSet<String>();

            policyLoop:
            for (final Map.Entry<String, List<CelPolicyScript>> policyNameAndScripts : compiledScriptsByPolicyName.entrySet()) {
                if (shortCircuitedPolicies.contains(policyNameAndScripts.getKey())) {
                    LOGGER.debug("Policy %s already short-circuited");
                    continue;
                }

                for (final CelPolicyScript script : policyNameAndScripts.getValue()) {
                    final Map<String, Object> scriptArguments = Map.ofEntries(
                            entry("component", scriptArgComponent),
                            entry("project", scriptArgProject),
                            entry("vuln", protoVuln)
                    );
                    try {
                        final boolean conditionMatched = script.execute(scriptArguments);
                        if (conditionMatched && policyNameAndScripts.getValue().lastIndexOf(script) == policyNameAndScripts.getValue().size() - 1) {
                            matchedPolicies.put(UUID.fromString(protoVuln.getUuid()), policiesByName.get(policyNameAndScripts.getKey()));

                            // We already matched a policy; We're done for this vulnerability.
                            break policyLoop;
                        } else if (!conditionMatched) {
                            // If we have any other policies in the pipeline with the EXACT same condition in them,
                            // mark them as short-circuited; They'll not yield a match.
                            // TODO: This should be more efficient
                            for (final Map.Entry<String, List<CelPolicyScript>> otherPolicyNameAndScripts : compiledScriptsByPolicyName.entrySet()) {
                                if (!otherPolicyNameAndScripts.getKey().equals(policyNameAndScripts.getKey()) && otherPolicyNameAndScripts.getValue().contains(script)) {
                                    LOGGER.debug("Short-circuiting policy %s".formatted(otherPolicyNameAndScripts.getKey()));
                                    shortCircuitedPolicies.add(otherPolicyNameAndScripts.getKey());
                                }
                            }

                            // Move on to the next policy in the pipeline.
                            continue policyLoop;
                        }
                    } catch (ScriptExecutionException e) {
                        LOGGER.warn("Failed to execute script for condition %s with arguments %s", e);
                        break policyLoop; // This policy can not succeed anymore; Move on to the next.
                    }
                }
            }
        }

        return matchedPolicies;
    }

    private Project ensureRequirementsLoaded(final Project project, final MultiValuedMap<Type, String> requirements) {
        final Collection<String> projectRequirements = requirements.get(TYPE_PROJECT);
        return cacheManager.get(Project.class, buildCacheKey(project.getUuid(), projectRequirements), cacheKey -> {
            final var fieldsToLoad = new HashSet<String>();
            for (final String requiredFieldName : projectRequirements) {
                final FieldDescriptor fieldDescriptor = Project.getDescriptor().findFieldByName(requiredFieldName);
                if (fieldDescriptor == null) {
                    LOGGER.warn("Field %s is required but does not exist for type %s"
                            .formatted(requiredFieldName, Component.getDescriptor().getFullName()));
                    continue;
                }

                if (fieldDescriptor.isRepeated() && project.getRepeatedFieldCount(fieldDescriptor) == 0) {
                    // There's no way differentiate between repeated fields being not set or just empty.
                    fieldsToLoad.add(requiredFieldName);
                } else if (!project.hasField(fieldDescriptor)) {
                    fieldsToLoad.add(requiredFieldName);
                }
            }
            if (fieldsToLoad.isEmpty()) {
                LOGGER.debug("All required project fields are already loaded");
                return project;
            }
            
            LOGGER.debug("Loading additional required project fields %s".formatted(fieldsToLoad));
            final String sqlSelectColumns = getFieldMappings(ProjectProjection.class).stream()
                    .filter(fieldMapping -> fieldsToLoad.contains(fieldMapping.protoFieldName()))
                    .map(fieldMapping -> "\"P\".\"%s\" AS \"%s\"".formatted(fieldMapping.sqlColumnName(), fieldMapping.javaFieldName()))
                    .collect(Collectors.joining(", "));
            // TODO: Handle tags, properties
            final ProjectProjection projectProjection;
            try (final var qm = new QueryManager()) {
                final Query<?> query = qm.getPersistenceManager().newQuery(Query.SQL, """
                        SELECT
                          %s
                        FROM
                          "PROJECT" AS "P"
                        WHERE
                          "UUID" = :uuid
                        """.formatted(sqlSelectColumns));
                query.setNamedParameters(Map.of("uuid", project.getUuid()));
                try {
                    projectProjection = query.executeResultUnique(ProjectProjection.class);
                } finally {
                    query.closeAll();
                }
            }

            final Project.Builder projectBuilder = project.toBuilder();
            getFieldMappings(ProjectProjection.class).stream()
                    .filter(fieldMapping -> fieldsToLoad.contains(fieldMapping.protoFieldName()))
                    .map(fieldMapping -> {
                        try {
                            return Pair.of(fieldMapping.protoFieldName(), FieldUtils.readField(projectProjection, fieldMapping.javaFieldName()));
                        } catch (IllegalAccessException e) {
                            throw new RuntimeException(e);
                        }
                    })
                    .filter(pair -> pair.getRight() != null)
                    .forEach(pair -> {
                        final var desc = Project.getDescriptor().findFieldByName(pair.getKey());
                        projectBuilder.setField(desc, pair.getValue());
                    });
            return projectBuilder.build();
        });
    }

    private Component ensureRequirementsLoaded(final Component component, final MultiValuedMap<Type, String> requirements) {
        final Collection<String> componentRequirements = requirements.get(TYPE_COMPONENT);
        return cacheManager.get(Component.class, buildCacheKey(component.getUuid(), componentRequirements), cacheKey -> {
            final var fieldsToLoad = new HashSet<String>();
            for (final String requiredField : componentRequirements) {
                final FieldDescriptor fieldDescriptor = Component.getDescriptor().findFieldByName(requiredField);
                if (fieldDescriptor == null) {
                    LOGGER.warn("Field %s is required but does not exist for type %s"
                            .formatted(requiredField, Component.getDescriptor().getFullName()));
                    continue;
                }

                if (fieldDescriptor.isRepeated() && component.getRepeatedFieldCount(fieldDescriptor) == 0) {
                    // There's no way differentiate between repeated fields being not set or just empty.
                    fieldsToLoad.add(requiredField);
                } else if (!component.hasField(fieldDescriptor)) {
                    fieldsToLoad.add(requiredField);
                }
            }
            if (fieldsToLoad.isEmpty()) {
                LOGGER.debug("All required component fields are already loaded");
                return component;
            }

            LOGGER.debug("Loading additional required component fields %s".formatted(fieldsToLoad));
            final String sqlSelectColumns = getFieldMappings(ComponentProjection.class).stream()
                    .filter(fieldMapping -> fieldsToLoad.contains(fieldMapping.protoFieldName()))
                    .map(fieldMapping -> "\"C\".\"%s\" AS \"%s\"".formatted(fieldMapping.sqlColumnName(), fieldMapping.javaFieldName()))
                    .collect(Collectors.joining(", "));
            final ComponentProjection componentProjection;
            try (final var qm = new QueryManager()) {
                final Query<?> query = qm.getPersistenceManager().newQuery(Query.SQL, """
                        SELECT
                          %s
                        FROM
                          "COMPONENT" AS "C"
                        WHERE
                          "UUID" = :uuid
                        """.formatted(sqlSelectColumns));
                query.setNamedParameters(Map.of("uuid", component.getUuid()));
                try {
                    componentProjection = query.executeResultUnique(ComponentProjection.class);
                } finally {
                    query.closeAll();
                }
            }

            final Component.Builder componentBuilder = component.toBuilder();
            getFieldMappings(ComponentProjection.class).stream()
                    .filter(fieldMapping -> fieldsToLoad.contains(fieldMapping.protoFieldName()))
                    .map(fieldMapping -> {
                        try {
                            return Pair.of(fieldMapping.protoFieldName(), FieldUtils.readField(componentProjection, fieldMapping.javaFieldName()));
                        } catch (IllegalAccessException e) {
                            throw new RuntimeException(e);
                        }
                    })
                    .filter(pair -> pair.getRight() != null)
                    .forEach(pair -> {
                        final var desc = Component.getDescriptor().findFieldByName(pair.getKey());
                        componentBuilder.setField(desc, pair.getValue());
                    });
            return componentBuilder.build();
        });
    }

    private Map<String, Vulnerability> ensureRequirementsLoaded(final Collection<Vulnerability> vulns,
                                                                final MultiValuedMap<Type, String> requirements) {
        return vulns.stream()
                .map(vuln -> entry(vuln.getUuid(), ensureRequirementsLoaded(vuln, requirements)))
                .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));
    }

    private Vulnerability ensureRequirementsLoaded(final Vulnerability vuln, final MultiValuedMap<Type, String> requirements) {
        final Collection<String> vulnRequirements = requirements.get(TYPE_VULNERABILITY);
        return cacheManager.get(Vulnerability.class, buildCacheKey(vuln.getUuid(), vulnRequirements), cacheKey -> {
            final var fieldsToLoad = new HashSet<String>();
            for (final String requiredField : vulnRequirements) {
                final FieldDescriptor fieldDescriptor = Vulnerability.getDescriptor().findFieldByName(requiredField);
                if (fieldDescriptor == null) {
                    LOGGER.warn("Field %s is required but does not exist for type %s"
                            .formatted(requiredField, Vulnerability.getDescriptor().getFullName()));
                    continue;
                }

                if (fieldDescriptor.isRepeated() && vuln.getRepeatedFieldCount(fieldDescriptor) == 0) {
                    // There's no way differentiate between repeated fields being not set or just empty.
                    fieldsToLoad.add(requiredField);
                } else if (!vuln.hasField(fieldDescriptor)) {
                    fieldsToLoad.add(requiredField);
                }
            }
            if (fieldsToLoad.isEmpty()) {
                LOGGER.debug("All required component fields are already loaded");
                return vuln;
            }

            // TODO: Load fields
            LOGGER.debug("Loading additional required component fields %s".formatted(fieldsToLoad));
            throw new NotImplementedException("Additional fields %s are required but couldn't be loaded".formatted(fieldsToLoad));
        });
    }

    private CelPolicyScript compileConditionScript(final String conditionScriptSrc) {
        try {
            return scriptHost.compile(conditionScriptSrc, CelPolicyScriptHost.CacheMode.CACHE);
        } catch (ScriptCreateException e) {
            LOGGER.warn("Failed to compile script %s; Condition will be skipped"
                    .formatted(conditionScriptSrc), e);
            return null;
        }
    }

    private static String buildCacheKey(final String objectIdentifier, final Collection<String> requirements) {
        return "%s-%s".formatted(objectIdentifier, requirements.stream().sorted().collect(Collectors.joining("|")));
    }

}
