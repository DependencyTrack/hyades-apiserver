package org.dependencytrack.policy.vulnerability;

import alpine.common.logging.Logger;
import alpine.server.cache.AbstractCacheManager;
import com.google.api.expr.v1alpha1.Type;
import org.apache.commons.collections4.MultiValuedMap;
import org.apache.commons.collections4.multimap.HashSetValuedHashMap;
import org.dependencytrack.policy.cel.CelPolicyScript;
import org.dependencytrack.policy.cel.CelPolicyScriptHost;
import org.dependencytrack.proto.policy.v1.Component;
import org.dependencytrack.proto.policy.v1.Project;
import org.dependencytrack.proto.policy.v1.Vulnerability;
import org.projectnessie.cel.tools.ScriptCreateException;
import org.projectnessie.cel.tools.ScriptExecutionException;

import java.util.Collection;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.UUID;
import java.util.function.Function;
import java.util.stream.Collectors;

import static java.util.Map.entry;
import static java.util.Objects.requireNonNull;
import static org.dependencytrack.policy.cel.CelPolicyLibrary.TYPE_COMPONENT;
import static org.dependencytrack.policy.cel.CelPolicyLibrary.TYPE_PROJECT;
import static org.dependencytrack.policy.cel.CelPolicyLibrary.TYPE_VULNERABILITY;
import static org.dependencytrack.util.PersistenceUtil.assertNonPersistent;

class CelVulnerabilityPolicyEvaluator implements VulnerabilityPolicyEvaluator {

    private static final Logger LOGGER = Logger.getLogger(CelVulnerabilityPolicyEvaluator.class);

    private final VulnerabilityPolicyProvider policyProvider;
    private final CelPolicyScriptHost scriptHost;
    private final AbstractCacheManager cacheManager;

    CelVulnerabilityPolicyEvaluator(final VulnerabilityPolicyProvider policyProvider,
                                    final CelPolicyScriptHost scriptHost, final AbstractCacheManager cacheManager) {
        this.policyProvider = policyProvider;
        this.scriptHost = scriptHost;
        this.cacheManager = cacheManager;
    }

    @Override
    public Map<UUID, VulnerabilityPolicy> evaluate(final org.dependencytrack.model.Project project,
                                                   final org.dependencytrack.model.Component component,
                                                   final Collection<org.dependencytrack.model.Vulnerability> vulnerabilities) {
        requireNonNull(project);
        requireNonNull(component);
        requireNonNull(vulnerabilities);

        // We don't want to trigger any database interactions when accessing fields.
        assertNonPersistent(project, "project must not be persistent");
        assertNonPersistent(component, "component must not be persistent");
        assertNonPersistent(vulnerabilities, "vulnerability must not be persistent");

        final List<VulnerabilityPolicy> applicablePolicies = policyProvider.getApplicablePolicies(project);
        if (applicablePolicies == null || applicablePolicies.isEmpty()) {
            LOGGER.debug("No applicable policies found");
            return Collections.emptyMap();
        }

        // Index policies by their (unique) name to make lookups easier.
        final Map<String, VulnerabilityPolicy> policiesByName = applicablePolicies.stream()
                .collect(Collectors.toMap(VulnerabilityPolicy::name, Function.identity()));

        // Conditions may be reused across policies. Instead of redundant evaluations,
        final MultiValuedMap<CelPolicyScript, String> policyNamesByScript = new HashSetValuedHashMap<>();

        final List<CelPolicyScript> compiledScripts = applicablePolicies.stream()
                .map(VulnerabilityPolicy::conditions)
                .flatMap(Collection::stream)
                .map(this::compileConditionScript)
                .filter(Objects::nonNull)
                .toList();

        final MultiValuedMap<Type, String> scriptRequirements = compiledScripts.stream()
                .map(CelPolicyScript::getRequirements)
                .reduce(new HashSetValuedHashMap<>(), (lhs, rhs) -> {
                    lhs.putAll(rhs);
                    return lhs;
                });

        final Project protoProject;
        if (scriptRequirements.containsKey(TYPE_PROJECT)) {
            protoProject = getProjectProto(project, scriptRequirements.get(TYPE_PROJECT));
        } else {
            protoProject = org.dependencytrack.proto.policy.v1.Project.getDefaultInstance();
        }

        final Component protoComponent;
        if (scriptRequirements.containsKey(TYPE_COMPONENT)) {
            protoComponent = getComponentProto(component, scriptRequirements.get(TYPE_COMPONENT));
        } else {
            protoComponent = org.dependencytrack.proto.policy.v1.Component.getDefaultInstance();
        }

        final Map<UUID, Vulnerability> protoVulns;
        if (scriptRequirements.containsKey(TYPE_VULNERABILITY)) {
            protoVulns = getVulnerabilityProtos(vulnerabilities, scriptRequirements.get(TYPE_VULNERABILITY));
        } else {
            protoVulns = vulnerabilities.stream()
                    .map(vuln -> entry(vuln.getUuid(), Vulnerability.getDefaultInstance()))
                    .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));
        }

        for (final org.dependencytrack.model.Vulnerability vulnerability : vulnerabilities) {
            // TODO: Retain the order of conditions for each policy.
            //   If a policy has the conditions A and B, B should never be evaluated when A did not yield a match.
            //   Each time a condition evaluates to false, we should check which policies we can short-circuit.
            for (final CelPolicyScript script : compiledScripts) {
                final Map<String, Object> scriptArguments = Map.ofEntries(
                        entry("component", protoComponent),
                        entry("project", protoProject),
                        entry("vuln", protoVulns.get(vulnerability.getUuid()))
                );
                try {
                    final boolean conditionMatched = script.execute(scriptArguments);
                } catch (ScriptExecutionException e) {
                    LOGGER.warn("Failed to execute script for condition %s with arguments %s", e);
                }
            }
        }


        return Collections.emptyMap();
    }

    private Project getProjectProto(final org.dependencytrack.model.Project project, final Collection<String> requirements) {
        return cacheManager.get(Project.class, buildCacheKey(project.getUuid(), requirements), cacheKey -> {
            LOGGER.debug("Building project proto for cache key %s".formatted(cacheKey));
            // TODO: Get object's StateManager to determine which fields are already loaded
            return null;
        });
    }

    private Component getComponentProto(final org.dependencytrack.model.Component component, final Collection<String> requirements) {
        return cacheManager.get(Component.class, buildCacheKey(component.getUuid(), requirements), cacheKey -> {
            LOGGER.debug("Building component proto for cache key %s".formatted(cacheKey));
            // TODO: Get object's StateManager to determine which fields are already loaded
            return null;
        });
    }

    private Map<UUID, Vulnerability> getVulnerabilityProtos(final Collection<org.dependencytrack.model.Vulnerability> vulnerabilities,
                                                            final Collection<String> requirements) {
        return Collections.emptyMap();
    }

    private CelPolicyScript compileConditionScript(final String conditionScriptSrc) {
        try {
            return scriptHost.compile(conditionScriptSrc, CelPolicyScriptHost.CacheMode.CACHE);
        } catch (ScriptCreateException e) {
            LOGGER.warn("Failed to compile script %s; Condition will be skipped"
                    .formatted(conditionScriptSrc), e);
            return null;
        }
    }

    private static String buildCacheKey(final UUID uuid, final Collection<String> requirements) {
        return "%s-%s".formatted(uuid, requirements.stream().sorted().collect(Collectors.joining(";")));
    }

}
