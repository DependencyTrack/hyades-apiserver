<?xml version="1.1" encoding="UTF-8" standalone="no"?>
<databaseChangeLog
        objectQuotingStrategy="QUOTE_ALL_OBJECTS"
        xmlns="http://www.liquibase.org/xml/ns/dbchangelog"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation="http://www.liquibase.org/xml/ns/dbchangelog
            http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-latest.xsd">
    <changeSet id="1" author="nscuro">
        <sql>
            CREATE TYPE WORKFLOW_RUN_STATUS AS ENUM (
              'PENDING'
            , 'RUNNING'
            , 'SUSPENDED'
            , 'CANCELLED'
            , 'COMPLETED'
            , 'FAILED'
            );

            CREATE TABLE "WORKFLOW_RUN" (
              "ID" UUID
            , "PARENT_ID" UUID
            , "WORKFLOW_NAME" TEXT NOT NULL
            , "WORKFLOW_VERSION" SMALLINT NOT NULL
            , "STATUS" WORKFLOW_RUN_STATUS NOT NULL DEFAULT 'PENDING'
            , "CUSTOM_STATUS" TEXT
            , "CONCURRENCY_GROUP_ID" TEXT
            , "PRIORITY" SMALLINT
            , "TAGS" TEXT[]
            , "LOCKED_BY" TEXT
            , "LOCKED_UNTIL" TIMESTAMPTZ(3)
            , "CREATED_AT" TIMESTAMPTZ(3) NOT NULL DEFAULT NOW()
            , "UPDATED_AT" TIMESTAMPTZ(3)
            , "STARTED_AT" TIMESTAMPTZ(3)
            , "COMPLETED_AT" TIMESTAMPTZ(3)
            , CONSTRAINT "WORKFLOW_RUN_PK" PRIMARY KEY ("ID")
            , CONSTRAINT "WORKFLOW_RUN_PARENT_FK" FOREIGN KEY ("PARENT_ID") REFERENCES "WORKFLOW_RUN" ("ID") ON DELETE CASCADE
            );

            <!--
              For workflow runs with concurrency group, maintain a sequence for the next run.
              This adds additional overhead to creation and completion of workflow runs,
              but performs magnitudes better than using a PARTITION BY window function
              in the poll query.

              https://docs.hatchet.run/blog/multi-tenant-queues#first-attempt-partition-by
              https://blog.sequinstream.com/build-your-own-sqs-or-kafka-with-postgres/
            -->
            CREATE TABLE "WORKFLOW_CONCURRENCY_GROUP" (
              "ID" TEXT
            , "NEXT_RUN_ID" UUID NOT NULL
            , CONSTRAINT "WORKFLOW_RUN_CONCURRENCY_GROUP_PK" PRIMARY KEY ("ID")
            );

            <!--
              NB: This table could be partitioned by WORKFLOW_RUN_ID since it's never queried without that ID.
              It's mostly append-only and doesn't accumulate lots of bloat, unless records are deleted (i.e. as part of workflow run retention).
            -->
            CREATE TABLE "WORKFLOW_RUN_JOURNAL" (
              "WORKFLOW_RUN_ID" UUID
            , "SEQUENCE_NUMBER" INT
            , "EVENT" BYTEA NOT NULL
            , CONSTRAINT "WORKFLOW_RUN_JOURNAL_PK" PRIMARY KEY ("WORKFLOW_RUN_ID", "SEQUENCE_NUMBER")
            , CONSTRAINT "WORKFLOW_RUN_JOURNAL_WORKFLOW_RUN_FK" FOREIGN KEY ("WORKFLOW_RUN_ID") REFERENCES "WORKFLOW_RUN" ("ID") ON DELETE CASCADE
            );

            <!--
              NB: This table could be partitioned by WORKFLOW_RUN_ID since it's never queried without that ID.
              It will usually hold ~1 record per active workflow run and thus will not get that huge.
              But since records are deleted frequently, it might accumulate quite a bit of bloat.
              Partitioning might help with that, but this remains to be verified.
            -->
            CREATE TABLE "WORKFLOW_RUN_INBOX" (
              "ID" BIGINT GENERATED ALWAYS AS IDENTITY
            , "WORKFLOW_RUN_ID" UUID NOT NULL
            , "VISIBLE_FROM" TIMESTAMPTZ(3)
            , "LOCKED_BY" TEXT
            , "DEQUEUE_COUNT" SMALLINT
            , "EVENT" BYTEA NOT NULL
            , CONSTRAINT "WORKFLOW_RUN_INBOX_PK" PRIMARY KEY ("ID")
            , CONSTRAINT "WORKFLOW_RUN_INBOX_WORKFLOW_RUN_FK" FOREIGN KEY ("WORKFLOW_RUN_ID") REFERENCES "WORKFLOW_RUN" ("ID") ON DELETE CASCADE
            );

            CREATE TABLE "WORKFLOW_ACTIVITY_TASK" (
              "WORKFLOW_RUN_ID" UUID
            , "SCHEDULED_EVENT_ID" INT
            , "ACTIVITY_NAME" TEXT NOT NULL
            , "PRIORITY" SMALLINT
            , "ARGUMENT" BYTEA
            , "VISIBLE_FROM" TIMESTAMPTZ(3)
            , "LOCKED_BY" TEXT
            , "LOCKED_UNTIL" TIMESTAMPTZ(3)
            , "CREATED_AT" TIMESTAMPTZ(3) NOT NULL DEFAULT NOW()
            , "UPDATED_AT" TIMESTAMPTZ(3)
            , CONSTRAINT "WORKFLOW_ACTIVITY_TASK_PK" PRIMARY KEY ("WORKFLOW_RUN_ID", "SCHEDULED_EVENT_ID")
            , CONSTRAINT "WORKFLOW_ACTIVITY_TASK_WORKFLOW_RUN_FK" FOREIGN KEY ("WORKFLOW_RUN_ID") REFERENCES "WORKFLOW_RUN" ("ID") ON DELETE CASCADE
            );

            CREATE INDEX "WORKFLOW_RUN_POLL_IDX"
                ON "WORKFLOW_RUN" (
                      "PRIORITY" DESC NULLS LAST
                    , "CREATED_AT"
                    , "WORKFLOW_NAME"
                    , "LOCKED_UNTIL")
                INCLUDE ("ID", "CONCURRENCY_GROUP_ID")
              WHERE "STATUS" = ANY('{PENDING, RUNNING, SUSPENDED}'::WORKFLOW_RUN_STATUS[]);

            CREATE INDEX "WORKFLOW_RUN_TAGS_IDX"
                ON "WORKFLOW_RUN" USING GIN ("TAGS")
                WHERE "TAGS" IS NOT NULL;

            CREATE INDEX "WORKFLOW_RUN_INBOX_POLL_IDX"
                ON "WORKFLOW_RUN_INBOX" ("WORKFLOW_RUN_ID", "VISIBLE_FROM");

            <!-- TODO: Verify if all these columns are indeed needed for an index-only scan. -->
            CREATE INDEX "WORKFLOW_ACTIVITY_TASK_POLL_IDX"
                ON "WORKFLOW_ACTIVITY_TASK" (
                      "PRIORITY" DESC NULLS LAST
                    , "CREATED_AT"
                    , "ACTIVITY_NAME"
                    , "LOCKED_UNTIL"
                    , "VISIBLE_FROM")
                INCLUDE ("WORKFLOW_RUN_ID", "SCHEDULED_EVENT_ID");

            ALTER TABLE "WORKFLOW_RUN" SET (AUTOVACUUM_VACUUM_SCALE_FACTOR = 0.02);
            ALTER TABLE "WORKFLOW_CONCURRENCY_GROUP" SET (AUTOVACUUM_VACUUM_SCALE_FACTOR = 0.02);
            ALTER TABLE "WORKFLOW_RUN_INBOX" SET (AUTOVACUUM_VACUUM_SCALE_FACTOR = 0.02);
            ALTER TABLE "WORKFLOW_ACTIVITY_TASK" SET (AUTOVACUUM_VACUUM_SCALE_FACTOR = 0.02);
        </sql>
    </changeSet>
</databaseChangeLog>